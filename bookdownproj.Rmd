---
title: "Long-read Single-Cell RNA-seq analysis tutorial"
author: "<strong>Sefi Prawer</strong><br>Postdoctoral Research Fellow in Long Reads and Single-Cell Transcriptomics<br>University of Melbourne"
date: "`r Sys.Date()`"
output:
  bookdown::gitbook:
    code_folding: show
    split_bib: no
book_filename: "bookdownproj"
output_dir: docs
delete_merged_file: true
language:
  ui:
    chapter_name: "Chapter "
bibliography: references.bib
csl: apa.csl
link-citations: yes
---

# **Introduction**

Placeholder


## Prerequisites
## Getting Started with the Data
## Dataset Information
## Citation
## Contact

<!--chapter:end:index.Rmd-->


# **Setup**

Placeholder


## Load in required packages
## Creating resource files.
## Convert count matrices from Gene ID to gene Symbol

<!--chapter:end:02-setup.Rmd-->


# **Removing sources of unwanted noise from the single cell dataset**

Placeholder


## Empty droplets
## Removing ambient RNA contamination
## Standard gene QC to remove low quality cells

<!--chapter:end:03-Cleaning-the-data-and-making-a-Seurat-object.Rmd-->


# **Add isoform counts to Seurat object**

Placeholder


## Create a Seurat object with isoform expression data
## Filter the new Seurat object based on gene level information
## Add the isoform assay to the Seurat object

<!--chapter:end:04-Adding-Isoform-Information-to-the-Seurat-object.Rmd-->

---
date: "`r Sys.Date()`"
output: html_document
---

# **Finding marker genes and isoforms** {style="gray"}

------------------------------------------------------------------------

## Differentially expressed genes by cluster identity

First we can look at marker genes for each cluster. This will help us identify which genes are DE in each cluster and indicate the identity of each cluster. We will also look at DE isoforms using the same methodology.

```{r perform_marker_gene_analysis, echo=TRUE, message=FALSE, warning=FALSE}
#Find markers for all clusters using the "RNA" and "iso" assay

all_markers_gene_cluster <- FindAllMarkers(seu_obj, assay = "RNA", do.print = TRUE,
                                       logfc.threshold = 0.5, min.pct = 0.20, only.pos = TRUE) %>% dplyr::filter(p_val_adj < 0.05)

all_markers_iso_cluster <- FindAllMarkers(seu_obj, assay = "iso", do.print = TRUE,
                                      logfc.threshold = 0.5, min.pct = 0.20, only.pos = TRUE) %>% dplyr::filter(p_val_adj < 0.05)

#save the list of DE genes 
write.csv(all_markers_gene_cluster, "./output_files/DE/all_markers_one_gene.csv")
write.csv(all_markers_iso_cluster, "./output_files/DE/all_markers_one_iso.csv")
```

## Identifying cell types

Based on these differentially expressed (DE) genes, we can identify the cell types present in our sample. This process is often complex and requires prior knowledge of cell markers as well as an understanding of the cell types expected in the sample. An alternative approach is to use automated cell type identification tools. In this tutorial, we will use ScType @ianevski2022 . However, it is important to note that the accuracy of automated tools varies and depends heavily on the reference database they utilize. Therefore, it is recommended to use a combination of methods to cross-validate cell type identification and ensure robust results.

```{r sctype, echo=TRUE, message=FALSE, warning=FALSE}
# load libraries from sctype
invisible(lapply(c("ggraph","igraph","tidyverse", "data.tree"), library, character.only = T))
invisible(lapply(c("dplyr","Seurat","HGNChelper"), library, character.only = T))

# load gene set preparation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R")
# load cell type annotation function
source("https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R")

####
# define functions
perform_sctype_analysis <- function(seurat_obj, db_, tissue, gs_removal_list = c(), 
                                    metadata_col_prefix = "db_prefix", figure_prefix ="fig_name", cluster_res = "RNA_snn_res.0.9", output_file = "", reduction = "umap") {

    # Prepare gene sets
  gs_list <- gene_sets_prepare(db_, tissue)
  
  # Remove specified gene sets
  for (gs in gs_removal_list) {
    gs_list[["gs_positive"]][[gs]] <- NULL
  }
  
  # Calculate sctype scores
  es.max <- sctype_score(scRNAseqData = seurat_obj@assays$RNA$scale.data, scaled = TRUE, 
                         gs = gs_list$gs_positive, gs2 = gs_list$gs_negative)
  
  # Set identities in Seurat object
  Idents(seurat_obj) <- cluster_res
  
  # Merge by cluster
  cL_results <- do.call("rbind", lapply(unique(seurat_obj@meta.data[[cluster_res]]), function(cl) {
    es.max.cl <- sort(rowSums(es.max[, rownames(seurat_obj@meta.data[seurat_obj@meta.data[[cluster_res]] == cl, ])]), decreasing = TRUE)
    head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(seurat_obj@meta.data[[cluster_res]] == cl)), 10)
  }))
  
  sctype_scores <- cL_results %>% group_by(cluster) %>% top_n(n = 1, wt = scores)
  
  # Set low-confident clusters to "Unknown"
  sctype_scores$scores <- as.numeric(sctype_scores$scores)
  sctype_scores$type[sctype_scores$scores < sctype_scores$ncells / 4] <- "Unknown"
  print(sctype_scores[, 1:3])
  
  # Overlay the labels
  seurat_obj@meta.data[[metadata_col_prefix]] <- ""
  for (j in unique(sctype_scores$cluster)) {
    cl_type <- sctype_scores[sctype_scores$cluster == j,]
    seurat_obj@meta.data[[metadata_col_prefix]][seurat_obj@meta.data[[cluster_res]] == j] <- as.character(cl_type$type[1])
  }
  
  # Plotting
  pclass <- DimPlot(seurat_obj, reduction = reduction, label = TRUE, repel = TRUE, group.by = metadata_col_prefix)
  print(pclass)
  
  # Save the plot to a PDF
  pdf(file = paste0(figure_prefix, "_", metadata_col_prefix, "_sctype_genes.pdf"), width = 8, height = 8)
  print(pclass + ggtitle(figure_prefix))
  dev.off()
  
  # Save the updated Seurat object to an RDS file
  #if (output_file != "") {
  #  saveRDS(seurat_obj, file = paste0(output_file, ".rds"))
  #}
  
  # Return the updated Seurat object
  return(seurat_obj)
}


# Define variables
db_ = "https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx"; # this is a default database from sctype 
tissue <- "Brain"
gs_removal_list <- c("Tanycytes") # list of cell types from the db to remove

seu_obj <- perform_sctype_analysis(seu_obj, db_, tissue, gs_removal_list, 
                        metadata_col_prefix ="sctype_db", figure_prefix = "Day_55",
                        output_file = "Day_55", cluster_res = "RNA_snn_res.0.9", reduction = "umap")

```

ScType gives us some indication of which cell types we have in our data. We can use the DE genes to get some more specific info. Glutamatergic neuronal markers "SLC17A7","SLC17A6","GRIN1","GRIN2B" are all DE in cluster 0 - the mature neuron cluster. This suggests these cells are likely glutamatergic neurons.

```{r plot marker genes, echo=TRUE, message=FALSE, warning=FALSE}
# markers for 
FeaturePlot(seu_obj, features = c("SLC17A7","SLC17A6","GRIN1","GRIN2B"))
```

```{r GO, echo=TRUE, message=FALSE, warning=FALSE}
library(gprofiler2)

set_base_url("https://biit.cs.ut.ee/gprofiler_beta")

background_genes <- rownames(GetAssayData(seu_obj, assay = "RNA", layer = "counts"))[
  Matrix::rowSums(GetAssayData(seu_obj, assay = "RNA", layer = "counts") > 0) > 0
]

# Filter for significant genes in the current cluster
sig_genes <- all_markers_gene_cluster %>%
    filter(cluster == 0 & p_val_adj < 0.05) %>%  # Filter for cluster 0 and adjusted p-value < 0.05
    pull(gene)  # Extract gene names
  # Step 5: Run g:Profiler for pathway enrichment analysis
  pathway_results <- gprofiler2::gost(
    query = sig_genes,
    ordered_query = TRUE,
    correction_method = 'fdr',
    custom_bg = background_genes,
    sources = c("GO", "KEGG", "REACTOME")
  )
  
  # Prepare the data for plotting
  df_path <- as_tibble(pathway_results$result) %>%
    filter(term_size < 3000, term_size > 5) %>%
    filter(!term_id %in% unlist(pathway_results$parents))
  
  # Step 6: Plot top 5 results per database
 df_path %>%
    group_by(source) %>%
    slice_min(p_value, n = 5, with_ties = TRUE) %>%
    ungroup() %>%
    ggplot(aes(x = reorder(term_name, -p_value), y = -log10(p_value), fill = source)) +
    geom_bar(stat = 'identity', position = position_identity()) +
    coord_flip() +
    theme_bw() +
    labs(x = "") +
    facet_grid(source ~ ., space = 'free', scales = 'free') +
    theme(legend.position = 'none',
        axis.text.y = element_text(angle = 0, size = 8)) +  # Rotate and adjust y-axis text size
    ggtitle(paste("Pathway Enrichment for cluster 0"))  # Add title with cluster name
  

```

Based on the enriched terms, we can confidently conclude that the cell type is neuronal. Both the KEGG and the <GO:MF> terms support the hypothesis that the cells in cluster 0 have glutamatergic synapses. This analysis can be done on all the clusters in the Seurat object.

We can now change the Mature neurons label to Glutamatergic neurons and plot the updated UMAP.

```{r plot marker genes iso,  fig.height=5, fig.width=10}
## Change the names of ScType DF to Glutamatergic neurons in metadata
seu_obj@meta.data$sctype_db <- gsub("Mature neurons", "Glutamatergic neurons", seu_obj@meta.data$sctype_db)

DimPlot(seu_obj, group.by = "sctype_db", reduction = "umap") | DimPlot(seu_obj, reduction ="umap_iso", group.by = "sctype_db")
```

Let's take a closer look at the *Myelinating Schwann cells*.\

This cell type is somewhat unexpected given the cortical differentiation context.\

To better understand their identity, weâ€™ll examine their marker expression, counts, and key features.

```{r}
VlnPlot(seu_obj, features = c("nCount_RNA", "nFeature_RNA", "percent.mt"),
        group.by = "sctype_db", pt.size = 0.1) 
```

Let's look at some Radial glial Markers.

```{r}
FeaturePlot(seu_obj, features = c("VIM", "SOX2", "PAX6", "NES"), reduction = "umap", ncol = 2)
```

let's look at the top marker genes in this cluster.

```{r}
# Filter top markers for cluster 7
top_cluster7 <- all_markers_gene_cluster %>%
  filter(cluster == 7) %>%
  arrange(p_val_adj, desc(avg_log2FC)) %>%
  slice_head(n = 20)   # top 10 markers, adjust as needed

# View the top genes
print(top_cluster7$gene)

```

Based on the plots above, *Myelinating Schwann cells* show markedly fewer detected features and lower total counts compared to other populations. Additionally, the expression profiles indicate that this cluster lacks canonical radial glial markers such as **VIM**, **SOX2**, and **PAX6** (shown above). Differential expression analysis using the `FindAllMarkers` function also revealed a high proportion of **ribosomal genes** among the top markers for this cluster.

Taken together, these findings suggest that this cluster does not represent a bona fide neural lineage. Instead, these cells are likely **low-complexity or low-quality cells** that have passed the initial QC filters. Therefore, we will remove this cluster from downstream analyses. It would also be sensible to label these cells as "Unknown' but for simplicity we will remove them\

```{r}
## Remove Myelinating Schwann cells
seu_obj <- subset(seu_obj, subset = sctype_db != "Myelinating Schwann cells")
DimPlot(seu_obj, group.by = "sctype_db", reduction = "umap") 
```

Cell type identification is an iterative process and often one of the most challenging aspects of single-cell analysis. For this example, we will assume that our combined approach, using automated cell type identification, differential expression (DE) analysis based on clusters and Gene set enrichment, provides a good indication of the cell types present in our data. It is possible to explore the these cell types in more detail as there are likely many subtypes. For the purposes of the tutorial we will leave this annotation as is. Based on this we have 3 main cell types.

1.  Radial glial cells (RG)

2.  Excitatory neurons (Glutamatergic neurons and Immature neurons)

3.  GABAergic neurons

We can use a very nice package called dittoSeq (<https://bioconductor.org/packages/devel/bioc/vignettes/dittoSeq/inst/doc/dittoSeq.html>) to Visualise scRNA seq data directly from a Seurat object.

We can plot the distribution of the 3 cell types in a few different ways using `dittoBarPlot`

```{r dito, echo=TRUE, message=FALSE, warning=FALSE}
library(dittoSeq)
dittoBarPlot(seu_obj, "orig.ident", group.by = "sctype_db", scale = "count") | dittoBarPlot(seu_obj, "sctype_db", group.by = "orig.ident", scale = "percent")

```

## DE genes and isoforms based on annotated cell types.

With this foundation, we can refine our DE analysis by focusing on cell types rather than clusters. This step is critical in nearly all transcriptomic analyses, offering a wide range of possibilities for downstream investigations.

A common downstream approach involves generating volcano plots to visualize DE genes and isoforms. performing gene set enrichment analysis, In the following sections, we will demonstrate how to perform these types of analyses and explore their potential applications.

The code chunk below provides an example of how to execute these analyses:

```{r setup DE, echo=TRUE, message=FALSE, warning=FALSE}
#Set identities based on cell type

Idents(seu_obj) <- "sctype_db"

all_markers_gene_celltype <- FindAllMarkers(
  object = seu_obj, 
  assay = "RNA", 
  group.by = "sctype_db",  # Replace with your metadata column name
  logfc.threshold = 0.5, 
  min.pct = 0.20, 
  only.pos = FALSE # changed this to false to get negatively DE genes to
)

all_markers_iso_celltype <- FindAllMarkers(
  object = seu_obj, 
  assay = "iso", 
  group.by = "sctype_db",  # Replace with your metadata column name
  logfc.threshold = 0.5, 
  min.pct = 0.20, 
  only.pos = FALSE # changed this to false to get negatively DE genes to
)

#save the list of DE genes 
write.csv(all_markers_gene_celltype, "./output_files/DE/all_markers_one_gene_celltype.csv")
write.csv(all_markers_iso_celltype, "./output_files/DE/all_markers_one_iso_celltype.csv")
```

A basic way of exploring this data is to plot these markers on a heatmap. Seurat has a nice function to do so. Let us plot the top 5 marker genes and isoforms in each cell type

```{r heatmap, echo=TRUE, message=FALSE, warning=FALSE, fig.height=8, fig.width=10}
all_markers_gene_celltype %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1) %>%
    slice_head(n = 5) %>%
    ungroup() -> G_top5
DoHeatmap(seu_obj, features = G_top5$gene, assay = "RNA", size = 3) + 
  NoLegend() 


all_markers_iso_celltype %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1) %>%
    slice_head(n = 5) %>%
    ungroup() -> I_top5
DoHeatmap(seu_obj, features = I_top5$gene, assay = "iso", size = 3) +
  NoLegend() 
```

Personally I find the same plots generated by `dittoHeatmap` much nicer. The function can also take a list of genes or isoforms of interest. Just remember to set the default assay accordingly.

```{r heatma pdito, echo=TRUE, message=FALSE, warning=FALSE}
#list_of_genes <- c("VIM", "MAPT", "KLC1", "RBFOX1", "RBFOX3")

DefaultAssay(seu_obj) <- "RNA"
dittoHeatmap(seu_obj, head(G_top5$gene, 25),
             scaled.to.max = FALSE,
             complex = FALSE,
             heatmap.colors.max.scaled = FALSE,
             annot.by = c("sctype_db"))

DefaultAssay(seu_obj) <- "iso"
dittoHeatmap(seu_obj, head(I_top5$gene, 25),
             scaled.to.max = FALSE,
             complex = FALSE,
             heatmap.colors.max.scaled = FALSE,
             annot.by = c("sctype_db"))

```

## Volcano plots

### FindAllMarkers DE

Next we can explore this data by generating some volcano plots. This analysis can be useful to identify genes and isoforms that are DE and also have large fold changes. Often these types of features are the interesting for further analysis. This can be done for any of the cell types defined in our object. For the sake of brevity we will look at the glutamatergic neurons.

When plotting the volcano plots, we observe that many genes exhibit both statistically significant p-values (p \< 0.05) and log2 fold changes -2\< or \>2. To highlight key findings, we have labeled some glutamatergic marker genes, demonstrating that the genes we expect to be upregulated in this cell type are indeed showing the expected pattern. Additionally, we have labeled VIM, a marker of radial glial and progenitor cells. As anticipated, VIM expression is downregulated in these neurons, which aligns with our expectations.

```{r valocano1, echo=TRUE, fig.height=8, fig.width=8, message=FALSE, warning=FALSE}
library(EnhancedVolcano)

#filter for the cell type of interest 
glut_DE_iso <- dplyr::filter(all_markers_iso_celltype, cluster == "Glutamatergic neurons")
glut_DE_gene <- dplyr::filter(all_markers_gene_celltype, cluster == "Glutamatergic neurons") 

#we can plot our volcano plot 
EnhancedVolcano(glut_DE_gene,
                lab=glut_DE_gene$gene,
                x='avg_log2FC', y='p_val_adj', pCutoff=0.05, FCcutoff=2,
                boxedLabels = TRUE,
                drawConnectors = TRUE,
                selectLab= c("SLC17A7","SLC17A6",'GRIN1',"GRIN2B",'VIM'),
                title = "Volcano Plot of Differentially Expressed Genes \n in the Glutamatergic Neurons")
```

Interestingly our long read data allows us to perform the same analysis but at the isoform level. This can be hard to interpret as there are many more features to plot on the volcano plot. for the sake of clarity we have just labelled TBR1 isoforms. This code below will allow users to plot all the isoforms from a given gene on the Volcano plot making interpretation of the data a bit cleaner. Here we can see two different isoforms of the TBR1 gene showing enrichment in this cell type.

```{r valocano2, echo=TRUE, fig.height=8, fig.width=8, message=FALSE, warning=FALSE}
gene <- "TBR1"
plot_features_list <- grep(paste0("(^|-|\\b)", gene, "($|\\b)"), features, value = TRUE)

EnhancedVolcano(glut_DE_iso,
                lab=glut_DE_iso$gene,
                x='avg_log2FC', y='p_val_adj', pCutoff=0.05, FCcutoff=2,
                boxedLabels = TRUE,
                drawConnectors = TRUE,
                selectLab= plot_features_list,
                title = "Volcano Plot of Differentially Expressed Isoforms \n in the Glutamatergic Neurons")


```

### FindMarkers DE

Finding All Markers is just one type of differential expression (DE) analysis that can be performed. Seurat offers the `FindAllMarkers` function, which tests the cell type of interest against all other cells. While this approach is often sufficient for identifying marker genes, users may also want to test differences between two specific cell types. For instance, you might want to identify DE genes when comparing glutamatergic neurons to radial glial cells. Below, we demonstrate how to perform this type of analysis with the `FindMarkers` function.

```{r valocano3, echo=TRUE, fig.height=8, fig.width=8, message=FALSE, warning=FALSE}


DefaultAssay(seu_obj) <- 'RNA' # difeine the gne assay as default
glu_RG_gene <- FindMarkers(seu_obj,
                          ident.1 = "Glutamatergic neurons",
                          ident.2 = "Radial glial cells",
                          logfc.threshold = 0.5, min.pct = 0.02)

DefaultAssay(seu_obj) <- 'iso' # difeine the gne assay as default
glu_RG_iso <- FindMarkers(seu_obj, ident.1 = "Glutamatergic neurons",
                          ident.2 = "Radial glial cells",
                          logfc.threshold = 0.5, min.pct = 0.02)


#Volcano plots # to plot at gene level
#EnhancedVolcano(glu_RG_gene, lab=rownames(glu_RG_gene),
#                x='avg_log2FC', y='p_val_adj',
#                #selectLab= "VIM",
#                pCutoff=0.05, FCcutoff=2,
#                title = "Volcano Plot of Differentially Expressed Gene \n Glutamatergic Neurons vs Radial glial #Cells")

#Volcano plots
EnhancedVolcano(glu_RG_iso, lab=rownames(glu_RG_iso),
                x='avg_log2FC', y='p_val_adj',
                #selectLab= "VIM",
                pCutoff=0.05, FCcutoff=2,
                title = "Volcano Plot of Differentially Expressed Isoforms \n Glutamatergic Neurons vs Radial glial Cells")

```

The volcano plot above is a useful tool for visualizing DE isoforms between two cell types. In this plot, red-labeled isoforms on the right-hand side indicate those that are unregulated in glutamatergic neurons compared to RG cells, while red dots on the left represent isoforms that are unregulated in radial glial cells compared to glutamatergic neurons. This analysis serves as an initial overview, and users can further explore the DE list (`glu_RG_iso`) to select specific isoforms of interest for more detailed analysis.

<!--chapter:end:05_Finding_differentially_expressed_genes_and_isoforms.Rmd-->


# **Exploring isoforms of interest**

Placeholder


## Isoforms expressed per gene
## Top 10 Genes with Most Isoforms
## Exploring *MACF1* isoforms
## Expression of *MACF1* isoforms Across Cell Types
## Visualization of Isoform Structures

<!--chapter:end:06_Finding-isoforms-of-interest.Rmd-->


# **Isoform Classification**

Placeholder


## Classification with SQANTI
## Cell type specific isoforms
## Find all the genes that express at least 1 novel isoform
## Visualising OAZ2 novel isoform
## Functional impacts of novel isoforms

<!--chapter:end:07-Isofrom-Classification.Rmd-->


# **Profiling Isoform Diversity**

Placeholder


## Measuring entropy with `find_diversity()` function
## Example of a low entropy gene
## Example of a high entropy gene
## Broadening Entropy Analysis

<!--chapter:end:08_diversity.rmd-->

---
date: "`r Sys.Date()`"
output: html_document
---

# **Multisample analysis**

The FLAMES pipeline supports the analysis of multiple samples simultaneously, allowing users to efficiently process complex experimental datasets. This is achieved using the `MultiSampleSCPipeline` function. The output generated by this function is similar to the single-sample analysis outlined in previous chapters but offers additional capabilities when the experimental design includes sample replicates.

To take full advantage of these features we need to perform sample integration to generate a single object that we can use to integrate isoform expression across our conditions. First standard preprocessing as described in Chapters 3 and 4 is required. After integration we can perform the following key analysis:

1.  **Sample Integration:** Combine multiple samples together and add isoform counts.

2.  **Trajectory Analysis:** Explore genes that change along pseudotime trajectories.

3.  **Differential Transcript Usage (DTU) Analysis:** Investigate changes in isoform proportions between conditions. (Coming soon!!)

Most preprocessing and QC steps remain the same. However, we will also demonstrate how to proceed directly from FLAMES output to initial QC without performing empty droplet removal or ambient RNA normalization. Although these steps are recommended, they may not always be necessary depending on the data.

------------------------------------------------------------------------

### Dataset Information

For this analysis, we are using a dataset comprising eight samples spanning four time points from an excitatory neuronal differentiation protocol. The protocol is the same as the one used for the D55 sample in previous chapters but utilizes a different cell line. Two samples were collected from each of the following time points:

-   **Stem cells** (STC)

-   **Day 25**

This dataset will allow us to explore temporal changes in gene and isoform expression throughout neuronal differentiation.

## Standard pre-processing and quality control

As before we will modify the count matrix for each sample so we use gene_symbol instead of ENSG id. The data generated from this multisample experiment is quite large. This is especially the case with Oarfish isoform quantification as there are many more features to consider. This means much of the workflow below is time consuming and computationally intensive. Please keep this in mind when processing your samples. In the tutorial we provide code for the required steps but do not evaluate many of the sections below due to these computational constraints. The raw counts are available in the multisample data folder if users wish to run through the analysis.

make isoform gene dictionary for the mutisample mode

```{r}
# The FLAMES ref can be found in your selected output folder after running the Flames pipeline. 
FLAMES_gtf_file <- "data/multi_sample_subset/isoform_annotated.gtf" #ensure file is unzipped
reference_gtf_file <- "data/gencode.v47.annotation.gtf" # ensure file is unzipped
output_file <- "isoform_gene_dict_mutlisample_subset.csv"

# Call the helper function defined in code block above to create a dictionary containing corresponding gene information for each isoform
# This may take a few minutes 
isoform_gene_dict_mutlisample <- make_isoform_gene_symbol_dict(FLAMES_gtf_file,
                                                   reference_gtf_file,
                                                   output_file)
```

```{r, subset_multisample_genesymbol, cache=TRUE, echo=TRUE, eval=TRUE}
# convert Gene_id to gene symbol for all counts
#run a loop to run this function on all count files.
# Directory with input files
input_dir <- "./data/multi_sample_subset/"
output_dir <- "./data/multi_sample_subset/"

# List all CSV files in the input directory
input_files <- list.files(input_dir, pattern = "\\count_subset.csv$", full.names = TRUE)

# Initialize an empty list to store data frames
result_list <- list()

# Process each file in the directory
total_files <- length(input_files)  # Total number of files

for (i in seq_along(input_files)) {
  file_path <- input_files[i]
  
  # Extract file name without extension
  file_name <- tools::file_path_sans_ext(basename(file_path))
  
  # Construct the output file name
  output_file <- file.path(output_dir, paste0(file_name, "_gene_symbol.csv"))
  
  # Show progress to the user
  message(sprintf("Processing file %d of %d: %s", i, total_files, file_name))
  
  # Call the function with return_df = TRUE to store the result
    result_list[[file_name]] <- convert_ENSGID_to_geneSymbol(
    id_symbol_df = isoform_gene_dict_mutlisample,
    gene_count_matrix_path = file_path,
    output_file = output_file,
    return_df = TRUE
  )
}


```

### Define QC function

We have developed a multisample QC function \@ref(Multisample QC function) for processing count matrices and constructing filtered Seurat objects, following best practices outlined in the Seurat tutorial. This function includes steps to identify and remove doublets, as well as generate key diagnostic plots for data inspection. We encourage users to customize this function to fit their specific needs, such as applying additional filtering criteria.

For the purposes of presenting concise and readable code we will apply the default filtering parameters to all objects. If users wish to be more specific about filtering each sample independently this is possible and can be done by running the `perform_qc_filtering` function on each sample with desired parameters.

```{r, subset_multi_sample_qc, fig.height=6, fig.width=12, cache=FALSE, include=TRUE, eval=FALSE}

# Define sample names
sample_names <- c("C1_STC", "C4_STC", "C2_Day25", "C5_Day25")

# Initialize a list to store UMAP objects
umap_objects <- list()

# Start the PDF for output
pdf(file = "./output_files/multi_sample_subset/QC/multisample_QC.pdf", width = 10, height = 6)

# Loop through each sample and apply the QC filtering function
for (i in seq_along(sample_names)) {
  sample_name <- sample_names[i]
  
  # Print progress message
  message(paste0("Processing sample ", i, " of ", length(sample_names), ": ", sample_name))
  
  # Perform QC filtering
  result <- perform_qc_filtering(
    result_list[paste0(sample_name, "_matched_reads_gene_count_subset")],
    fig_name = sample_name,
    project = sample_name
  )
  
  # Store the UMAP object from the result
  umap_objects[[sample_name]] <- result[[1]]
}

# Close the PDF device
dev.off()

#save the object
saveRDS(umap_objects, file = "./output_files/multi_sample_subset//umap_objects.rds")
```

## Multisample integration

First we will merge the Seurat objects together and then perform integration. There are many options for sample integration and Seurat provides many wrappers for these functions. Here we will use Harmony [@korsunsky2019] for fast and effective integration. As these processes are time consuming we will load our saved objects.

```{r, subset_multisample_integration, cache=TRUE, include=TRUE, eval=TRUE, echo=TRUE}
# integrate samples  
#from the function above pull the filtered seurat object 

merged_seurat <- merge(
  umap_objects[["C1_STC"]],
  y = list(
    umap_objects[["C4_STC"]],
    umap_objects[["C2_Day25"]],
    umap_objects[["C5_Day25"]]
  ),
  add.cell.ids = c(
    "C1_STC", "C4_STC", "C2_Day25", "C5_Day25"
  ), 
  project = "Multi-sample_tutorial"
  )

# create a sample column
merged_seurat$sample <- rownames(merged_seurat@meta.data)

## split sample column to make a batch col
merged_seurat@meta.data <- separate(merged_seurat@meta.data, col = 'sample', into = c('batch', 'Day', 'Barcode'), 
                                    sep = '_')
#check some QC metrics 
VlnPlot(merged_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, group.by = "Day") + 
  plot_annotation(title = "Vln plots grouped by Day")

#can plot based on any metadata col
#VlnPlot(merged_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, group.by = "orig.ident")

# Number of cells per group
table(merged_seurat$orig.ident)
table(merged_seurat$Day)

# Apply normal preprocessing steps to merged file 

merged_seurat <- NormalizeData(object = merged_seurat)
merged_seurat <- FindVariableFeatures(object = merged_seurat)
merged_seurat <- ScaleData(object = merged_seurat) 
merged_seurat <- RunPCA(object = merged_seurat)
merged_seurat <- FindNeighbors(object = merged_seurat, dims = 1:16)
merged_seurat <- FindClusters(object = merged_seurat, resolution = 0.6)
merged_seurat <- RunUMAP(object = merged_seurat, dims = 1:30)

##save merged object
saveRDS(merged_seurat, file = "./output_files/multi_sample_subset//merged_seurat.rds")

```

```{r, subset_multisample_integration_2, include=TRUE, fig.height=6, fig.width=10, message=FALSE, echo=TRUE}
set.seed(00003)
merged_seurat <- readRDS("./output_files/multi_sample_subset/merged_seurat.rds")


#Let's plot the merged file. 
p1 <- FeaturePlot(merged_seurat, reduction = 'umap', features = 'nCount_RNA')
p2 <- FeaturePlot(merged_seurat, reduction = "umap", features = 'nFeature_RNA')
p3 <- DimPlot(merged_seurat, reduction = 'umap', group.by = 'Day')
p4 <- DimPlot(merged_seurat, reduction = 'umap', group.by = 'orig.ident')

grid.arrange(p1, p2, p3, p4, ncol = 2)


merged_seurat <- JoinLayers(object = merged_seurat)
merged_seurat[["RNA"]] <- split(merged_seurat[["RNA"]], f = merged_seurat$orig.ident)

#perform integration with Harmony
obj <- IntegrateLayers(object = merged_seurat,
                       method = HarmonyIntegration,
                       orig.reduction = "pca",
                       new.reduction = 'integrated.harm',
                       verbose = FALSE,
)

obj <- FindNeighbors(obj, reduction="integrated.harm")
obj <- FindClusters(obj, resolution=0.4, cluster.name="harm_cluster")
obj <- RunUMAP(obj, reduction="integrated.harm", dims=1:50, reduction.name = "umap.harm")


DimPlot(obj, reduction = "umap.harm", group.by = c("Day", "orig.ident", "harm_cluster"), label = T)  

### save object 
saveRDS(obj, file = "./output_files/multi_sample_subset//integrated_harm_seurat.rds")
```

## Add isoform counts

Now we can add isoform level information to the merged Seurat object. When doing this you may need to convert the Oarfish files into a count.csv file with the row names in the ENSTID_gene_symbol ID form. The function to do so can be found here \@ref(Convert Oarfish files to count matrix)

We will convert the Oarfish output to count data. We can also use the bellow fucntion to incldue or exlude Novel bambu genes that poarfish quantifies. for the sake of simplicity we will exclude novel bambu Genes.

```{r, message=FALSE, echo=TRUE, eval=FALSE}
# Define sample names
sample_names <- c("C1_STC",
                  "C4_STC",
                  "C2_Day25",
                  "C5_Day25")

# Loop through each sample and process the count files
for (sample in sample_names) {
  # Use tryCatch to handle errors
  tryCatch({
    # Call the function to process the sample
    process_oarfish_files_to_counts_matrix(
      sample_name = sample,
      resource_table_path = "./output_files/ref_files/isoform_gene_dict_mutlisample_subset.csv",
      output_dir = "./output_files/multi_sample_subset/oarfish_counts/",
      input_dir = "./data/multi_sample_subset/oarfsih/",
      filter_bambu_Genes = TRUE
    )
  }, error = function(e) {
    # Print the error message and exit the loop
    cat("Error processing sample:", sample, "\nError message:", e$message, "\nExiting loop.\n")
    stop(e)
  })
}
```

The workflow follows these steps.

1.  Create a Seurat object per sample
2.  Merge the objects together
3.  Filter the isoform merged object based on cell types that are high quality (based on gene level filtering)
4.  Add the isoform filtered and merged object to the gene level object as a new assay
5.  Integration on the isoform assay is possible but not shown here.

```{r, subset_multisample_add_iso_counts, eval=FALSE, echo=TRUE}

############ read in count matrix and add isoform assay to Seurat object  #########
#Make Seurat objects not filtered
# Function to read a CSV file and create a Seurat object
create_seurat_object <- function(sample_name, input_dir, project_name) {
  # Construct file path
  file_path <- file.path(input_dir, paste0("gene_symbol_oarfish_", sample_name, "_counts.csv"))
  
  # Read the CSV file
  counts <- fread(file_path)
  counts <- as.data.frame(counts) 
  rownames(counts) <- counts[[1]]            # Set row names from the first column
  counts[[1]] <- NULL     
  
  # Create the Seurat object
  seurat_obj <- CreateSeuratObject(counts = counts, project = project_name, min.cells = 5, min.features = 500)
  
  return(seurat_obj)
}

# Directory where the CSV files are stored
input_directory <- "./output_files/multi_sample_subset/oarfish_counts/"

# Create an empty list to store Seurat objects
iso_seurat_objects <- list()

total_samples <- length(sample_names)
for (i in seq_along(sample_names)) {
  sample <- sample_names[i]
  
  message(sprintf("Processing sample %d of %d: %s", i, total_samples, sample))
  
  iso_seurat_objects[[sample]] <- create_seurat_object(
    sample_name = sample,
    input_dir = input_directory,
    project_name = sample
  )
}

####### Merge the samples into one object ######
iso.merged_seurat <- merge(
  iso_seurat_objects[["C1_STC"]],
  y = list(
    iso_seurat_objects[["C4_STC"]],
    iso_seurat_objects[["C2_Day25"]],
    iso_seurat_objects[["C5_Day25"]]
  ),
  add.cell.ids = c(
    "C1_STC", "C4_STC", "C2_Day25", "C5_Day25"
  ), 
  project = "iso-Multi-sample_tutorial"
  )

# create a sample column
iso.merged_seurat$sample <- rownames(iso.merged_seurat@meta.data)

# split sample column to makw a batch col
iso.merged_seurat@meta.data <- separate(iso.merged_seurat@meta.data, col = 'sample', into = c('batch', 'Day', 'Barcode'), 
                                    sep = '_')

## filter the data to iso and gene cells match
merged_seurat_isoform_filtered <- subset(iso.merged_seurat, cells =obj@graphs[["RNA_nn"]]@Dimnames[[1]])

VlnPlot(merged_seurat_isoform_filtered, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# perform standard workflow steps
merged_seurat_isoform_filtered <- NormalizeData(object = merged_seurat_isoform_filtered) # if using SCT dont run this
merged_seurat_isoform_filtered <- FindVariableFeatures(object = merged_seurat_isoform_filtered) # if using SCT dont run this
merged_seurat_isoform_filtered <- ScaleData(object = merged_seurat_isoform_filtered) # if using SCT dont run this
merged_seurat_isoform_filtered <- RunPCA(object = merged_seurat_isoform_filtered)
#ElbowPlot(merged_seurat_isoform_filtered)
merged_seurat_isoform_filtered <- FindNeighbors(object = merged_seurat_isoform_filtered, dims = 1:10)
merged_seurat_isoform_filtered <- FindClusters(object = merged_seurat_isoform_filtered, resolution = 0.6)
merged_seurat_isoform_filtered <- RunUMAP(object = merged_seurat_isoform_filtered, dims = 1:10)

#Save file
saveRDS(merged_seurat_isoform_filtered, file = "./output_files/multi_sample_subset//merged_seurat_isoform_filtered.rds")
```

```{r, subset_multisample_add_iso_counts_2, echo=TRUE, cache=FALSE, message=FALSE}
merged_seurat_isoform_filtered <- readRDS(file = "./output_files/multi_sample_subset//merged_seurat_isoform_filtered.rds")

#plots
p5 <- DimPlot(merged_seurat_isoform_filtered, reduction = 'umap', group.by = 'orig.ident')
p6 <- DimPlot(merged_seurat_isoform_filtered, reduction = 'umap', group.by = 'Day')
p7 <- FeaturePlot(merged_seurat_isoform_filtered, reduction = 'umap', features = 'nCount_RNA')
p8 <- FeaturePlot(merged_seurat_isoform_filtered, reduction = "umap", features = 'nFeature_RNA')

grid.arrange(p5, p6, p7, p8, ncol = 2)

#####

merged_seurat_isoform_filtered <- JoinLayers(merged_seurat_isoform_filtered)
counts_table <- merged_seurat_isoform_filtered[["RNA"]]$counts

obj[["iso"]] <- CreateAssay5Object(counts = counts_table)

# Step 1: Normalize the new assay data
obj <- NormalizeData(obj, assay = "iso")
obj <- FindVariableFeatures(obj, assay = "iso")
obj <- ScaleData(obj, assay = "iso")

# Step 4: Perform PCA
obj <- RunPCA(obj, assay = "iso", reduction.name = "pca_iso")
# Step 5: Run UMAP
obj <- RunUMAP(obj, reduction = "pca_iso", dims = 1:15, assay = "iso", reduction.name = "umap_iso")

# Visualize the UMAP
DimPlot(obj, label = TRUE, reduction = "umap.harm") | DimPlot(obj, label = TRUE, reduction = "umap_iso")
```

## Identify cell types

Here we annotate cell types using some key markers.

Cluster 1 2 and 3 are stem ells

```{r, fig.height=3, fig.width=12, echo = TRUE}
# We can annoate Day 0 
FeaturePlot(obj, reduction = "umap.harm", features = c("MKI67", "NANOG", "POU5F1"), ncol = 3)
```

Cluster 0 and 4 - Radial Glia

```{r, fig.height=3, fig.width=12, echo = TRUE}
FeaturePlot(obj, reduction = "umap.harm", features = c("VIM", "SOX2", "PAX6"), ncol = 3)
```

Cluster 5 - Inhibitory neurons

```{r, fig.height=3, fig.width=12, echo = TRUE}
FeaturePlot(obj, reduction = "umap.harm", features = c("GAD1", "GAD2", "DLX5", "DLX6"),ncol = 4)
```

Cluster 6 - Excitatory neurons (NPC)

```{r, fig.height=3, fig.width=8, echo = TRUE}
#Clsuter 6 Excitorty neurons (NPC)
FeaturePlot(obj, reduction = "umap.harm", features = c("EOMES", "TBR1"))
```

Now we will assign these labels to each cluster.

```{r, cache=FALSE, echo=TRUE, fig.height=3, fig.width=6}
new_ids <- c(
  "0" = "Radial glia",
  "1" = "Stem cells",
  "2" = "Stem cells",
  "3" = "Stem cells",
  "4" = "Radial glia",
  "5" = "Inhibitory neurons",
  "6" = "Excitatory neurons"
)

obj <- RenameIdents(obj, new_ids)

# store as a metadata column for later
obj$cell_type <- Idents(obj)

# plot by cell type instead of numeric cluster
DimPlot(obj, group.by = "cell_type", reduction = "umap.harm")

#saveRDS(obj, file = "./output_files/multi_sample/multisample_seurat.intergrated_harm.isoform.rds")

```

Now that we have an integrated Seurat object containing both gene- and isoform-level counts, along with curated cell type annotations, we can move beyond static clustering to explore how these transcriptional programs change over time and across lineages. In the next sections, we will use this object as the foundation for **trajectory analysis**, to reconstruct developmental paths and cell state transitions, and for **differential transcript usage (DTU)** analysis, to identify genes whose **isoform composition** shifts between conditions, lineages, or cell types.

<!--chapter:end:09_multi_sample_subset.rmd-->


# **Trajectory analysis**

Placeholder


## Running pseudotime analysis on genes
## Running pseudotime analysis on isoforms
## Summary and downstream applications

<!--chapter:end:10_traj_multi_sub.rmd-->

---
date: "`r Sys.Date()`"
output:
  html_document:
    number_sections: true
bookdown::chapter_name: NULL
---

# **Conclusion** {.unnumbered}

In this tutorial, we have demonstrated an end-to-end workflow for analyzing and visualising long-read single-cell data generated by FLAMES. We have shown how to preprocess the data to retain high-quality cells, load gene and isoform counts into a Seurat object, identify differentially expressed genes and isoforms across cell types, visualize isoform expression and structure, and identify novel isoforms that may impact protein function.

While this tutorial covers the core aspects of single-cell long-read data analysis, several additional avenues remain unexplored. Further analyses could include enrichment analysis of differentially expressed transcription factors or splicing regulators, motif analysis to investigate regulatory element binding, and alternative splicing events that may impact cellular functions. Integrating these analyses can provide a more comprehensive understanding of cellular diversity and regulatory mechanisms.

Ultimately, this tutorial, in combination with long-read tools such as FLAMES, offers a powerful toolkit for exploring and analyzing isoform-level dynamics in single cells. This workflow can be applied to other experimental contexts to identify candidate isoforms involved in development or disease pathogenesis.

## Acknowledgements {.unnumbered}

Thank you to Manveer Chauhanand Michaela Sacco for reviewing this book and providing valuable suggestions to improve its clarity and content. Your feedback has contributed to making this a more useful resource for researchers working with long-read single-cell RNA sequencing data.

## Session info {.unnumbered}

```{r setup, include=TRUE, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE)
sessionInfo()
```

<!--chapter:end:12_Citations_and_Session_info.Rmd-->

---
date: "`r Sys.Date()`"
output: html_document
---

# **References** {.unnumbered}

::: {#refs}
:::

<!--chapter:end:refs.Rmd-->


# **Appendix** {.unnumbered}

Placeholder


## Calculating the ambient RNA profile {.unnumbered}
## Multisample QC function {.unnumbered}
## Convert Oarfish files to a count matrix {.unnumbered}

<!--chapter:end:Appendix.Rmd-->

