---
date: "`r Sys.Date()`"
output: html_document
---

# Profiling Isoform Diversity Using Shannon’s Entropy

Beyond standard analyses like differential gene expression (DGE), differential isoform expression (DIE), differential transcript usage (DTU), or pseudotime trajectories, long-read single-cell data let us ask a different kind of question:\

**How is a gene’s expression distributed across its isoforms?**

This idea is what we refer to as **isoform diversity**. Instead of just asking “is isoform X up in cluster A?”, we ask:

-   Does a single cell use one dominant isoform for a gene?

-   Or does it spread expression across many isoforms?

-   And do cells of the *same* type agree on which isoforms they use, or not?

In the FLAMESv2 paper, we formalise this by using **Shannon’s entropy** to measure isoform diversity at single-cell resolution using the `find_diversity` function.

In plain terms, entropy gives you a score for how evenly a gene’s expression is split across its isoforms.

-   **Low entropy** → the gene is basically using one isoform in that cell.

-   **High entropy** → the gene is using multiple isoforms more evenly in that cell.

```{r, fig.cap="Isoform diversity schematic. For each gene, we measure how transcript usage is distributed across isoforms within individual cells. Cells dominated by a single isoform show low isoform diversity (low entropy), while cells that express multiple isoforms at similar levels show high isoform diversity (high entropy).", out.width="1600px", fig.height=2, fig.width=5}
knitr::include_graphics("images/entropy_example.png")
```

### Measuring entropy with `find_diversity()` function

Lets grab Radial glial cells and look at the diversitry of gene expresstion in each cell.

We have a fucntion in FLAMESv2 softare called find diversity. This fucntion is a powerful yet simple way o calacultion shanaonsn entropt for every gene for every cell. We the fucntion is placed here () if you wish to look at the compete source code. This code has been modified in the FLAMESv2 sofrware to work with sce objects. here we use a seuat objet so the code has been apapricte modiufued ro ensure we can use a seurat as input. See the fLEMS bioconder manual for an eaxplation of each parater.

here will simpaly look at the diverty metrics in \~100 Radial glial cells

```{r}
DimPlot(seu_obj, reduction = "umap")

```

```{r}
find_diversity <- function(obj,
                                        genes,
                                        assay = "iso",
                                        slot.counts = "counts",
                                        slot.data = "data",
                                        ident.name = NULL,
                                        alpha = 0,
                                        min_counts_per_cell = 10,
                                        isoform_min_pct_cells = 0.05,
                                        isoform_cumulative_pct = 0.95,
                                        min_cell_fraction = 0.20,
                                        p = NULL) {
  if (!is.null(ident.name)) {
    Idents(obj) <- ident.name
  }

  if (is.null(p)) {
  p <- function(x) { message(x) }  # simple fallback that just prints messages
}

  cells <- colnames(obj)
  mat_counts <- GetAssayData(obj, assay = assay, slot = slot.counts)[, cells, drop = FALSE]
  mat_data   <- GetAssayData(obj, assay = assay, slot = slot.data)

  norm_entropy_mat <- matrix(NA_real_, nrow = length(genes), ncol = length(cells))
  raw_entropy_mat  <- matrix(NA_real_, nrow = length(genes), ncol = length(cells))
  rownames(norm_entropy_mat) <- genes
  colnames(norm_entropy_mat) <- cells
  rownames(raw_entropy_mat) <- genes
  colnames(raw_entropy_mat) <- cells

  isoform_summary_list <- list()

  for (gene in genes) {
    p(sprintf("Processing %s", gene))

    # all isoforms matching gene pattern
    isoforms <- grep(paste0("(^|-|\\b)", gene, "($|\\b)"), rownames(mat_data), value = TRUE)
    total_isoforms <- length(isoforms)
    if (total_isoforms < 2) {
      message("Skipping ", gene, ": fewer than 2 isoforms (found ", total_isoforms, ")")
      next
    }

    submat <- mat_counts[isoforms, , drop = FALSE]
    gene_total_counts <- colSums(submat)
    keep_cells <- names(gene_total_counts)[gene_total_counts >= min_counts_per_cell]
    if (length(keep_cells) == 0) {
      message("Skipping ", gene, ": no cells with at least ", min_counts_per_cell, " gene counts")
      next
    }

    submat_f <- submat[, keep_cells, drop = FALSE]

    # filter by percent of cells expressing each isoform
    pct_cells_expressed <- rowMeans(submat_f > 0)
    iso_keep_pct <- names(pct_cells_expressed)[pct_cells_expressed >= isoform_min_pct_cells]
    isoforms_passing_pct <- iso_keep_pct
    submat_f <- submat_f[iso_keep_pct, , drop = FALSE]
    if (nrow(submat_f) == 0) {
      message("Skipping ", gene, ": no isoforms pass pct filter")
      next
    }

    # cumulative proportion filtering per cell, then intersect
    filter_top_isoforms <- function(counts, threshold = 0.9) { 
      proportions <- counts / sum(counts)
      sorted <- sort(proportions, decreasing = TRUE)
      keep <- which(cumsum(sorted) <= threshold)
      if (length(keep) == 0) keep <- 1
      names(sorted)[c(keep, length(keep) + 1)]
    }

    iso_keep_cum <- unique(unlist(apply(submat_f, 2, filter_top_isoforms, threshold = isoform_cumulative_pct)))
    iso_keep_final <- base::intersect(rownames(submat_f), iso_keep_cum)
    n_isoforms_used <- length(iso_keep_final)
    if (n_isoforms_used < 2) {
      message("Skipping ", gene, ": fewer than 2 isoforms remain after cumulative filtering (kept ", n_isoforms_used, ")")
      next
    }

    submat_final <- submat_f[iso_keep_final, , drop = FALSE]
    mat_smoothed <- submat_final + alpha
    p_mat <- sweep(mat_smoothed, 2, colSums(mat_smoothed), FUN = "/")  # proportions

    # raw entropy: -sum(p log2 p)
    entropy_raw <- vapply(seq_len(ncol(p_mat)), function(i) {
      p_vec <- p_mat[, i]
      valid <- p_vec > 0
      -sum(p_vec[valid] * log2(p_vec[valid]))
    }, numeric(1))

    # normalized: divide by log2(number of nonzero isoforms) per cell
    denom <- vapply(seq_len(ncol(p_mat)), function(i) {
      p_vec <- p_mat[, i]
      sum(p_vec > 0)
    }, numeric(1))
    norm_factor <- log2(denom)
    entropy_norm <- entropy_raw / norm_factor

    norm_entropy_mat[gene, colnames(p_mat)] <- entropy_norm
    raw_entropy_mat[gene, colnames(p_mat)]  <- entropy_raw

    # record cells used (where entropy was computed)
    cells_used <- colnames(p_mat)
    n_cells_used <- length(cells_used)

    isoform_summary_list[[gene]] <- list(
      gene = gene,
      isoforms_all = paste(isoforms, collapse = ";"),
      total_isoforms = total_isoforms,
      isoforms_passing_pct = paste(isoforms_passing_pct, collapse = ";"),
      n_isoforms_passing_pct = length(isoforms_passing_pct),
      isoforms_used = paste(iso_keep_final, collapse = ";"),
      n_isoforms_used = n_isoforms_used,
      cells_used = paste(cells_used, collapse = ";"),
      n_cells_used = n_cells_used
    )
  }

  # assemble summary df
  isoform_summary_df <- do.call(rbind, lapply(isoform_summary_list, function(x) {
    data.frame(
      gene = x$gene,
      isoforms_all = x$isoforms_all,
      total_isoforms = x$total_isoforms,
      isoforms_passing_pct = x$isoforms_passing_pct,
      n_isoforms_passing_pct = x$n_isoforms_passing_pct,
      isoforms_used = x$isoforms_used,
      n_isoforms_used = x$n_isoforms_used,
      cells_used = x$cells_used,
      n_cells_used = x$n_cells_used,
      stringsAsFactors = FALSE
    )
  }))
  rownames(isoform_summary_df) <- isoform_summary_df$gene

  # added this to deal with Nan values thata rise from 0 entropy values 
  nan_idx <- is.nan(norm_entropy_mat)
  norm_entropy_mat[nan_idx & raw_entropy_mat == 0] <- 0

  # filter genes by min_cell_fraction (based on normalized entropy presence)
  keep_genes <- rownames(norm_entropy_mat)[rowMeans(!is.na(norm_entropy_mat)) >= min_cell_fraction]
  norm_entropy_mat <- norm_entropy_mat[keep_genes, , drop = FALSE]
  raw_entropy_mat  <- raw_entropy_mat[keep_genes, , drop = FALSE]
  isoform_summary_df <- isoform_summary_df[keep_genes, , drop = FALSE]
  
  return(list(
    normalized_entropy = norm_entropy_mat,
    raw_entropy = raw_entropy_mat,
    isoform_summary = isoform_summary_df
  ))
}

```

```{r}

# Subset to RG (cycling)
RG_seu_obj <- subset(seu_obj , subset = sctype_db == "Radial glial cells")


DefaultAssay(RG_seu_obj) <- "RNA"
genes <- rownames(RG_seu_obj)


library(progressr)
handlers("txtprogressbar")


# Use with_progress and create progressor inside
res <- find_diversity(
    obj = RG_seu_obj,
    min_counts_per_cell = 10,
    assay = "iso",
    genes = genes
  )

```

```{r}
dim(res$raw_entropy)
```

After running the diversity function, we identified 269 genes for which we could calculate isoform diversity metrics. By default, these tend to be highly expressed genes that are detected in at least 20% of cells. These parameters can be changed by the user, but because single-cell data are sparse we recommend keeping relatively strict filters. This helps make sure that each gene has enough counts per cell to accurately estimate diversity.

We can summarise these results in a heatmap. In this plot, each column is a single cell and each row is a gene that passed filtering. Grey regions indicate cell–gene combinations where there were not enough counts to calculate entropy for that gene in that cell.

```{r}
library(pheatmap)
pheatmap(res$normalized_entropy,
         show_rownames = FALSE,
         show_colnames = FALSE,
         cluster_rows = TRUE,
         cluster_cols = TRUE,
         main = "Entropy heatmap",
         na_col = "darkgrey", )
```

```{r}

library(ggplot2)
# Median entropy per gene
df <- data.frame(
  gene = rownames(res$normalized_entropy),
  median_entropy = apply(res$normalized_entropy, 1, median, na.rm = TRUE)
)

# Global median
global_median <- median(df$median_entropy, na.rm = TRUE)

#Select bottom 25 nonzero genes, always include VIM
df_nonzero <- df %>% dplyr::filter(median_entropy > 0 | gene == "VIM")
df_low <- df_nonzero %>%
  dplyr::mutate(median_entropy = as.numeric(median_entropy)) %>%
  dplyr::arrange(median_entropy) %>%
  dplyr::slice(1:25)


# Top 25 by highest median entropy
df_high <- df %>%
  dplyr::mutate(median_entropy = as.numeric(median_entropy)) %>%  # ensure it's numeric
  dplyr::arrange(desc(median_entropy)) %>%
  dplyr::slice(1:25)


# --- Low entropy plot (blue) with scale break ---
p_low <- ggplot(df_low, aes(x = median_entropy, y = reorder(gene, median_entropy), fill = median_entropy)) +
  geom_col() +
  geom_vline(xintercept = global_median, linetype = "dashed", color = "black") +
  scale_fill_gradient(low = "darkblue", high = "skyblue") +
  labs(x = "Median Normalised Entropy", y = "Low Entropy Genes") +
  theme_bw(base_size = 12) +
  theme(legend.position = "none")

# --- High entropy plot (red) ---
p_high <- ggplot(df_high, aes(x = median_entropy, y = reorder(gene, median_entropy), fill = median_entropy)) +
  geom_col() +
  geom_vline(xintercept = global_median, linetype = "dashed", color = "black") +
  scale_fill_gradient(low = "mistyrose", high = "firebrick") +
  labs(x = "Median Normalised Entropy", y = "High Entropy Genes") +
  theme_bw(base_size = 12) +
  theme(legend.position = "none")

p_high | p_low

```

```{r}

# Visualize isoform features across UMAP
source("code/plot_isoforms_exp_umap.R")
source("code/plot_isoform_entropy.R") 

plot_isoforms_exp_umap(
  obj       = RG_seu_obj,
  gene      = "RPL19",
  reduction = "umap",
  slot      = "data",
  assay = "iso",
  n_features = 10#,  # Optional: limit to top 5 isoforms
  #entropy_mat = res$normalized_entropy
)

plots <- plot_isoform_entropy(
  RG_seu_obj,
  gene="RPS6",
  ident.name             = "sctype_db",
  cell.type              = NULL,
  assay                  = "iso",
  slot.counts            = "counts",
  slot.data              = "data",
  reduction              = "umap",
  min_gene_counts        = 10,
  isoform_min_pct_cells  = 0.05,
  isoform_cumulative_pct = 0.95,
  alpha                  = 0.0
)

```
