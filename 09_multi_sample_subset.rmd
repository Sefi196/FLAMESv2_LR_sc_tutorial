---
date: "`r Sys.Date()`"
output: html_document
---

# **Multisample analysis**

The FLAMES pipeline supports the analysis of multiple samples simultaneously, allowing users to efficiently process complex experimental datasets. This is achieved using the `MultiSampleSCPipeline` function. The output generated by this function is similar to the single-sample analysis outlined in previous chapters but offers additional capabilities when the experimental design includes sample replicates.

To take full advantage of these features we need to perform sample integration to generate a single object that we can use to integrate isoform expression across our conditions. First standard preprocessing as described in Chapters 3 and 4 is required. After integration we can perform the following key analysis:

1.  **Sample Integration:** Combine multiple samples together and add isoform counts.

2.  **Trajectory Analysis:** Explore genes that change along pseudotime trajectories.

3.  **Differential Transcript Usage (DTU) Analysis:** Investigate changes in isoform proportions between conditions. (Coming soon!!)

Most preprocessing and QC steps remain the same. However, we will also demonstrate how to proceed directly from FLAMES output to initial QC without performing empty droplet removal or ambient RNA normalization. Although these steps are recommended, they may not always be necessary depending on the data.

------------------------------------------------------------------------

### Dataset Information

For this analysis, we are using a dataset comprising eight samples spanning four time points from an excitatory neuronal differentiation protocol. The protocol is the same as the one used for the D55 sample in previous chapters but utilizes a different cell line. Two samples were collected from each of the following time points:

-   **Stem cells** (STC)

-   **Day 25**

This dataset will allow us to explore temporal changes in gene and isoform expression throughout neuronal differentiation.

## Standard pre-processing and quality control

As before we will modify the count matrix for each sample so we use gene_symbol instead of ENSG id. The data generated from this multisample experiment is quite large. This is especially the case with Oarfish isoform quantification as there are many more features to consider. This means much of the workflow below is time consuming and computationally intensive. Please keep this in mind when processing your samples. In the tutorial we provide code for the required steps but do not evaluate many of the sections below due to these computational constraints. The raw counts are available in the multisample data folder if users wish to run through the analysis.

make isoform gene dictionary for the mutisample mode

```{r}
# The FLAMES ref can be found in your selected output folder after running the Flames pipeline. 
FLAMES_gtf_file <- "data/multi_sample_subset/isoform_annotated.gtf" #ensure file is unzipped
reference_gtf_file <- "data/gencode.v47.annotation.gtf" # ensure file is unzipped
output_file <- "isoform_gene_dict_mutlisample_subset.csv"

# Call the helper function defined in code block above to create a dictionary containing corresponding gene information for each isoform
# This may take a few minutes 
isoform_gene_dict_mutlisample <- make_isoform_gene_symbol_dict(FLAMES_gtf_file,
                                                   reference_gtf_file,
                                                   output_file)
```

```{r, subset_multisample_genesymbol, cache=TRUE, echo=TRUE, eval=TRUE}
# convert Gene_id to gene symbol for all counts
#run a loop to run this function on all count files.
# Directory with input files
input_dir <- "./data/multi_sample_subset/"
output_dir <- "./data/multi_sample_subset/"

# List all CSV files in the input directory
input_files <- list.files(input_dir, pattern = "\\count_subset.csv$", full.names = TRUE)

# Initialize an empty list to store data frames
result_list <- list()

# Process each file in the directory
total_files <- length(input_files)  # Total number of files

for (i in seq_along(input_files)) {
  file_path <- input_files[i]
  
  # Extract file name without extension
  file_name <- tools::file_path_sans_ext(basename(file_path))
  
  # Construct the output file name
  output_file <- file.path(output_dir, paste0(file_name, "_gene_symbol.csv"))
  
  # Show progress to the user
  message(sprintf("Processing file %d of %d: %s", i, total_files, file_name))
  
  # Call the function with return_df = TRUE to store the result
    result_list[[file_name]] <- convert_ENSGID_to_geneSymbol(
    id_symbol_df = isoform_gene_dict_mutlisample,
    gene_count_matrix_path = file_path,
    output_file = output_file,
    return_df = TRUE
  )
}


```

### Define QC function

We have developed a multisample QC function \@ref(Multisample QC function) for processing count matrices and constructing filtered Seurat objects, following best practices outlined in the Seurat tutorial. This function includes steps to identify and remove doublets, as well as generate key diagnostic plots for data inspection. We encourage users to customize this function to fit their specific needs, such as applying additional filtering criteria.

For the purposes of presenting concise and readable code we will apply the default filtering parameters to all objects. If users wish to be more specific about filtering each sample independently this is possible and can be done by running the `perform_qc_filtering` function on each sample with desired parameters.

```{r, subset_multi_sample_qc, fig.height=6, fig.width=12, cache=FALSE, include=TRUE, eval=FALSE}

# Define sample names
sample_names <- c("C1_STC", "C4_STC", "C2_Day25", "C5_Day25")

# Initialize a list to store UMAP objects
umap_objects <- list()

# Start the PDF for output
pdf(file = "./output_files/multi_sample_subset/QC/multisample_QC.pdf", width = 10, height = 6)

# Loop through each sample and apply the QC filtering function
for (i in seq_along(sample_names)) {
  sample_name <- sample_names[i]
  
  # Print progress message
  message(paste0("Processing sample ", i, " of ", length(sample_names), ": ", sample_name))
  
  # Perform QC filtering
  result <- perform_qc_filtering(
    result_list[paste0(sample_name, "_matched_reads_gene_count_subset")],
    fig_name = sample_name,
    project = sample_name
  )
  
  # Store the UMAP object from the result
  umap_objects[[sample_name]] <- result[[1]]
}

# Close the PDF device
dev.off()

#save the object
saveRDS(umap_objects, file = "./output_files/multi_sample_subset//umap_objects.rds")
```

## Multisample integration

First we will merge the Seurat objects together and then perform integration. There are many options for sample integration and Seurat provides many wrappers for these functions. Here we will use Harmony [@korsunsky2019] for fast and effective integration. As these processes are time consuming we will load our saved objects.

```{r, subset_multisample_integration, cache=TRUE, include=TRUE, eval=TRUE, echo=TRUE}
# integrate samples  
#from the function above pull the filtered seurat object 

merged_seurat <- merge(
  umap_objects[["C1_STC"]],
  y = list(
    umap_objects[["C4_STC"]],
    umap_objects[["C2_Day25"]],
    umap_objects[["C5_Day25"]]
  ),
  add.cell.ids = c(
    "C1_STC", "C4_STC", "C2_Day25", "C5_Day25"
  ), 
  project = "Multi-sample_tutorial"
  )

# create a sample column
merged_seurat$sample <- rownames(merged_seurat@meta.data)

## split sample column to make a batch col
merged_seurat@meta.data <- separate(merged_seurat@meta.data, col = 'sample', into = c('batch', 'Day', 'Barcode'), 
                                    sep = '_')
#check some QC metrics 
VlnPlot(merged_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, group.by = "Day") + 
  plot_annotation(title = "Vln plots grouped by Day")

#can plot based on any metadata col
#VlnPlot(merged_seurat, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, group.by = "orig.ident")

# Number of cells per group
table(merged_seurat$orig.ident)
table(merged_seurat$Day)

# Apply normal preprocessing steps to merged file 

merged_seurat <- NormalizeData(object = merged_seurat)
merged_seurat <- FindVariableFeatures(object = merged_seurat)
merged_seurat <- ScaleData(object = merged_seurat) 
merged_seurat <- RunPCA(object = merged_seurat)
merged_seurat <- FindNeighbors(object = merged_seurat, dims = 1:16)
merged_seurat <- FindClusters(object = merged_seurat, resolution = 0.6)
merged_seurat <- RunUMAP(object = merged_seurat, dims = 1:30)

##save merged object
saveRDS(merged_seurat, file = "./output_files/multi_sample_subset//merged_seurat.rds")

```

```{r, subset_multisample_integration_2, include=TRUE, fig.height=6, fig.width=10, message=FALSE, echo=TRUE}
set.seed(00003)
merged_seurat <- readRDS("./output_files/multi_sample_subset/merged_seurat.rds")


#Let's plot the merged file. 
p1 <- FeaturePlot(merged_seurat, reduction = 'umap', features = 'nCount_RNA')
p2 <- FeaturePlot(merged_seurat, reduction = "umap", features = 'nFeature_RNA')
p3 <- DimPlot(merged_seurat, reduction = 'umap', group.by = 'Day')
p4 <- DimPlot(merged_seurat, reduction = 'umap', group.by = 'orig.ident')

grid.arrange(p1, p2, p3, p4, ncol = 2)


merged_seurat <- JoinLayers(object = merged_seurat)
merged_seurat[["RNA"]] <- split(merged_seurat[["RNA"]], f = merged_seurat$orig.ident)

#perform integration with Harmony
obj <- IntegrateLayers(object = merged_seurat,
                       method = HarmonyIntegration,
                       orig.reduction = "pca",
                       new.reduction = 'integrated.harm',
                       verbose = FALSE,
)

obj <- FindNeighbors(obj, reduction="integrated.harm")
obj <- FindClusters(obj, resolution=0.4, cluster.name="harm_cluster")
obj <- RunUMAP(obj, reduction="integrated.harm", dims=1:50, reduction.name = "umap.harm")


DimPlot(obj, reduction = "umap.harm", group.by = c("Day", "orig.ident", "harm_cluster"), label = T)  

### save object 
saveRDS(obj, file = "./output_files/multi_sample_subset//integrated_harm_seurat.rds")
```

## Add isoform counts

Now we can add isoform level information to the merged Seurat object. When doing this you may need to convert the Oarfish files into a count.csv file with the row names in the ENSTID_gene_symbol ID form. The function to do so can be found here \@ref(Convert Oarfish files to count matrix)

We will convert the Oarfish output to count data. We can also use the bellow fucntion to incldue or exlude Novel bambu genes that poarfish quantifies. for the sake of simplicity we will exclude novel bambu Genes.

```{r, message=FALSE, echo=TRUE, eval=FALSE}
# Define sample names
sample_names <- c("C1_STC",
                  "C4_STC",
                  "C2_Day25",
                  "C5_Day25")

# Loop through each sample and process the count files
for (sample in sample_names) {
  # Use tryCatch to handle errors
  tryCatch({
    # Call the function to process the sample
    process_oarfish_files_to_counts_matrix(
      sample_name = sample,
      resource_table_path = "./output_files/ref_files/isoform_gene_dict_mutlisample_subset.csv",
      output_dir = "./output_files/multi_sample_subset/oarfish_counts/",
      input_dir = "./data/multi_sample_subset/oarfsih/",
      filter_bambu_Genes = TRUE
    )
  }, error = function(e) {
    # Print the error message and exit the loop
    cat("Error processing sample:", sample, "\nError message:", e$message, "\nExiting loop.\n")
    stop(e)
  })
}
```

The workflow follows these steps.

1.  Create a Seurat object per sample
2.  Merge the objects together
3.  Filter the isoform merged object based on cell types that are high quality (based on gene level filtering)
4.  Add the isoform filtered and merged object to the gene level object as a new assay
5.  Integration on the isoform assay is possible but not shown here.

```{r, subset_multisample_add_iso_counts, eval=FALSE, echo=TRUE}

############ read in count matrix and add isoform assay to Seurat object  #########
#Make Seurat objects not filtered
# Function to read a CSV file and create a Seurat object
create_seurat_object <- function(sample_name, input_dir, project_name) {
  # Construct file path
  file_path <- file.path(input_dir, paste0("gene_symbol_oarfish_", sample_name, "_counts.csv"))
  
  # Read the CSV file
  counts <- fread(file_path)
  counts <- as.data.frame(counts) 
  rownames(counts) <- counts[[1]]            # Set row names from the first column
  counts[[1]] <- NULL     
  
  # Create the Seurat object
  seurat_obj <- CreateSeuratObject(counts = counts, project = project_name, min.cells = 5, min.features = 500)
  
  return(seurat_obj)
}

# Directory where the CSV files are stored
input_directory <- "./output_files/multi_sample_subset/oarfish_counts/"

# Create an empty list to store Seurat objects
iso_seurat_objects <- list()

total_samples <- length(sample_names)
for (i in seq_along(sample_names)) {
  sample <- sample_names[i]
  
  message(sprintf("Processing sample %d of %d: %s", i, total_samples, sample))
  
  iso_seurat_objects[[sample]] <- create_seurat_object(
    sample_name = sample,
    input_dir = input_directory,
    project_name = sample
  )
}

####### Merge the samples into one object ######
iso.merged_seurat <- merge(
  iso_seurat_objects[["C1_STC"]],
  y = list(
    iso_seurat_objects[["C4_STC"]],
    iso_seurat_objects[["C2_Day25"]],
    iso_seurat_objects[["C5_Day25"]]
  ),
  add.cell.ids = c(
    "C1_STC", "C4_STC", "C2_Day25", "C5_Day25"
  ), 
  project = "iso-Multi-sample_tutorial"
  )

# create a sample column
iso.merged_seurat$sample <- rownames(iso.merged_seurat@meta.data)

# split sample column to makw a batch col
iso.merged_seurat@meta.data <- separate(iso.merged_seurat@meta.data, col = 'sample', into = c('batch', 'Day', 'Barcode'), 
                                    sep = '_')

## filter the data to iso and gene cells match
merged_seurat_isoform_filtered <- subset(iso.merged_seurat, cells =obj@graphs[["RNA_nn"]]@Dimnames[[1]])

VlnPlot(merged_seurat_isoform_filtered, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)

# perform standard workflow steps
merged_seurat_isoform_filtered <- NormalizeData(object = merged_seurat_isoform_filtered) # if using SCT dont run this
merged_seurat_isoform_filtered <- FindVariableFeatures(object = merged_seurat_isoform_filtered) # if using SCT dont run this
merged_seurat_isoform_filtered <- ScaleData(object = merged_seurat_isoform_filtered) # if using SCT dont run this
merged_seurat_isoform_filtered <- RunPCA(object = merged_seurat_isoform_filtered)
#ElbowPlot(merged_seurat_isoform_filtered)
merged_seurat_isoform_filtered <- FindNeighbors(object = merged_seurat_isoform_filtered, dims = 1:10)
merged_seurat_isoform_filtered <- FindClusters(object = merged_seurat_isoform_filtered, resolution = 0.6)
merged_seurat_isoform_filtered <- RunUMAP(object = merged_seurat_isoform_filtered, dims = 1:10)

#Save file
saveRDS(merged_seurat_isoform_filtered, file = "./output_files/multi_sample_subset//merged_seurat_isoform_filtered.rds")
```

```{r, subset_multisample_add_iso_counts_2, echo=TRUE, cache=FALSE, message=FALSE}
merged_seurat_isoform_filtered <- readRDS(file = "./output_files/multi_sample_subset//merged_seurat_isoform_filtered.rds")

#plots
p5 <- DimPlot(merged_seurat_isoform_filtered, reduction = 'umap', group.by = 'orig.ident')
p6 <- DimPlot(merged_seurat_isoform_filtered, reduction = 'umap', group.by = 'Day')
p7 <- FeaturePlot(merged_seurat_isoform_filtered, reduction = 'umap', features = 'nCount_RNA')
p8 <- FeaturePlot(merged_seurat_isoform_filtered, reduction = "umap", features = 'nFeature_RNA')

grid.arrange(p5, p6, p7, p8, ncol = 2)

#####

merged_seurat_isoform_filtered <- JoinLayers(merged_seurat_isoform_filtered)
counts_table <- merged_seurat_isoform_filtered[["RNA"]]$counts

obj[["iso"]] <- CreateAssay5Object(counts = counts_table)

# Step 1: Normalize the new assay data
obj <- NormalizeData(obj, assay = "iso")
obj <- FindVariableFeatures(obj, assay = "iso")
obj <- ScaleData(obj, assay = "iso")

# Step 4: Perform PCA
obj <- RunPCA(obj, assay = "iso", reduction.name = "pca_iso")
# Step 5: Run UMAP
obj <- RunUMAP(obj, reduction = "pca_iso", dims = 1:15, assay = "iso", reduction.name = "umap_iso")

# Visualize the UMAP
DimPlot(obj, label = TRUE, reduction = "umap.harm") | DimPlot(obj, label = TRUE, reduction = "umap_iso")
```

## Identify cell types

Here we annotate cell types using some key markers.

Cluster 1 2 and 3 are stem ells

```{r, fig.height=3, fig.width=12, echo = TRUE}
# We can annoate Day 0 
FeaturePlot(obj, reduction = "umap.harm", features = c("MKI67", "NANOG", "POU5F1"), ncol = 3)
```

Cluster 0 and 4 - Radial Glia

```{r, fig.height=3, fig.width=12, echo = TRUE}
FeaturePlot(obj, reduction = "umap.harm", features = c("VIM", "SOX2", "PAX6"), ncol = 3)
```

Cluster 5 - Inhibitory neurons

```{r, fig.height=3, fig.width=12, echo = TRUE}
FeaturePlot(obj, reduction = "umap.harm", features = c("GAD1", "GAD2", "DLX5", "DLX6"),ncol = 4)
```

Cluster 6 - Excitatory neurons (NPC)

```{r, fig.height=3, fig.width=8, echo = TRUE}
#Clsuter 6 Excitorty neurons (NPC)
FeaturePlot(obj, reduction = "umap.harm", features = c("EOMES", "TBR1"))
```

Now we will assign these labels to each cluster.

```{r, cache=FALSE, echo=TRUE, fig.height=3, fig.width=6}
new_ids <- c(
  "0" = "Radial glia",
  "1" = "Stem cells",
  "2" = "Stem cells",
  "3" = "Stem cells",
  "4" = "Radial glia",
  "5" = "Inhibitory neurons",
  "6" = "Excitatory neurons"
)

obj <- RenameIdents(obj, new_ids)

# store as a metadata column for later
obj$cell_type <- Idents(obj)

# plot by cell type instead of numeric cluster
DimPlot(obj, group.by = "cell_type", reduction = "umap.harm")

#saveRDS(obj, file = "./output_files/multi_sample/multisample_seurat.intergrated_harm.isoform.rds")

```

Now that we have an integrated Seurat object containing both gene- and isoform-level counts, along with curated cell type annotations, we can move beyond static clustering to explore how these transcriptional programs change over time and across lineages. In the next sections, we will use this object as the foundation for **trajectory analysis**, to reconstruct developmental paths and cell state transitions, and for **differential transcript usage (DTU)** analysis, to identify genes whose **isoform composition** shifts between conditions, lineages, or cell types.
