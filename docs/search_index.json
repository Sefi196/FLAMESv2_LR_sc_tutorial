[["removing-sources-of-unwanted-noise-from-the-single-cell-dataset.html", "Chapter 3 Removing sources of unwanted noise from the single cell dataset 3.1 Removing ambient RNA contamination 3.2 Standard gene QC to remove low quality cells", " Chapter 3 Removing sources of unwanted noise from the single cell dataset Now we will do some initial prepossessing of single cell data to ensure we have some high quality data. This will involve 3 main steps Removing empty droplets - droplets that do not contain true cells. Removing ambient RNA contamination - optional Removing low quality cells that 3.0.1 Empty droplets This function removes empty droplets, a critical step to ensure that only true cells are retained for analysis. In short-read analysis using CellRanger, this process is automated, and empty droplets are removed by the software. However, FLAMES does not perform this step automatically, so it must be done manually. The function provided here not only removes empty droplets but also generates general QC metrics, enabling users to assess the reasonableness of the number of cells removed. ### notes: This fucnion should be refactored and cleaed up. Its very long and complex. perform_empty_drops_analysis &lt;- function(output_path, gene_count_file, empty_drops_file, output_seurat_file, fdr_threshold = 0.001, lower = 100) { # Load required libraries # Read in data df &lt;- read.csv(gene_count_file, row.names = 1) df_emptydrops &lt;- read.csv(empty_drops_file, row.names = 1) # Combine the dataframes by row names combined_df &lt;- merge(df, df_emptydrops, by = &quot;row.names&quot;, all = TRUE) rownames(combined_df) &lt;- combined_df[, 1] combined_df[, 1] &lt;- NULL combined_df[is.na(combined_df)] &lt;- 0 # Perform standard pre-processing before empty drops analysis seurat_obj &lt;- CreateSeuratObject(counts = df, project = &quot;Day_55&quot;, min.features = 20) seurat_obj[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(seurat_obj, pattern = &quot;^MT-&quot;) VlnPlot(seurat_obj, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) #seurat_obj &lt;- subset(seurat_obj, subset = nFeature_RNA &gt; 10 &amp; nFeature_RNA &lt; 100000 &amp; percent.mt &lt; 100) seurat_obj &lt;- NormalizeData(seurat_obj, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) seurat_obj &lt;- FindVariableFeatures(seurat_obj, selection.method = &quot;vst&quot;, nfeatures = 2000) all.genes &lt;- rownames(seurat_obj) seurat_obj &lt;- ScaleData(seurat_obj, features = all.genes) seurat_obj &lt;- RunPCA(seurat_obj, features = VariableFeatures(object = seurat_obj)) ElbowPlot(seurat_obj) seurat_obj &lt;- FindNeighbors(seurat_obj, dims = 1:10) seurat_obj &lt;- FindClusters(seurat_obj, resolution = 0.5) seurat_obj &lt;- RunUMAP(seurat_obj, dims = 1:10) DimPlot(seurat_obj, reduction = &quot;umap&quot;) # Define function to make dgCMatrix from combined counts makedgcmatrix &lt;- function(count.matrix) { seurat_object &lt;- CreateSeuratObject(counts = count.matrix, project = &quot;singlecell&quot;) list(seurat_object[[&quot;RNA&quot;]]$counts) } # Empty Drops Analysis combined_df[] &lt;- lapply(combined_df, function(x) as.numeric(as.character(x))) outs.ddcmatrix &lt;- makedgcmatrix(combined_df)[[1]] br.out &lt;- DropletUtils::barcodeRanks(outs.ddcmatrix) e.out &lt;- emptyDrops(outs.ddcmatrix, lower = lower, niters = 10000, test.ambient = TRUE, BPPARAM = SerialParam()) is.cell &lt;- e.out$FDR &lt; fdr_threshold # Create a dataframe with FDR of TRUE cells is.true.cell_CR &lt;- as.data.frame(e.out@listData[[&quot;FDR&quot;]], e.out@rownames) is.true.cell_CR &lt;- is.true.cell_CR %&gt;% filter(is.true.cell_CR$`e.out@listData[[&quot;FDR&quot;]]` &lt;= fdr_threshold) is.true.cell_CR &lt;- tibble::rownames_to_column(is.true.cell_CR, &quot;cell_id&quot;) # Function for retrieving the Seurat cells and cluster in dataframe overlap_true_cell &lt;- function(seurat_object) { seurat_cluster.df &lt;- as.data.frame(seurat_object$seurat_clusters) seurat_cluster.df &lt;- tibble::rownames_to_column(seurat_cluster.df, &quot;cell_id&quot;) seurat_cluster.df } # Obtain cluster dataframe from Seurat object overlap_CR &lt;- overlap_true_cell(seurat_obj) # Check overlaps between Seurat object and true cells summary(overlap_CR$cell_id %in% is.true.cell_CR$cell_id) # Function to add metadata to Seurat object True.cells &lt;- function(e.out) { cells &lt;- as.data.frame(e.out@rownames) fdr &lt;- as.data.frame(e.out$FDR) T.F.cells &lt;- cbind(cells, fdr) T.F.cells &lt;- data.frame(T.F.cells[,-1], row.names = T.F.cells[,1]) setnames(T.F.cells, c(&#39;FDR&#39;)) T.F.cells %&gt;% mutate(FDR = case_when(FDR &lt; fdr_threshold ~ &quot;Cells&quot;, FDR &gt; fdr_threshold ~ &quot;Empty_drops&quot;)) } cells_CR &lt;- True.cells(e.out) seurat_obj &lt;- AddMetaData(seurat_obj, metadata = cells_CR, col.name = &#39;is.cell&#39;) # Plot Empty drops on Gene UMAP # Create a ggplot object rankplot &lt;- ggplot(br.out, aes(x = rank, y = total)) + geom_point() + scale_x_log10() + scale_y_log10() + labs(x = &quot;Rank&quot;, y = &quot;Total&quot;) + geom_line(aes(y = fitted), color = &quot;red&quot;, linetype = &quot;solid&quot;) + geom_hline(yintercept = metadata(br.out)$knee, color = &quot;dodgerblue&quot;, linetype = &quot;dashed&quot;) + geom_hline(yintercept = metadata(br.out)$inflection, color = &quot;forestgreen&quot;, linetype = &quot;dashed&quot;) + theme( legend.position = &quot;bottomleft&quot; ) + guides(colour = guide_legend(override.aes = list(linetype = c(&quot;dashed&quot;, &quot;dashed&quot;)))) + annotate(&quot;text&quot;, x = Inf, y = metadata(br.out)$knee, label = &quot;knee&quot;, color = &quot;dodgerblue&quot;, vjust = -1, hjust = 1) + annotate(&quot;text&quot;, x = Inf, y = metadata(br.out)$inflection, label = &quot;inflection&quot;, color = &quot;forestgreen&quot;, vjust = -1, hjust = 1) # Summary table -&gt; may want to add a bunch of other summary metrics # Extract counts with checks for NULL cell_counts &lt;- as.data.frame(table(seurat_obj@meta.data$is.cell)) count_true_cells &lt;- ifelse(length(cell_counts$Freq[cell_counts$Var1 == &quot;Cells&quot;]) &gt; 0, cell_counts$Freq[cell_counts$Var1 == &quot;Cells&quot;], 0) count_empty_drops &lt;- ifelse(length(cell_counts$Freq[cell_counts$Var1 == &quot;Empty_drops&quot;]) &gt; 0, cell_counts$Freq[cell_counts$Var1 == &quot;Empty_drops&quot;], 0) # Create the summary table summary_table &lt;- data.frame( Description = c(&#39;fdr&#39;, &#39;lower Counts&#39;, &#39;number of true cells&#39;, &#39;number of empty drops&#39;), Value = c(fdr_threshold, lower, count_true_cells, count_empty_drops) ) summary_grob &lt;- tableGrob(summary_table, rows = NULL, cols = NULL) # Create the combined plot plot1 &lt;- grid.arrange( rankplot, DimPlot(seurat_obj, reduction = &quot;umap&quot;, group.by = &#39;is.cell&#39;) + labs(color = &quot;is.cell&quot;, title = &#39;Seurat Object&#39;) + theme(text = element_text(size = 10), plot.background = element_rect(fill = &quot;white&quot;)), FeaturePlot(seurat_obj, features = &quot;nCount_RNA&quot;) + theme(plot.background = element_rect(fill = &quot;white&quot;)), FeaturePlot(seurat_obj, features = &quot;nFeature_RNA&quot;) + theme(plot.background = element_rect(fill = &quot;white&quot;)), summary_grob, ncol = 2, top = textGrob(&#39;Empty drops vs real cells&#39;) ) #output the plot and summary stats pdf(file = file.path(output_path, paste0(output_seurat_file, &quot;_plots.pdf&quot;)), width = 6, height = 6, bg = &quot;white&quot;) plot(plot1) dev.off() # Subset the Seurat object to remove cells marked as empty drops seurat_obj_rm_empty &lt;- subset(seurat_obj, subset = is.cell == &#39;Cells&#39;) #save the seurat objects saveRDS(seurat_obj, file = file.path(output_path, paste0(&quot;with_empty_&quot;, output_seurat_file, &quot;.rds&quot;))) saveRDS(seurat_obj_rm_empty, file = file.path(output_path, paste0(&quot;removed_empty_&quot;, output_seurat_file, &quot;.rds&quot;))) } ##################### # usage perform_empty_drops_analysis( gene_count_file = &quot;./output_files/counts/geneSymbol_gene_count.csv&quot;, empty_drops_file = &quot;./output_files/counts/background_geneSymbol_gene_count.csv&quot;, output_path = &quot;./output_files/empty_drops/&quot;, output_seurat_file = &quot;Day55&quot;, fdr_threshold = 0.001, # see droplet utils if you want to adjust these params lower = 500 # see droplet utils if you want to adjust these params ) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 344 ## Number of edges: 7209 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8510 ## Number of communities: 7 ## Elapsed time: 0 seconds 3.1 Removing ambient RNA contamination Now we will remove ambient RNA contamination using decontX (or SoupX). This step is optional, and it’s up to the user to decide whether it’s necessary. In this case, the barcode rank plot (found here…) shows a clear distinction between true barcodes and background barcodes, suggesting that ambient RNA contamination may not significantly contribute to noise in this dataset. However, we’ll demonstrate how to run this step in case your barcode rank plot is noisier and contamination is a concern. if users wish to skip this step take the ‘seurat_obj_rm_empty’ object and proceed to standard gene QC step. ## -------------------------------------------------- ## Starting DecontX ## -------------------------------------------------- ## Wed Dec 11 20:26:14 2024 .. Analyzing all cells ## Wed Dec 11 20:26:15 2024 .... Converting to sparse matrix ## Wed Dec 11 20:26:15 2024 .... Generating UMAP ## Wed Dec 11 20:26:20 2024 .... Estimating contamination ## Wed Dec 11 20:26:20 2024 ...... Completed iteration: 10 | converge: 0.02483 ## Wed Dec 11 20:26:20 2024 ...... Completed iteration: 20 | converge: 0.009197 ## Wed Dec 11 20:26:20 2024 ...... Completed iteration: 30 | converge: 0.005009 ## Wed Dec 11 20:26:21 2024 ...... Completed iteration: 40 | converge: 0.003423 ## Wed Dec 11 20:26:21 2024 ...... Completed iteration: 50 | converge: 0.00254 ## Wed Dec 11 20:26:21 2024 ...... Completed iteration: 60 | converge: 0.002116 ## Wed Dec 11 20:26:22 2024 ...... Completed iteration: 70 | converge: 0.001571 ## Wed Dec 11 20:26:22 2024 ...... Completed iteration: 80 | converge: 0.00118 ## Wed Dec 11 20:26:22 2024 ...... Completed iteration: 87 | converge: 0.0009944 ## Wed Dec 11 20:26:22 2024 .. Calculating final decontaminated matrix ## -------------------------------------------------- ## Completed DecontX. Total time: 7.738443 secs ## -------------------------------------------------- ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.001336 0.040294 0.065590 0.095857 0.113042 0.810218 ## Centering and scaling data matrix ## PC_ 1 ## Positive: VIM, ADGRV1, GLI3, DOK5, CACHD1, DACH1, SMC4, SHROOM3, RCN1, PARD3 ## FBXL7, PHGDH, HMGA2, HMGN2, ID3, ENSG00000286757, ID4, LRIG1, SOX2, NBPF14 ## LTBP1, YAP1, HMGB2, ZFP36L1, SLC35F1, TRIM59-IFT80, SMC2, TUBA1B, COL4A5, LEF1 ## Negative: NRXN1, PTPRD, MYT1L, LRRC7, ANK3, MAPT, DCC, UNC79, PTPRN2, SLC4A10 ## KCNH7, ENOX1, ANKS1B, EPHA5, RALYL, PHACTR3, CNTNAP2, RUNX1T1, NBEA, CACNA1E ## THSD7A, CACNA1A, GRIA2, NSG2, LINC01122, NELL2, RBFOX1, CELF4, NFASC, NEUROD6 ## PC_ 2 ## Positive: HECW1, LHX2, MPPED2, IVNS1ABP, LEF1, SEZ6L, SFRP1, ENSG00000251680, CADPS, ROBO2 ## ADAMTS19, B3GAT2, LRRC3B, FUT9, LMNB1, SNCAIP, TMTC1, NKAIN3, LTBP1, FOXP1 ## NRG1, STOX1, SV2C, PANTR1, PREX2, SEMA3C, ITGA2, GLI3, UHRF1, ENSG00000301688 ## Negative: SLIT3, RSPO2, RBM47, DYNLRB2-AS1, PRTG, LMX1A, PCP4, WLS, ENSG00000287949, MAF ## GJA1, FYB2, RSPO1, PLS3, MIR4435-2HG, NR3C2, RBM20, ZIC1, KRT8, LGI1 ## EYA4, KRT18, ENSG00000241231, TPBG, TTR, OTX2, WNT2B, PTCHD1-AS, DLK1, IFITM1 ## PC_ 3 ## Positive: NHLH1, EBF2, SLC22A23, DISP3, ENSG00000285755, CECR2, LINC01830, FRMD4B, ARL4D, BHLHE22 ## ENC1, RASGEF1B, ENSG00000310169, BHLHE22-AS1, PPP1R17, CRABP1, CHD7, FAM149A, RBFOX3, NFIA-AS2 ## HYCC1, LMO1, NPTX1, HUNK, UNC5A, SERINC5, PGAP1, P2RX3, PRDM8, ENSG00000231252 ## Negative: OPCML, NAV3, FRMD4A, GRIN2B, XKR4, KIRREL3, NALF1, KCNMA1, CNTN1, NAV2 ## GRIK3, CALN1, LRP1B, SMARCA2, DGKI, NRG3, SYN3, PRKG1, MACROD2, GAREM1 ## SLCO3A1, MDGA2, SYT13, ATXN1, ULK4, GRID2, GABBR2, ZC3H12B, LMO3, RIMS1 ## PC_ 4 ## Positive: ZFPM2, ZFPM2-AS1, ZEB2, MYO5B, CSRP2, ZBTB18, PLXDC2, ST18, NEUROD6, CAP2 ## NELL2, ENSG00000307341, PDE1A, GAREM1, ADAMTS3, FLRT2, DLGAP1, EPHA7, NEUROD2, GRIA3 ## CTTNBP2, SLC24A2, PDGFC, DMD, SYNDIG1, CORO2B, CENPE, KCNH7, SDK1, THSD7A ## Negative: COPG2, PBX3, GAD2, COPG2IT1, VGF, ENSG00000259460, KCNMB2, MEIS2, KCNMB2-AS1, LINC01414 ## SIX3, ENSG00000270953, MEST, ENSG00000298285, SPRY4-AS1, PCDH7, DLX1, DLX6-AS1, SORCS3, SIX3-AS1 ## GRM7, KCNH1, CDH8, DLX2, SGCD, MDGA2, SLC35F3, NRXN3, GAD1, MIR325HG ## PC_ 5 ## Positive: CDC20, CCNB1, PLK1, UBE2S, DLGAP5, KNSTRN, CCNB2, ARL6IP1, TPX2, AURKA ## NEK2, PTTG1, CDKN3, TROAP, GTSE1, UBE2C, BUB1, SGO2, KIF20A, CEP55 ## PRR11, CENPE, GAS2L3, CDCA8, ASPM, PIMREG, ARHGAP11A, BIRC5, NDE1, DEPDC1 ## Negative: HECW1, DPP10, GPC6, LINC03051, BMPR1B, SLC1A3, SPIDR, DMD, ZFPM2, TMTC1 ## SDK1, ADAMTS6, ADAMTS19, ENSG00000301688, HDAC9, MEGF11, PVT1, MCM4, LRP4, RHBDL3 ## FREM2, TAFA1, STOX1, LAMA1, RORA, NCKAP5, HELLS, PDGFC, STOX2, KHDRBS2 ## Computing nearest neighbor graph ## Computing SNN ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 339 ## Number of edges: 7342 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8177 ## Number of communities: 8 ## Elapsed time: 0 seconds ## 20:26:24 UMAP embedding parameters a = 0.9922 b = 1.112 ## 20:26:24 Read 339 rows and found 20 numeric columns ## 20:26:24 Using Annoy for neighbor search, n_neighbors = 30 ## 20:26:24 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 20:26:24 Writing NN index file to temp file /tmp/Rtmp8EdkU0/file14d802807a7fd ## 20:26:24 Searching Annoy index using 1 thread, search_k = 3000 ## 20:26:24 Annoy recall = 100% ## 20:26:25 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 ## 20:26:26 Initializing from normalized Laplacian + noise (using RSpectra) ## 20:26:26 Commencing optimization for 500 epochs, with 11376 positive edges ## 20:26:28 Optimization finished ## Making plots ## Saving seurat obj ## Saving decontx counts ## Saving contamination summary 3.2 Standard gene QC to remove low quality cells Now that we have removed empty drops and ambient RNA we will perform standard QC as described in the Seurat tutorial (found here). First we will determine what our filtering criteria should be using some basic QC plots. # standard QC filtering and also remove doublets #define sample name sample_id = &#39;Day55_tutorial&#39; # Create Seurat object seurat_object &lt;- CreateSeuratObject(counts = deconx_results$decontaminated_counts, project = sample_id) ## Warning: Data is of class matrix. Coercing to dgCMatrix. # Plot relationship between reads and unique genes per cell plot_scatter1 &lt;- FeatureScatter(seurat_object, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + geom_smooth(method = &quot;lm&quot;) + NoLegend() + labs(title = &quot;Reads vs Unique Genes per Cell BEFORE Filtering&quot;) plot(plot_scatter1) ## `geom_smooth()` using formula = &#39;y ~ x&#39; # Add mitochondrial percentage seurat_object[[&quot;joined&quot;]] &lt;- JoinLayers(seurat_object[[&quot;RNA&quot;]]) ## Warning: Key &#39;rna_&#39; taken, using &#39;joined_&#39; instead seurat_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(seurat_object, pattern = &quot;^MT-&quot;) p1 &lt;- VlnPlot(seurat_object, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;)) ## Warning: Default search for &quot;data&quot; layer in &quot;RNA&quot; assay yielded no results; utilizing ## &quot;counts&quot; layer instead. p1 + plot_annotation(title = &quot;QC plots (gene level) BEFORE Filtering&quot;) Based on these QC plots we will filter the data with the following values listed in the bellow code chunk. QC paramaters might vary based on your own data so please make sure you filter your data accordingly. Here we will also remove doublets - droplets that contain two or more cells - using the package ‘doubletfinder’. ## Warning: Default search for &quot;data&quot; layer in &quot;RNA&quot; assay yielded no results; utilizing ## &quot;counts&quot; layer instead. ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 319 ## Number of edges: 6816 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.7804 ## Number of communities: 8 ## Elapsed time: 0 seconds ## [1] &quot;Creating artificial doublets for pN = 5%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 10%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 15%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 20%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 25%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 30%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## NULL ## [1] &quot;Creating 106 artificial doublets...&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Computing pANN...&quot; ## [1] &quot;Classifying doublets..&quot; Now that we have filtered the object to ensure we retain high quality data we are going to add in the isoform level information. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
