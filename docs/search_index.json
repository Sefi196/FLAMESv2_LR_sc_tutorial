[["index.html", "FLAMES Single-Cell RNA-seq Tutorial Chapter 1 Introduction 1.1 Prerequisites 1.2 Getting Started with the Data 1.3 Dataset Information 1.4 Citation 1.5 Contact", " FLAMES Single-Cell RNA-seq Tutorial Sefi PrawerPostdoctoral Research Fellow in Long Reads and Single-Cell TranscriptomicsUniversity of Melbourne 2025-02-07 Chapter 1 Introduction Welcome to the FLAMES analysis tutorial! In this tutorial, we demonstrate how to process and analyze long-read single-cell RNA sequencing data using outputs from the FLAMES package (Tian et al., 2021). FLAMES enables the identification and quantification of isoform-level expression in single cells, providing a unique opportunity to uncover transcriptomic complexity that is often undetectable in short-read data. We will demonstrate how to load and explore FLAMES outputs in Seurat and other popular single-cell analysis tools. By following this workflow, you’ll learn how to: Preprocess long-read single-cell data Visualize isoform expression patterns and isoform structure Identify differentially expressed isoforms across cell types Detect novel isoforms with potential functional impact If you’re familiar with short-read data processing, much of the pre-processing workflow will feel intuitive. However, long-read single cell sequencing provides isoform-level information which enables you to explore isoform dynamics in single cells. This can be useful for exploring complex developmental systems or disease parthenogenesis. 1.1 Prerequisites This tutorial assumes you have already processed your long-read single-cell data using FLAMES, either through the sc_long_pipeline or sc_long_multisample_pipeline. Please ensure that the following parameters in your configuration file are set to TRUE to enable isoform identification and quantification with Bambu (Chen et al., 2023) and Oarfish (Jousheghani &amp; Patro, 2024): \"bambu_isoform_identification\": [true] \"oarfish_quantification\": [true] While FLAMES is optimized for use with specific quantification and isoform discovery tools, much of this workflow can be adapted for use with other tools which FLAMES supports. We recommend using Bambu and Oarfish as they have been validated for the type of analysis demonstrated here. Additionally, we provide an optional step for users interested in removing empty droplets and ambient RNA contamination. If you plan to use this feature, ensure that you have previously calculated the ambient RNA profile. Detailed instructions for this step can be found here 11.1 1.2 Getting Started with the Data To follow along with this tutorial, you can use the data provided in the ‘data’ folder from the github page. dowload it using the following command: Code wget https://github.com/Sefi196/FLAMESv2_LR_sc_tutorial/data. Simply unzip all files to begin. If you prefer to run the tutorial using your own output from FLAMES, there is no need to unzip your files. However, be sure to use the correct GTF file. The GTF file used during FLAMES processing must be the same one used for downstream analyses. The current version utilized in this tutorial can be downloaded using the following command: Code wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_47/gencode.v47.annotation.gtf.gz 1.3 Dataset Information This tutorial uses data generated by the Clark Lab at the University of Melbourne, consisting of a small dataset of approximately 400 cells. The cells were collected at Day 55 of an excitatory neural differentiation protocol. More details on the dataset, sequencing methodology, and the differentiation protocol can be found in the following publication: (You et al., 2023) [PLACE HOLDER - FLAMESv2 paper] 1.4 Citation If you find this tutorial useful please cite our work [PLACE HOLDER - FLAMESv2 paper] 1.5 Contact For questions or suggestions, please feel free to email us at sefi.prawer@unimelb.edu.au or leave a comment on our GitHub page: https://github.com/Sefi196/FLAMESv2_LR_sc_tutorial. "],["setup.html", "Chapter 2 Setup 2.1 load in required packages 2.2 Creating resource files. 2.3 Convert count matrices from Gene ID to gene Symbol", " Chapter 2 Setup 2.1 load in required packages Code #install packages if required. Note some packages require installation via bioconductor. See installation instruction for each package to ensure installation is successful. library(rtracklayer) library(Seurat) library(DropletUtils) library(gridExtra) library(data.table) library(BiocParallel) library(celda) library(SingleCellExperiment) library(DoubletFinder) library(stringr) library(cowplot) library(grid) library(patchwork) library(tidyverse) library(ORFik) library(GenomicFeatures) library(Gviz) library(BSgenome.Hsapiens.UCSC.hg38) # Set working directory and create folders for output files setwd(&quot;.&quot;) # Set this to correct location dir.create(&quot;./output_files/ref_files&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/counts&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/seu_objects&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/empty_drops&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/decontx&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/QC&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/DE&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/mutli_sample&quot;, recursive = TRUE, showWarnings = FALSE) 2.2 Creating resource files. To start, we’ll create a few essential files that will be used throughout the analysis. The first step is to generate a CSV file containing three key columns: ENSTID, ENSGID, and geneSymbol. This file will be used as a dictionary to rename entries in both the isoform and gene count matrices, replacing ENSGID with the corresponding gene symbol. By adopting this naming convention for ENSTID, we can easily identify the gene origin of each isoform, streamlining the interpretation and analysis of gene and isoform-level data. First lets define a helper function for this step: Code # Function to make csv naming resource make_isoform_gene_symbol_dict &lt;- function(FLAMES_gtf, reference_gtf, output_file) { # Import the first GTF file (transcripts GTF) gtf1 &lt;- import(FLAMES_gtf) gtf1_df &lt;- as.data.frame(gtf1) # Select relevant columns from the first GTF selected_columns1 &lt;- gtf1_df[, c(&quot;transcript_id&quot;, &quot;gene_id&quot;)] unique_selected_cols &lt;- unique(selected_columns1) # Import the second GTF file (reference GTF with gene symbols) gtf2 &lt;- import(reference_gtf) gtf2_df &lt;- as.data.frame(gtf2) # Select relevant columns from the second GTF selected_columns2 &lt;- gtf2_df[, c(&quot;gene_name&quot;, &quot;gene_id&quot;)] unique_gene_symbol &lt;- unique(selected_columns2) # Merge the two data frames on &#39;gene_id&#39; combined_data &lt;- merge(unique_selected_cols, unique_gene_symbol, by = &quot;gene_id&quot;, all.x = TRUE) # If &#39;gene_name&#39; is missing, replace it with &#39;gene_id&#39; combined_data$gene_symbol &lt;- ifelse(is.na(combined_data$gene_name), combined_data$gene_id, combined_data$gene_name) # Select relevant columns final_combined_data &lt;- combined_data[, c(&quot;transcript_id&quot;, &quot;gene_id&quot;, &quot;gene_symbol&quot;)] # Write to a CSV file write.csv(final_combined_data, file = file.path(&quot;output_files/ref_files&quot;, output_file), row.names = FALSE) return(final_combined_data) } Run this chunk to create the dictionary containing ENSTID, ENSGID, and geneSymbol information: Code # The FLAMES ref can be found in your selected output folder after running the Flames pipeline. FLAMES_gtf_file &lt;- &quot;./data/FLAMES_out/isoform_annotated.gtf&quot; #ensure file is unzipped reference_gtf_file &lt;- &quot;data/gencode.v47.annotation.gtf&quot; # ensure file is unzipped output_file &lt;- &quot;isoform_gene_dict.csv&quot; # Call the helper function defined in code block above to create a dictionary containing corresponding gene information for each isoform # This may take a few minutes isoform_gene_dict &lt;- make_isoform_gene_symbol_dict(FLAMES_gtf_file, reference_gtf_file, output_file) 2.3 Convert count matrices from Gene ID to gene Symbol With the reference dictionary in place, we can now rename both our count matrix and background count matrix by converting ENSGIDs to geneSymbols. This conversion not only simplifies the interpretation of gene expression in single cells but is also necessary for some downstream tools that require gene symbols instead of ENSGIDs, such as automated cell annotation tools. Like before, lets define a generic helper function first to do this: Code convert_ENSGID_to_geneSymbol &lt;- function(gene_count_matrix_path, id_symbol_df = isoform_gene_dict, output_file, return_df = FALSE) { # Load the reference dictionary we made earlier - select gene-level cols id_symbol_df &lt;- as_tibble(id_symbol_df) %&gt;% dplyr::select(gene_id, gene_symbol) # Load the data object with ENSGID row names gene_count_matrix &lt;- fread(gene_count_matrix_path, header = TRUE) colnames(gene_count_matrix)[1] &lt;- &quot;gene_id&quot; # Replace ENSGIDs with gene symbols in original flames gene-level count matrix formatted_gene_count_matrix &lt;- gene_count_matrix %&gt;% merge(id_symbol_df, by.x = &#39;gene_id&#39;, by.y = &#39;gene_id&#39;) %&gt;% # Add gene symbol information distinct(gene_symbol, .keep_all = TRUE) %&gt;% # Remove duplicates based on gene symbol dplyr::select(-gene_id) %&gt;% # Remove the ENSGID column column_to_rownames(var = &quot;gene_symbol&quot;) # use the gene symbols we added as rownames # Write out the processed data frame fwrite(formatted_gene_count_matrix, output_file, row.names = TRUE) # Return the processed count matrix for further use if needed if(return_df){ return(formatted_gene_count_matrix) } } Run the chunk below to format gene-level count matrices for background and FLAMES data using the helper function from above: Code # convert Gene_id to gene symbol for gene counts convert_ENSGID_to_geneSymbol( gene_count_matrix_path = &quot;./data/FLAMES_out/gene_count.csv&quot;, output_file = &quot;./output_files/counts/geneSymbol_gene_count.csv&quot; ) # convert Gene_id to gene symbol for background counts convert_ENSGID_to_geneSymbol( gene_count_matrix_path = &quot;./data/background/gene_count.csv&quot;, output_file = &quot;./output_files/counts/background_geneSymbol_gene_count.csv&quot; ) Now we have the files we need to begin cleaning our data and removing unwanted noise. "],["removing-sources-of-unwanted-noise-from-the-single-cell-dataset.html", "Chapter 3 Removing sources of unwanted noise from the single cell dataset 3.1 Empty droplets 3.2 Removing ambient RNA contamination 3.3 Standard gene QC to remove low quality cells", " Chapter 3 Removing sources of unwanted noise from the single cell dataset Now we will do some initial prepossessing of single cell data to ensure we have some high quality data. This will involve 3 main steps Removing empty droplets - droplets that do not contain true cells. Removing ambient RNA contamination - optional Removing low quality cells that 3.1 Empty droplets This function removes empty droplets, a critical step to ensure that only true cells are retained for analysis. In short-read analysis using CellRanger, this process is automated, and empty droplets are removed by the software. However, FLAMES does not perform this step automatically, so it must be done manually. The function provided here not only removes empty droplets but also generates general QC metrics, enabling users to assess the reasonableness of the number of cells removed. Code ### notes: This fucnion should be refactored and cleaed up. Its very long and complex. perform_empty_drops_analysis &lt;- function(output_path, gene_count_file, empty_drops_file, output_seurat_file, fdr_threshold = 0.001, lower = 100) { # Load required libraries # Read in data df &lt;- read.csv(gene_count_file, row.names = 1) df_emptydrops &lt;- read.csv(empty_drops_file, row.names = 1) # Combine the dataframes by row names combined_df &lt;- merge(df, df_emptydrops, by = &quot;row.names&quot;, all = TRUE) rownames(combined_df) &lt;- combined_df[, 1] combined_df[, 1] &lt;- NULL combined_df[is.na(combined_df)] &lt;- 0 # Perform standard pre-processing before empty drops analysis seurat_obj &lt;- CreateSeuratObject(counts = df, project = &quot;Day_55&quot;, min.features = 20) seurat_obj[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(seurat_obj, pattern = &quot;^MT-&quot;) VlnPlot(seurat_obj, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) #seurat_obj &lt;- subset(seurat_obj, subset = nFeature_RNA &gt; 10 &amp; nFeature_RNA &lt; 100000 &amp; percent.mt &lt; 100) seurat_obj &lt;- NormalizeData(seurat_obj, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) seurat_obj &lt;- FindVariableFeatures(seurat_obj, selection.method = &quot;vst&quot;, nfeatures = 2000) all.genes &lt;- rownames(seurat_obj) seurat_obj &lt;- ScaleData(seurat_obj, features = all.genes) seurat_obj &lt;- RunPCA(seurat_obj, features = VariableFeatures(object = seurat_obj)) ElbowPlot(seurat_obj) seurat_obj &lt;- FindNeighbors(seurat_obj, dims = 1:10) seurat_obj &lt;- FindClusters(seurat_obj, resolution = 0.5) seurat_obj &lt;- RunUMAP(seurat_obj, dims = 1:10) DimPlot(seurat_obj, reduction = &quot;umap&quot;) # Define function to make dgCMatrix from combined counts makedgcmatrix &lt;- function(count.matrix) { seurat_object &lt;- CreateSeuratObject(counts = count.matrix, project = &quot;singlecell&quot;) list(seurat_object[[&quot;RNA&quot;]]$counts) } # Empty Drops Analysis combined_df[] &lt;- lapply(combined_df, function(x) as.numeric(as.character(x))) outs.ddcmatrix &lt;- makedgcmatrix(combined_df)[[1]] br.out &lt;- DropletUtils::barcodeRanks(outs.ddcmatrix) e.out &lt;- emptyDrops(outs.ddcmatrix, lower = lower, niters = 10000, test.ambient = TRUE, BPPARAM = SerialParam()) is.cell &lt;- e.out$FDR &lt; fdr_threshold # Create a dataframe with FDR of TRUE cells is.true.cell_CR &lt;- as.data.frame(e.out@listData[[&quot;FDR&quot;]], e.out@rownames) is.true.cell_CR &lt;- is.true.cell_CR %&gt;% filter(is.true.cell_CR$`e.out@listData[[&quot;FDR&quot;]]` &lt;= fdr_threshold) is.true.cell_CR &lt;- tibble::rownames_to_column(is.true.cell_CR, &quot;cell_id&quot;) # Function for retrieving the Seurat cells and cluster in dataframe overlap_true_cell &lt;- function(seurat_object) { seurat_cluster.df &lt;- as.data.frame(seurat_object$seurat_clusters) seurat_cluster.df &lt;- tibble::rownames_to_column(seurat_cluster.df, &quot;cell_id&quot;) seurat_cluster.df } # Obtain cluster dataframe from Seurat object overlap_CR &lt;- overlap_true_cell(seurat_obj) # Check overlaps between Seurat object and true cells summary(overlap_CR$cell_id %in% is.true.cell_CR$cell_id) # Function to add metadata to Seurat object True.cells &lt;- function(e.out) { cells &lt;- as.data.frame(e.out@rownames) fdr &lt;- as.data.frame(e.out$FDR) T.F.cells &lt;- cbind(cells, fdr) T.F.cells &lt;- data.frame(T.F.cells[,-1], row.names = T.F.cells[,1]) setnames(T.F.cells, c(&#39;FDR&#39;)) T.F.cells %&gt;% mutate(FDR = case_when(FDR &lt; fdr_threshold ~ &quot;Cells&quot;, FDR &gt; fdr_threshold ~ &quot;Empty_drops&quot;)) } cells_CR &lt;- True.cells(e.out) seurat_obj &lt;- AddMetaData(seurat_obj, metadata = cells_CR, col.name = &#39;is.cell&#39;) # Plot Empty drops on Gene UMAP # Create a ggplot object rankplot &lt;- ggplot(br.out, aes(x = rank, y = total)) + geom_point() + scale_x_log10() + scale_y_log10() + labs(x = &quot;Rank&quot;, y = &quot;Total&quot;) + geom_line(aes(y = fitted), color = &quot;red&quot;, linetype = &quot;solid&quot;) + geom_hline(yintercept = metadata(br.out)$knee, color = &quot;dodgerblue&quot;, linetype = &quot;dashed&quot;) + geom_hline(yintercept = metadata(br.out)$inflection, color = &quot;forestgreen&quot;, linetype = &quot;dashed&quot;) + theme( legend.position = &quot;bottomleft&quot; ) + guides(colour = guide_legend(override.aes = list(linetype = c(&quot;dashed&quot;, &quot;dashed&quot;)))) + annotate(&quot;text&quot;, x = Inf, y = metadata(br.out)$knee, label = &quot;knee&quot;, color = &quot;dodgerblue&quot;, vjust = -1, hjust = 1) + annotate(&quot;text&quot;, x = Inf, y = metadata(br.out)$inflection, label = &quot;inflection&quot;, color = &quot;forestgreen&quot;, vjust = -1, hjust = 1) # Summary table -&gt; may want to add a bunch of other summary metrics # Extract counts with checks for NULL cell_counts &lt;- as.data.frame(table(seurat_obj@meta.data$is.cell)) count_true_cells &lt;- ifelse(length(cell_counts$Freq[cell_counts$Var1 == &quot;Cells&quot;]) &gt; 0, cell_counts$Freq[cell_counts$Var1 == &quot;Cells&quot;], 0) count_empty_drops &lt;- ifelse(length(cell_counts$Freq[cell_counts$Var1 == &quot;Empty_drops&quot;]) &gt; 0, cell_counts$Freq[cell_counts$Var1 == &quot;Empty_drops&quot;], 0) # Create the summary table summary_table &lt;- data.frame( Description = c(&#39;fdr&#39;, &#39;lower Counts&#39;, &#39;number of true cells&#39;, &#39;number of empty drops&#39;), Value = c(fdr_threshold, lower, count_true_cells, count_empty_drops) ) summary_grob &lt;- tableGrob(summary_table, rows = NULL, cols = NULL) # Create the combined plot plot1 &lt;- grid.arrange( rankplot, DimPlot(seurat_obj, reduction = &quot;umap&quot;, group.by = &#39;is.cell&#39;) + labs(color = &quot;is.cell&quot;, title = &#39;Seurat Object&#39;) + theme(text = element_text(size = 10), plot.background = element_rect(fill = &quot;white&quot;)), FeaturePlot(seurat_obj, features = &quot;nCount_RNA&quot;) + theme(plot.background = element_rect(fill = &quot;white&quot;)), FeaturePlot(seurat_obj, features = &quot;nFeature_RNA&quot;) + theme(plot.background = element_rect(fill = &quot;white&quot;)), summary_grob, ncol = 2, top = textGrob(&#39;Empty drops vs real cells&#39;) ) #output the plot and summary stats pdf(file = file.path(output_path, paste0(output_seurat_file, &quot;_plots.pdf&quot;)), width = 6, height = 6, bg = &quot;white&quot;) plot(plot1) dev.off() # Subset the Seurat object to remove cells marked as empty drops seurat_obj_rm_empty &lt;- subset(seurat_obj, subset = is.cell == &#39;Cells&#39;) #save the seurat objects saveRDS(seurat_obj, file = file.path(output_path, paste0(&quot;with_empty_&quot;, output_seurat_file, &quot;.rds&quot;))) saveRDS(seurat_obj_rm_empty, file = file.path(output_path, paste0(&quot;removed_empty_&quot;, output_seurat_file, &quot;.rds&quot;))) } ##################### # usage perform_empty_drops_analysis( gene_count_file = &quot;./output_files/counts/geneSymbol_gene_count.csv&quot;, empty_drops_file = &quot;./output_files/counts/background_geneSymbol_gene_count.csv&quot;, output_path = &quot;./output_files/empty_drops/&quot;, output_seurat_file = &quot;Day55&quot;, fdr_threshold = 0.001, # see droplet utils if you want to adjust these params lower = 500 # see droplet utils if you want to adjust these params ) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 344 ## Number of edges: 7209 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8510 ## Number of communities: 7 ## Elapsed time: 0 seconds 3.2 Removing ambient RNA contamination Now we will remove ambient RNA contamination using decontX (or SoupX). This step is optional, and it’s up to the user to decide whether it’s necessary. In this case, the barcode rank plot (Figure 3.1) shows a clear distinction between true barcodes and background barcodes, suggesting that ambient RNA contamination may not significantly contribute to noise in this dataset. However, we’ll demonstrate how to run this step in case your barcode rank plot is noisier and contamination is a concern. if users wish to skip this step take the ‘seurat_obj_rm_empty’ object and proceed to standard gene QC step. Code knitr::include_graphics(&quot;images/knee_plot.png&quot;) Figure 3.1: Barcode rank plot produced by FLAMES. Code # Function to run decontX on a single Seurat object run_decontX &lt;- function(seurat_obj_path, background_counts_path, sample_id) { # Load the Seurat object seurat_obj &lt;- readRDS(seurat_obj_path) filtered_counts &lt;- as.matrix(GetAssayData(seurat_obj, layer = &quot;counts&quot;)) # Read background counts raw_counts &lt;- as.matrix(read.csv(background_counts_path, row.names = 1)) # Get cluster info from Seurat object cluster_info &lt;- setNames(seurat_obj$seurat_clusters, colnames(seurat_obj)) # Find common genes common_genes &lt;- intersect(rownames(filtered_counts), rownames(raw_counts)) raw_counts &lt;- raw_counts[common_genes, ] filtered_counts &lt;- filtered_counts[common_genes, ] # Create SingleCellExperiment objects sce_raw &lt;- SingleCellExperiment(list(counts = raw_counts)) sce_object &lt;- SingleCellExperiment(list(counts = filtered_counts)) # Run decontX with background sce &lt;- decontX(sce_object, z = cluster_info, background = sce_raw) # Summarize contamination levels contamination_summary &lt;- as.array(summary(sce$decontX_contamination)) print(contamination_summary) # Add contamination levels to Seurat object metadata contamination &lt;- colData(sce)$decontX_contamination seurat_obj &lt;- AddMetaData(seurat_obj, metadata = contamination, col.name = &quot;decontX_contamination&quot;) # Extract decontaminated counts from SCE object decontaminated_counts &lt;- assay(sce, &quot;decontXcounts&quot;) decontaminated_counts &lt;- as.matrix(decontaminated_counts) # Create a new assay with decontaminated counts and add it to Seurat object new_assay &lt;- CreateAssayObject(counts = decontaminated_counts) seurat_obj[[&quot;decontaminated&quot;]] &lt;- new_assay clusters_umap_orig &lt;- DimPlot( object = seurat_obj, group.by = &quot;seurat_clusters&quot;, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5 ) + labs(title = &quot;UMAP with Clusters&quot;) # Plot UMAP with contamination levels contamination_umap &lt;- FeaturePlot( object = seurat_obj, features = &quot;decontX_contamination&quot;, reduction = &quot;umap&quot; ) + labs(title = &quot;decontX contamination value&quot;) DefaultAssay(seurat_obj) &lt;- &quot;decontaminated&quot; # Normalization, variable feature selection, and scaling seurat_obj &lt;- NormalizeData(seurat_obj) seurat_obj &lt;- FindVariableFeatures(seurat_obj) seurat_obj &lt;- ScaleData(seurat_obj) # PCA and clustering seurat_obj &lt;- RunPCA(seurat_obj) seurat_obj &lt;- FindNeighbors(seurat_obj, dims = 1:20) seurat_obj &lt;- FindClusters(seurat_obj, resolution = 0.7) # UMAP seurat_obj &lt;- RunUMAP(seurat_obj, dims = 1:20) # Plot UMAP with updated clusters clusters_umap &lt;- DimPlot( object = seurat_obj, group.by = &quot;seurat_clusters&quot;, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5 ) + labs(title = &quot;UMAP with Corrected Clusters&quot;) # Combine plots combined_umap &lt;- cowplot::plot_grid(clusters_umap_orig, contamination_umap, clusters_umap, ncol = 2) cat(&quot;Making plots\\n&quot;) # Save the combined plot as a PDF #pdf(file = paste0(sample_id, &quot;_decontx_plots.pdf&quot;), width = 18, height = 6) print(combined_umap) #dev.off() cat(&quot;Saving seurat obj\\n&quot;) # Save the Seurat object saveRDS(seurat_obj, file = paste0(sample_id, &quot;_decontx_seurat_obj.rds&quot;)) # Save decontaminated counts and contamination summary cat(&quot;Saving decontx counts\\n&quot;) write.csv(decontaminated_counts, paste0(sample_id, &quot;_decontx_counts.csv&quot;)) # Print a message indicating that the contamination summary is being saved cat(&quot;Saving contamination summary\\n&quot;) # Ensure contamination_summary is a data frame contamination_summary_df &lt;- as.data.frame(contamination_summary) write.table(contamination_summary_df, file = paste0(sample_id, &quot;_contamination_summary.txt&quot;)) # Optionally return the results return(list(seurat_obj = seurat_obj, decontaminated_counts = decontaminated_counts, contamination_summary = contamination_summary)) } # Run decontX on the input Seurat object and background counts file deconx_results &lt;- run_decontX(&quot;./output_files/empty_drops/removed_empty_Day55.rds&quot;, &quot;./output_files/counts/background_geneSymbol_gene_count.csv&quot;, &quot;./output_files/decontx//Day55&quot;) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.001336 0.040294 0.065590 0.095857 0.113042 0.810218 ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 339 ## Number of edges: 7342 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8177 ## Number of communities: 8 ## Elapsed time: 0 seconds ## Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric ## To use Python UMAP via reticulate, set umap.method to &#39;umap-learn&#39; and metric to &#39;correlation&#39; ## This message will be shown once per session ## Making plots ## Saving seurat obj ## Saving decontx counts ## Saving contamination summary 3.3 Standard gene QC to remove low quality cells Now that we have removed empty drops and ambient RNA we will perform standard QC as described in the Seurat tutorial (found here). First we will determine what our filtering criteria should be using some basic QC plots. Code # standard QC filtering and also remove doublets #define sample name sample_id = &#39;Day55_tutorial&#39; # Create Seurat object seurat_object &lt;- CreateSeuratObject(counts = deconx_results$decontaminated_counts, project = sample_id) # Plot relationship between reads and unique genes per cell plot_scatter1 &lt;- FeatureScatter(seurat_object, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + geom_smooth(method = &quot;lm&quot;) + NoLegend() + labs(title = &quot;Reads vs Unique Genes per Cell BEFORE Filtering&quot;) plot(plot_scatter1) Code # Add mitochondrial percentage seurat_object[[&quot;joined&quot;]] &lt;- JoinLayers(seurat_object[[&quot;RNA&quot;]]) seurat_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(seurat_object, pattern = &quot;^MT-&quot;) p1 &lt;- VlnPlot(seurat_object, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;)) p1 + plot_annotation(title = &quot;QC plots (gene level) BEFORE Filtering&quot;) Based on these QC plots we will filter the data with the following values listed in the bellow code chunk. QC paramaters might vary based on your own data so please make sure you filter your data accordingly. Here we will also remove doublets - droplets that contain two or more cells - using the package ‘doubletfinder’. Code # Filter cells based on feature and count thresholds ## define the filtering params - (change these based on your data) max.features = 10000 min.features = 1000 min.counts = 800 max.counts = 100000 MT = 10 npc = 15 doublet_rate = 0.039 cluster_res = 0.9 #now we filter the seurat object based on the QC params listed above filt_seurat_object &lt;- subset(seurat_object, subset = nFeature_RNA &gt; min.features &amp; nFeature_RNA &lt; max.features &amp; percent.mt &lt; MT &amp; nCount_RNA &lt; max.counts &amp; nCount_RNA &gt; min.counts) # Plot quality metrics after filtering p2 &lt;- VlnPlot(filt_seurat_object, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;)) p2 + plot_annotation(title = &quot;QC metrics gene level AFTER Filtering&quot;) Code # Normalize data filt_seurat_object &lt;- NormalizeData(filt_seurat_object, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) # Identify highly variable features filt_seurat_object &lt;- FindVariableFeatures(filt_seurat_object, selection.method = &quot;vst&quot;, nfeatures = 2000) # Apply linear transformation all_genes &lt;- rownames(filt_seurat_object) filt_seurat_object &lt;- ScaleData(filt_seurat_object, features = all_genes) # Perform PCA filt_seurat_object &lt;- RunPCA(filt_seurat_object, features = VariableFeatures(object = filt_seurat_object)) # Cluster cells filt_seurat_object &lt;- FindNeighbors(filt_seurat_object, dims = 1:npc) filt_seurat_object &lt;- FindClusters(filt_seurat_object, resolution = cluster_res) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 319 ## Number of edges: 6816 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.7804 ## Number of communities: 8 ## Elapsed time: 0 seconds Code # Perform UMAP filt_seurat_object &lt;- RunUMAP(filt_seurat_object, dims = 1:npc) ### Filter out doublets (remember to modify doublet rate if samples have variable target cells) ## pK Identification (no ground-truth) sweep.res.list_pbmc &lt;- paramSweep(filt_seurat_object, PCs = 1:npc, sct = FALSE) ## [1] &quot;Creating artificial doublets for pN = 5%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 10%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 15%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 20%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 25%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 30%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; Code sweep.stats_pbmc &lt;- summarizeSweep(sweep.res.list_pbmc, GT = FALSE) bcmvn_pbmc &lt;- find.pK(sweep.stats_pbmc) ## NULL Code ##### pK &lt;- bcmvn_pbmc %&gt;% filter(BCmetric == max(BCmetric)) %&gt;% dplyr::select(pK) pK &lt;- as.numeric(as.character(pK[[1]])) ## Homotypic Doublet Proportion Estimate annotations &lt;- filt_seurat_object@meta.data$seurat_clusters homotypic.prop &lt;- modelHomotypic(annotations) nExp_poi &lt;- round(doublet_rate * nrow(filt_seurat_object@meta.data)) nExp_poi.adj &lt;- round(nExp_poi * (1 - homotypic.prop)) # Run doubletFinder filt_seurat_object &lt;- doubletFinder(filt_seurat_object, PCs = 1:npc, pN = 0.25, pK = pK, nExp = nExp_poi.adj, reuse.pANN = FALSE, sct = FALSE) ## [1] &quot;Creating 106 artificial doublets...&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Computing pANN...&quot; ## [1] &quot;Classifying doublets..&quot; Code colnames(filt_seurat_object@meta.data) &lt;- sub(&quot;DF.classifications_.*$&quot;, &quot;DF.classifications&quot;, colnames(filt_seurat_object@meta.data)) # Summary doublets statsDoublets &lt;- filt_seurat_object@meta.data %&gt;% group_by(DF.classifications) %&gt;% summarize(Median_nCount_RNA = median(nCount_RNA), Median_nFeature_RNA = median(nFeature_RNA), Count = n()) ###Save the seurat object with doublets listed filt_seurat_object_doublets &lt;- filt_seurat_object filt_seurat_object &lt;- subset(filt_seurat_object, subset = DF.classifications == &#39;Singlet&#39;) # figures ggplot_list &lt;- list( ElbowPlot(filt_seurat_object) + labs(title = &#39;SD explained by each PC&#39;) + theme(text = element_text(size = 10)), FeatureScatter(filt_seurat_object, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + geom_smooth(method = &quot;lm&quot;) + NoLegend() + labs(title = &quot;Association between reads and \\nunique genes per cell AFTER filtering&quot;), DimPlot(filt_seurat_object, reduction = &quot;umap&quot;) + labs(color = &quot;Cluster \\n(from PCA)&quot;, title = &#39;&#39;) + theme(text = element_text(size = 10)), FeaturePlot(filt_seurat_object, reduction = &quot;umap&quot;, features = &#39;nCount_RNA&#39;) + labs(color = &quot;UMI count&quot;, title = &#39;&#39;) + theme(text = element_text(size = 10)), FeaturePlot(filt_seurat_object, reduction = &quot;umap&quot;, features = &#39;nFeature_RNA&#39;) + labs(color = str_wrap(&quot;Feature count (gene)&quot;, 15), title = &#39;&#39;) + theme(text = element_text(size = 10)), p2 ) combined_plots &lt;- plot_grid(plotlist = ggplot_list, ncol = 3) plot(combined_plots) Code plot(DimPlot(filt_seurat_object_doublets, reduction = &#39;umap&#39;, group.by = &quot;DF.classifications&quot;)) Code tbl_sts1 &lt;- tableGrob(statsDoublets) grid.newpage() grid.draw(tbl_sts1) Code stats_sumary &lt;- rbind(&quot;Sample ID&quot; = sample_id, &quot;Cells_before_filter&quot; = dim(seurat_object)[2], &quot;Cells_after_filter&quot; = dim(filt_seurat_object)[2], &quot;Median Feature per Cell before filter&quot; = median(seurat_object$nFeature_RNA), &quot;Median Reads per Gene before filter&quot; = median(seurat_object$nCount_RNA), &quot;Median Feature per Cell&quot; = median(filt_seurat_object$nFeature_RNA), &quot;Median Reads per Gene&quot; = median(filt_seurat_object$nCount_RNA), &quot;Max Features&quot; = max.features, &quot;Min Features&quot; = min.features, &quot;Min Counts&quot; = min.counts, &quot;Max Counts&quot; = max.counts, &quot;MT Percentage&quot; = MT, &quot;NPCs&quot; = npc, &quot;Median Percent MT before Filter&quot; = median(seurat_object@meta.data[[&quot;percent.mt&quot;]]), &quot;Median Percent MT after Filter&quot; = median(filt_seurat_object@meta.data[[&quot;percent.mt&quot;]]) ) tbl_sts2 &lt;- tableGrob(stats_sumary) grid.newpage() grid.draw(tbl_sts2) Code #save files saveRDS(filt_seurat_object, file = paste0(&quot;./output_files/QC/&quot;, sample_id, &quot;_umap_object.rds&quot;)) saveRDS(filt_seurat_object_doublets, file = paste0(&quot;./output_files/QC/&quot;,sample_id, &quot;_with_doublets_umap_object.rds&quot;)) write.table(stats_sumary, file = paste0(&quot;./output_files/QC/&quot;, sample_id, &quot;_stats.csv&quot;)) Now that we have filtered the object to ensure we retain high quality data we are going to add in the isoform level information. "],["add-isoform-counts-to-seurat-object.html", "Chapter 4 Add isoform counts to Seurat object 4.1 Create a Seurat object with isoform expression data 4.2 Filter the new Seurat object based on gene level information 4.3 Add the isoform assay to the Seurat object", " Chapter 4 Add isoform counts to Seurat object 4.1 Create a Seurat object with isoform expression data Now that we have 309 high-quality cells for our downstream analysis, let’s incorporate isoform-level information into our Seurat object. The first step is to read in the outputs from FLAMES, which provides isoform-level counts from Oarfish. We’ll create a new Seurat object for this data, specifically for the isoform counts, and add it as a new assay to our existing object. This setup will allow us to explore both gene-level and isoform-level counts within a single Seurat object, giving us a more comprehensive view of our data. Code #This function reads in Oarfish count files and creates a csv file of count data. The function also appends the gene symbol to the ENSTID process_oarfish_files_to_counts_matrix &lt;- function(flames_output_folder, sample_name, output_dir) { # Read in the resource table (transcript_id, gene_id, gene_symbol) # Define the file paths based on the sample name count_matrix_path &lt;- file.path(flames_output_folder, paste0(sample_name, &quot;.count.mtx&quot;)) barcodes_path &lt;- file.path(flames_output_folder, paste0(sample_name, &quot;.barcodes.txt&quot;)) features_path &lt;- file.path(flames_output_folder, paste0(sample_name, &quot;.features.txt&quot;)) # Read the data counts &lt;- readMM(count_matrix_path) barcodes &lt;- readLines(barcodes_path) features &lt;- read.delim(features_path, header = FALSE) # Transpose the matrix for Seurat compatibility counts &lt;- t(counts) # Set row and column names rownames(counts) &lt;- features$V1 colnames(counts) &lt;- barcodes # Convert to a data frame counts_df &lt;- as.data.frame(counts) # Add transcript_id as the first column counts_df$transcript_id &lt;- rownames(counts_df) counts_df &lt;- counts_df[, c(ncol(counts_df), 1:(ncol(counts_df)-1))] # Merge with the resource table to add gene symbols df_genesymbol &lt;- counts_df %&gt;% left_join(isoform_gene_dict, by = &quot;transcript_id&quot;) # Remove the gene_id column and reorder the columns df_genesymbol$gene_id &lt;- NULL df_genesymbol &lt;- df_genesymbol[, c(ncol(df_genesymbol), 1:(ncol(df_genesymbol)-1))] # Update row names to include gene symbol instead of transcript_id rownames(df_genesymbol) &lt;- paste0(df_genesymbol$transcript_id, &quot;_&quot;, df_genesymbol$gene_symbol) df_genesymbol$transcript_id &lt;- NULL df_genesymbol$gene_symbol &lt;- NULL # Write the output to a CSV file output_path &lt;- file.path(output_dir, paste0(&quot;gene_symbol_&quot;, sample_name, &quot;_counts.csv&quot;)) write.csv(df_genesymbol, output_path) cat(&quot;Processed sample:&quot;, sample_name, &quot;\\nOutput saved to:&quot;, output_path, &quot;\\n&quot;) return(df_genesymbol) } oarfish_counts &lt;- process_oarfish_files_to_counts_matrix( flames_output_folder = &quot;/data/scratch/users/yairp/FLAMES_Day55/outs/&quot;, sample_name = &quot;oarfish&quot;, output_dir = &quot;./output_files/counts/&quot; ) ## Processed sample: oarfish ## Output saved to: ./output_files/counts//gene_symbol_oarfish_counts.csv Code # Create the Seurat object with iso counts iso_seurat_obj &lt;- CreateSeuratObject(counts = oarfish_counts, project = sample_id) VlnPlot(iso_seurat_obj, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;), ncol = 2) + plot_annotation(title = &quot;QC plots (isoform level) BEFORE Filtering&quot;) 4.2 Filter the new Seurat object based on gene level information We have now created a Seurat object with isoform-level count data. Users can take this object and follow similar processing steps as at the gene level 3, which might include filtering out low-quality cells and removing ambient RNA counts. In our case, we evaluated these steps and found they don’t add much value as low quality cells are already removed at the gene level and we can leverage this information rather than processing the isoform counts in the same way. Additionally, tools like DeconX and SoupX haven’t been tested on isoform count data, so we decided to exclude this analysis. Instead, we believe the most valuable approach is to append the isoform data to our gene-level Seurat object, resulting in two assays: one for gene-level and one for isoform-level data. If users have short-read data, they could similarly add it as a third assay. Since we’ve already filtered out low-quality cells based on our gene-level data, we’ll use these high-quality cells to filter our isoform data. Code #### isofrom assay ## filter the data so iso and gene cells match oarfish_iso_matched_gene &lt;- subset(iso_seurat_obj, cells =filt_seurat_object@graphs[[&quot;RNA_nn&quot;]]@Dimnames[[1]]) #Rejoin data sets after integration oarfish_iso_matched_gene &lt;- JoinLayers(oarfish_iso_matched_gene) counts_table_iso &lt;- oarfish_iso_matched_gene[[&quot;RNA&quot;]]$counts as.data.frame(counts_table_iso) -&gt; df_iso # Remove rows where the sum is 0 df_iso &lt;- df_iso[rowSums(df_iso) != 0, ] filt_seurat_object[[&quot;iso&quot;]] &lt;- CreateAssay5Object(counts = df_iso) # Normalize the new assay data filt_seurat_object &lt;- NormalizeData(filt_seurat_object, assay = &quot;iso&quot;) filt_seurat_object &lt;- FindVariableFeatures(filt_seurat_object, assay = &quot;iso&quot;) filt_seurat_object &lt;- ScaleData(filt_seurat_object, assay = &quot;iso&quot;) filt_seurat_object &lt;- RunPCA(filt_seurat_object, assay = &quot;iso&quot;, reduction.name = &quot;pca_iso&quot;) #Run UMAP filt_seurat_object &lt;- RunUMAP(filt_seurat_object, reduction = &quot;pca_iso&quot;, dims = 1:15, assay = &quot;iso&quot;, reduction.name = &quot;umap_iso&quot;) #check to see that we have two assays filt_seurat_object ## An object of class Seurat ## 93557 features across 309 samples within 3 assays ## Active assay: RNA (14906 features, 2000 variable features) ## 3 layers present: counts, data, scale.data ## 2 other assays present: joined, iso ## 4 dimensional reductions calculated: pca, umap, pca_iso, umap_iso Code # visualize the UMAP for Gene and isoform DimPlot(filt_seurat_object, label = TRUE, reduction = &quot;umap&quot;) + ggtitle(&quot;UMAP gene level clustering&quot;) | DimPlot(filt_seurat_object, label = TRUE, reduction = &quot;umap_iso&quot;) + ggtitle(&quot;UMAP isoform level clustering&quot;) Code seu_obj &lt;- filt_seurat_object saveRDS(seu_obj, file = &quot;./output_files/seu_objects/Day55_tutorial_gene_and_isoform_seurat.rds&quot;) 4.3 Add the isoform assay to the Seurat object Great! We now have an object containing both assays, so we can start by plotting some of our favorite genes and isoforms. This setup gives us the flexibility to visualize gene expression on isoform UMAPs and vice versa, allowing us to integrate and explore the expression of both gene and isoform expression within single cells on the same dimensional reduction. Let’s begin by plotting VIM and TBR1. VIM is a marker of progenitor cells, while TBR1 is a marker of deep layer neurons. Code ####### test plotting on iso assays ## features &lt;- rownames(filt_seurat_object@assays$iso@features) gene &lt;- &quot;VIM&quot; plot_features_list &lt;- grep(paste0(&quot;(^|-|\\\\b)&quot;, gene, &quot;($|\\\\b)&quot;), features, value = TRUE) #We can now plot our favorite gene and all its corresponding isoforms on either the gene or isoform UMAPs. To switch between them, simply change the reduction argument to the desired UMAP (either the gene or isoform reduction) FeaturePlot(filt_seurat_object, features = plot_features_list, reduction = &quot;umap_iso&quot;) Code FeaturePlot(filt_seurat_object, features = gene, reduction = &quot;umap&quot;) Code #lets also plot the isoform data on the gene level clsuters. FeaturePlot(filt_seurat_object, features = plot_features_list, reduction = &quot;umap&quot;) + plot_annotation( title = &#39;VIM isoform expresstion plotted on gene level clusters&#39;, #caption = &#39;made with patchwork&#39;, theme = theme(plot.title = element_text(size = 20)) ) Code gene &lt;- &quot;TBR1&quot; plot_features_list &lt;- grep(paste0(&quot;(^|-|\\\\b)&quot;, gene, &quot;($|\\\\b)&quot;), features, value = TRUE) #We can now plot our favorite gene and all its corresponding isoforms on either the gene or isoform UMAPs. To switch between them, simply change the reduction argument to the desired UMAP (either the gene or isoform reduction) FeaturePlot(filt_seurat_object, features = plot_features_list, reduction = &quot;umap_iso&quot;) Code FeaturePlot(filt_seurat_object, features = gene, reduction = &quot;umap&quot;) Code #lets also plot the isoform data on the gene level clsuters. FeaturePlot(filt_seurat_object, features = plot_features_list, reduction = &quot;umap&quot;) + plot_annotation( title = &#39;TBR1 isoform expresstion plotted on gene level clusters&#39;, #caption = &#39;made with patchwork&#39;, theme = theme(plot.title = element_text(size = 20)) ) We observe that the expression of VIM and TBR1 are is localized to two distinct clusters, which aligns with our expectations. This suggests that some cells remain in the progenitor/radial glial stage, while others have already begun differentiating into neurons. Furthermore, our data reveals isoform-level expression for each of our genes, including TBR1, which shows distinct isoform expression patterns across different cell populations. To plot genes and expressed isoforms from that gene simply change the ‘gene’ value to your favorite gene and run the code chunk above. Now we have a count matrix with two assays, gene and isoform. There are many avenues for analysis. We will begin with finding DE genes and isoforms. Then we identify cell types and perform trajectory analysis. finally we look into interesting isoforms unique to each cluster "],["finding-marker-genes-and-isoforms.html", "Chapter 5 Finding marker genes and isoforms 5.1 Differentially expressed genes by cluster identity 5.2 Identifying cell types 5.3 DE genes and isoforms based on annotaed cell types. 5.4 Volcano plots", " Chapter 5 Finding marker genes and isoforms 5.1 Differentially expressed genes by cluster identity First we can look at marker genes for each cluster. This will help us identify which genes are DE in each cluster and indicate the identity of each cluster. We will also look at DE isoforms using the same methodology. Code #Find markers for all clusters using the &quot;RNA&quot; and &quot;iso&quot; assay all_markers_gene_cluster &lt;- FindAllMarkers(seu_obj, assay = &quot;RNA&quot;, do.print = TRUE, logfc.threshold = 0.5, min.pct = 0.20, only.pos = TRUE) %&gt;% dplyr::filter(p_val_adj &lt; 0.05) all_markers_iso_cluster &lt;- FindAllMarkers(seu_obj, assay = &quot;iso&quot;, do.print = TRUE, logfc.threshold = 0.5, min.pct = 0.20, only.pos = TRUE) %&gt;% dplyr::filter(p_val_adj &lt; 0.05) #save the list of DE genes write.csv(all_markers_gene_cluster, &quot;./output_files/DE/all_markers_one_gene.csv&quot;) write.csv(all_markers_iso_cluster, &quot;./output_files/DE/all_markers_one_iso.csv&quot;) 5.2 Identifying cell types Based on these differentially expressed (DE) genes, we can identify the cell types present in our sample. This process is often complex and requires prior knowledge of cell markers as well as an understanding of the cell types expected in the sample. An alternative approach is to use automated cell type identification tools. In this tutorial, we will use scType [ref]. However, it is important to note that the accuracy of automated tools varies and depends heavily on the reference database they utilize. Therefore, it is recommended to use a combination of methods to cross-validate cell type identification and ensure robust results. Code # load libraries from sctype invisible(lapply(c(&quot;ggraph&quot;,&quot;igraph&quot;,&quot;tidyverse&quot;, &quot;data.tree&quot;), library, character.only = T)) invisible(lapply(c(&quot;dplyr&quot;,&quot;Seurat&quot;,&quot;HGNChelper&quot;), library, character.only = T)) # load gene set preparation function source(&quot;https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R&quot;) # load cell type annotation function source(&quot;https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R&quot;) #### # define functions perform_sctype_analysis &lt;- function(seurat_obj, db_, tissue, gs_removal_list = c(), metadat_col_prefix = &quot;db_prefix&quot;, figure_prefix =&quot;fig_name&quot;, cluster_res = &quot;RNA_snn_res.0.9&quot;, output_file = &quot;&quot;, reduction = &quot;umap&quot;) { # Prepare gene sets gs_list &lt;- gene_sets_prepare(db_, tissue) # Remove specified gene sets for (gs in gs_removal_list) { gs_list[[&quot;gs_positive&quot;]][[gs]] &lt;- NULL } # Calculate sctype scores es.max &lt;- sctype_score(scRNAseqData = seurat_obj@assays$RNA$scale.data, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative) # Set identities in Seurat object Idents(seurat_obj) &lt;- cluster_res # Merge by cluster cL_results &lt;- do.call(&quot;rbind&quot;, lapply(unique(seurat_obj@meta.data[[cluster_res]]), function(cl) { es.max.cl &lt;- sort(rowSums(es.max[, rownames(seurat_obj@meta.data[seurat_obj@meta.data[[cluster_res]] == cl, ])]), decreasing = TRUE) head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(seurat_obj@meta.data[[cluster_res]] == cl)), 10) })) sctype_scores &lt;- cL_results %&gt;% group_by(cluster) %&gt;% top_n(n = 1, wt = scores) # Set low-confident clusters to &quot;Unknown&quot; sctype_scores$scores &lt;- as.numeric(sctype_scores$scores) sctype_scores$type[sctype_scores$scores &lt; sctype_scores$ncells / 4] &lt;- &quot;Unknown&quot; print(sctype_scores[, 1:3]) # Overlay the labels seurat_obj@meta.data[[metadat_col_prefix]] &lt;- &quot;&quot; for (j in unique(sctype_scores$cluster)) { cl_type &lt;- sctype_scores[sctype_scores$cluster == j,] seurat_obj@meta.data[[metadat_col_prefix]][seurat_obj@meta.data[[cluster_res]] == j] &lt;- as.character(cl_type$type[1]) } # Plotting pclass &lt;- DimPlot(seurat_obj, reduction = reduction, label = TRUE, repel = TRUE, group.by = metadat_col_prefix) print(pclass) # Save the plot to a PDF pdf(file = paste0(figure_prefix, &quot;_&quot;, metadat_col_prefix, &quot;_sctype_genes.pdf&quot;), width = 8, height = 8) print(pclass + ggtitle(figure_prefix)) dev.off() # Save the updated Seurat object to an RDS file #if (output_file != &quot;&quot;) { # saveRDS(seurat_obj, file = paste0(output_file, &quot;.rds&quot;)) #} # Return the updated Seurat object return(seurat_obj) } # Define variables db_ = &quot;https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx&quot;; # this is a defualt databse from sctype tissue &lt;- &quot;Brain&quot; gs_removal_list &lt;- c(&quot;Tanycytes&quot;) # list of cell types from the db to remove seu_obj &lt;- perform_sctype_analysis(seu_obj, db_, tissue, gs_removal_list, metadat_col_prefix =&quot;sctype_db&quot;, figure_prefix = &quot;Day_55&quot;, output_file = &quot;Day_55&quot;, cluster_res = &quot;RNA_snn_res.0.9&quot;, reduction = &quot;umap&quot;) ## # A tibble: 8 × 3 ## # Groups: cluster [8] ## cluster type scores ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Immature neurons 81.3 ## 2 7 Myelinating Schwann cells 7.18 ## 3 0 Mature neurons 108. ## 4 6 Mature neurons 37.4 ## 5 3 Radial glial cells 85.1 ## 6 4 GABAergic neurons 82.8 ## 7 5 Radial glial cells 92.0 ## 8 1 Radial glial cells 94.0 Sctype gives us some indication of which cell types we have in our data. We can use the DE genes to get some more specific info. Glutatergic Neuronal Markers “SLC17A7”,“SLC17A6”,“GRIN1”,“GRIN2B” are all DE in cluster 0 - the mature neuron cluster. This suggests these cells are likely glutamatergic neurons. Code # markers for FeaturePlot(seu_obj, features = c(&quot;SLC17A7&quot;,&quot;SLC17A6&quot;,&quot;GRIN1&quot;,&quot;GRIN2B&quot;)) Code library(gprofiler2) background_genes &lt;- rownames(GetAssayData(seu_obj, assay = &quot;RNA&quot;, layer = &quot;counts&quot;))[ Matrix::rowSums(GetAssayData(seu_obj, assay = &quot;RNA&quot;, layer = &quot;counts&quot;) &gt; 0) &gt; 0 ] # Filter for significant genes in the current cluster sig_genes &lt;- all_markers_gene_cluster %&gt;% filter(cluster == 0 &amp; p_val_adj &lt; 0.05) %&gt;% # Filter for cluster 0 and adjusted p-value &lt; 0.05 pull(gene) # Extract gene names # Step 5: Run g:Profiler for pathway enrichment analysis pathway_results &lt;- gprofiler2::gost( query = sig_genes, ordered_query = TRUE, correction_method = &#39;fdr&#39;, custom_bg = background_genes, sources = c(&quot;GO&quot;, &quot;KEGG&quot;, &quot;REACTOME&quot;) ) # Prepare the data for plotting df_path &lt;- as_tibble(pathway_results$result) %&gt;% filter(term_size &lt; 3000, term_size &gt; 5) %&gt;% filter(!term_id %in% unlist(pathway_results$parents)) # Step 6: Plot top 5 results per database df_path %&gt;% group_by(source) %&gt;% slice_min(p_value, n = 5, with_ties = TRUE) %&gt;% ungroup() %&gt;% ggplot(aes(x = reorder(term_name, -p_value), y = -log10(p_value), fill = source)) + geom_bar(stat = &#39;identity&#39;, position = position_identity()) + coord_flip() + theme_bw() + labs(x = &quot;&quot;) + facet_grid(source ~ ., space = &#39;free&#39;, scales = &#39;free&#39;) + theme(legend.position = &#39;none&#39;, axis.text.y = element_text(angle = 0, size = 8)) + # Rotate and adjust y-axis text size ggtitle(paste(&quot;Pathway Enrichment for cluster 0&quot;)) # Add title with cluster name Based on the enriched terms, we can confidently conclude that the cell type is neuronal. Both the KEGG and the GO:MF terms support the hypothesis that the cells in cluster 0 have glutamatergic synapses. This analysis can be done on all the clusters in the Seurat object. We can now change the Mature neurons label to Glutamatergic neurons and plot the updated UMAP. Code ## Change the names of ScType DF to Glutatertergic neurons in metadat seu_obj@meta.data$sctype_db &lt;- gsub(&quot;Mature neurons&quot;, &quot;Glutamatergic neurons&quot;, seu_obj@meta.data$sctype_db) DimPlot(seu_obj, group.by = &quot;sctype_db&quot;) | DimPlot(seu_obj, reduction =&quot;umap_iso&quot;, group.by = &quot;sctype_db&quot;) Cell type identification is an iterative process and often one of the most challenging aspects of single-cell analysis. For this example, we will assume that our combined approach, using automated cell type identification, differential expression (DE) analysis based on clusters and Gene set enrichment, provides a good indication of the cell types present in our data. It is possible to explore the radial glial cells in more detail as there are likely many subtypes. For the purposes of the tutorial we will leave this annoation as is. Based on this we have 5 main cell types. Radial glial cells (RG) Immature neurons Glutamatergic neurons GABAergic neuorns Myelinating Schwann cells We can use a very nice package called dittoSeq (https://bioconductor.org/packages/devel/bioc/vignettes/dittoSeq/inst/doc/dittoSeq.html) to Visualise scRNA seq data directly from a seurat object. We can plot the distrubtion of the 5 cell types in a few different ways using dittoBarPlot Code library(dittoSeq) dittoBarPlot(seu_obj, &quot;orig.ident&quot;, group.by = &quot;sctype_db&quot;, scale = &quot;count&quot;) | dittoBarPlot(seu_obj, &quot;sctype_db&quot;, group.by = &quot;orig.ident&quot;, scale = &quot;percent&quot;) 5.3 DE genes and isoforms based on annotaed cell types. With this foundation, we can refine our DE analysis by focusing on cell types rather than clusters. This step is critical in nearly all transcriptomic analyses, offering a wide range of possibilities for downstream investigations. A common downstream approach involves generating volcano plots to visualize DE genes and isoforms. performing gene set enrichment analysis, In the following sections, we will demonstrate how to perform these types of analyses and explore their potential applications. The code chunk below provides an example of how to execute these analyses: Code #Set identities based on cell type Idents(seu_obj) &lt;- &quot;sctype_db&quot; all_markers_gene_celltype &lt;- FindAllMarkers( object = seu_obj, assay = &quot;RNA&quot;, group.by = &quot;sctype_db&quot;, # Replace with your metadata column name logfc.threshold = 0.5, min.pct = 0.20, only.pos = FALSE # changed this to false to get negatively DE genes to ) all_markers_iso_celltype &lt;- FindAllMarkers( object = seu_obj, assay = &quot;iso&quot;, group.by = &quot;sctype_db&quot;, # Replace with your metadata column name logfc.threshold = 0.5, min.pct = 0.20, only.pos = FALSE # changed this to false to get negatively DE genes to ) #save the list of DE genes write.csv(all_markers_gene_celltype, &quot;./output_files/DE/all_markers_one_gene_celltype.csv&quot;) write.csv(all_markers_iso_celltype, &quot;./output_files/DE/all_markers_one_iso_celltype.csv&quot;) A basic way of exploring this data is to plot these markers on a heatmap. Seurat has a nice function to do so. Let us plot the top 5 marker gene and isofroms in each cell type Code all_markers_gene_celltype %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% slice_head(n = 5) %&gt;% ungroup() -&gt; G_top5 DoHeatmap(seu_obj, features = G_top5$gene, assay = &quot;RNA&quot;, size = 3) + NoLegend() Code all_markers_iso_celltype %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% slice_head(n = 5) %&gt;% ungroup() -&gt; I_top5 DoHeatmap(seu_obj, features = I_top5$gene, assay = &quot;iso&quot;, size = 3) + NoLegend() Personally i find the same plots generated by dittoHeatmap much nicer. The function can also take a list of genes or isofroms of interest. Just remember to set the default assay accordingly. Code #list_of_genes &lt;- c(&quot;VIM&quot;, &quot;MAPT&quot;, &quot;KLC1&quot;, &quot;RBFOX1&quot;, &quot;RBFOX3&quot;) DefaultAssay(seu_obj) &lt;- &quot;RNA&quot; dittoHeatmap(seu_obj, head(G_top5$gene, 25), scaled.to.max = FALSE, complex = FALSE, heatmap.colors.max.scaled = FALSE, annot.by = c(&quot;sctype_db&quot;)) Code DefaultAssay(seu_obj) &lt;- &quot;iso&quot; dittoHeatmap(seu_obj, head(I_top5$gene, 25), scaled.to.max = FALSE, complex = FALSE, heatmap.colors.max.scaled = FALSE, annot.by = c(&quot;sctype_db&quot;)) 5.4 Volcano plots 5.4.1 FIndAllMarkers DE Next we can explore this data by generating some volcano plots. This analysis can be useful to identify genes and isoforms that are DE and also have large fold changes. Often these types of features are the interesting for further analysis. This can be done for any of the cell types defined in our object. For the sake of brevity we will look a the Glutamatergic neurons. When plotting the volcano plots, we observe that many genes exhibit both statistically significant p-values (p &lt; 0.05) and log2 fold changes -2&lt; or &gt;2. To highlight key findings, we have labeled some glutamatergic marker genes, demonstrating that the genes we expect to be upregulated in this cell type are indeed showing the expected pattern. Additionally, we have labeled VIM, a marker of radial glial and projenitor cells. As anticipated, VIM expression is downregulated in these neurons, which aligns with our expectations. Code library(EnhancedVolcano) #filter for the cell type of interest glut_DE_iso &lt;- dplyr::filter(all_markers_iso_celltype, cluster == &quot;Glutamatergic neurons&quot;) glut_DE_gene &lt;- dplyr::filter(all_markers_gene_celltype, cluster == &quot;Glutamatergic neurons&quot;) #we can plot our colcano plot EnhancedVolcano(glut_DE_gene, lab=glut_DE_gene$gene, x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, pCutoff=0.05, FCcutoff=2, boxedLabels = TRUE, drawConnectors = TRUE, selectLab= c(&quot;SLC17A7&quot;,&quot;SLC17A6&quot;,&#39;GRIN1&#39;,&quot;GRIN2B&quot;,&#39;VIM&#39;), title = &quot;Volcano Plot of Differentially Expressed Genes \\n in the Glutamatergic Neurons&quot;) Interestingly our long read data allows us to perform the same analysis but at the isoform level. This can be hard to interpret as there are many more features to plot on the volcano plot. for the sake a clarity we have just labelled TBR1 isoforms. This code bellow will allow users to plot all the isofroms from a given gene on the Volaco plot making interpretation of the data a bit cleaner. Here just like in 3.1 (this is wrong just cheeking the citation works) we can see two different isoforms of the TBR1 gene showing regulation this cell type Code gene &lt;- &quot;TBR1&quot; plot_features_list &lt;- grep(paste0(&quot;(^|-|\\\\b)&quot;, gene, &quot;($|\\\\b)&quot;), features, value = TRUE) EnhancedVolcano(glut_DE_iso, lab=glut_DE_iso$gene, x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, pCutoff=0.05, FCcutoff=2, boxedLabels = TRUE, drawConnectors = TRUE, selectLab= plot_features_list, title = &quot;Volcano Plot of Differentially Expressed Isoforms \\n in the Glutamatergic Neurons&quot;) 5.4.2 FindMarkers DE Finding All Markers is just one type of differential expression (DE) analysis that can be performed. Seurat offers the FindAllMarkers function, which tests the cell type of interest against all other cells. While this approach is often sufficient for identifying marker genes, users may also want to test differences between two specific cell types. For instance, you might want to identify DE genes when comparing glutamatergic neurons to radial glial cells. Below, we demonstrate how to perform this type of analysis with the FindMarkers function. Code DefaultAssay(seu_obj) &lt;- &#39;RNA&#39; # difeine the gne assay as default glu_RG_gene &lt;- FindMarkers(seu_obj, ident.1 = &quot;Glutamatergic neurons&quot;, ident.2 = &quot;Radial glial cells&quot;, logfc.threshold = 0.5, min.pct = 0.02) DefaultAssay(seu_obj) &lt;- &#39;iso&#39; # difeine the gne assay as default glu_RG_iso &lt;- FindMarkers(seu_obj, ident.1 = &quot;Glutamatergic neurons&quot;, ident.2 = &quot;Radial glial cells&quot;, logfc.threshold = 0.5, min.pct = 0.02) #Volcano plots # to plot at gene level #EnhancedVolcano(glu_RG_gene, lab=rownames(glu_RG_gene), # x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, # #selectLab= &quot;VIM&quot;, # pCutoff=0.05, FCcutoff=2, # title = &quot;Volcano Plot of Differentially Expressed Gene \\n Glutamatergic Neurons vs Radial glial #Cells&quot;) #Volcano plots EnhancedVolcano(glu_RG_iso, lab=rownames(glu_RG_iso), x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, #selectLab= &quot;VIM&quot;, pCutoff=0.05, FCcutoff=2, title = &quot;Volcano Plot of Differentially Expressed Isoforms \\n Glutamatergic Neurons vs Radial glial Cells&quot;) The volcano plot above is a useful tool for visualizing DE isoforms between two cell types. In this plot, red-labeled isoforms on the right-hand side indicate those that are unregulated in glutamatergic neurons compared to RG cells, while red dots on the left represent isoforms that are unregulated in radial glial cells compared to glutamatergic neurons. This analysis serves as an initial overview, and users can further explore the DE list (glu_RG_iso) to select specific isoforms of interest for more detailed analysis. "],["exploring-isoforms-of-interest.html", "Chapter 6 Exploring isoforms of interest 6.1 Isoforms expressed per gene 6.2 Top 10 Genes with Most Isoforms 6.3 Exploring MACF1 isoforms 6.4 Expression of MCAF1 isoforms Across Cell Types 6.5 Visualization of Isoform Structures", " Chapter 6 Exploring isoforms of interest One of the most powerful aspects of long-read single-cell sequencing is its ability to profile isoform-specific information at single-cell resolution. This capability opens up numerous avenues for analysis. In our lab we are interested in exploring the role of RNA isofroms in neuronal differentiation and there are many examples in the literate of isofroms regulating this process. We will cover some very general analysis with this focus in mind. 6.1 Isoforms expressed per gene With long-read single-cell data, we have the ability to analyze all the isoforms expressed by a given gene. In our data we can see that most genes express more than one isoform. Code #lets aggeragte the expresstion data by cell type counts &lt;- AggregateExpression( seu_obj, assays = &quot;iso&quot;, return.seurat = FALSE, group.by = &quot;sctype_db&quot; ) as.data.frame(counts) -&gt; df row.names(df) -&gt; df$gene #split transcript ids into gene and transcript id pseudobulk_data &lt;- df %&gt;% separate(gene, into = c(&quot;transcript_id&quot;, &quot;gene_id&quot;), sep = &quot;-&quot;, extra = &quot;merge&quot;) #df$transcript_id &lt;- sub(&quot;\\\\..*&quot;, &quot;&quot;, df$transcript_id) # 2. Count the number of isoforms per gene isoform_count_per_gene &lt;- pseudobulk_data %&gt;% group_by(gene_id) %&gt;% summarise(n_isoforms = n_distinct(transcript_id)) # 3. count isforms per category isoform_count_per_gene &lt;- isoform_count_per_gene %&gt;% mutate(isoform_category = case_when( n_isoforms == 1 ~ &quot;1&quot;, n_isoforms &gt;= 2 &amp; n_isoforms &lt;= 3 ~ &quot;2-3&quot;, n_isoforms &gt;= 4 &amp; n_isoforms &lt;= 5 ~ &quot;4-5&quot;, n_isoforms &gt;= 6 ~ &quot;6+&quot; )) # 4. Calculate the percentage of genes in each bin isoform_count_summary &lt;- isoform_count_per_gene %&gt;% dplyr::count(isoform_category) %&gt;% mutate(percent = (n / sum(n)) * 100) ggplot(isoform_count_summary, aes(x = isoform_category, y = percent)) + geom_bar(stat = &quot;identity&quot;, fill = &quot;lightblue&quot;, color = &quot;black&quot;) + labs(title = &quot;Number of Isoforms per Gene&quot;, x = &quot;Isoforms per Gene&quot;, y = &quot;Genes, %&quot;) + theme_minimal() + theme(legend.position = &quot;none&quot;, plot.title = element_text(hjust = 0.5)) 6.2 Top 10 Genes with Most Isoforms We can see that about 45% of genes express a single isoform, however there are some genes like MIR9-1HG that have alot of unique isofroms, 97 in fact. The top 10 genes with the most isofroms are listed bellow. Code # Genes ranked by the number of transcript isoforms detected across all samples gene_transcript_counts &lt;- pseudobulk_data %&gt;% group_by(gene_id) %&gt;% summarise(unique_transcripts = n_distinct(transcript_id)) %&gt;% arrange(desc(unique_transcripts)) # Select the top 10 genes based on unique transcript counts top10 &lt;- gene_transcript_counts %&gt;% top_n(10, unique_transcripts) top10 ## # A tibble: 10 × 2 ## gene_id unique_transcripts ## &lt;chr&gt; &lt;int&gt; ## 1 MIR9-1HG 97 ## 2 GAS5 69 ## 3 NUTM2A-AS1 50 ## 4 SNHG1 50 ## 5 FRG1HP 43 ## 6 TMEM161B-DT 43 ## 7 SNHG29 42 ## 8 ENSG00000300022 41 ## 9 FAM66A 39 ## 10 SNHG14 38 We can also plot unique transcripts per gene on a log scale showing that the number of isofroms per gene varies across out data. Code # Plot ranked genes by unique &quot;BambuTx&quot; transcript count ggplot(gene_transcript_counts, aes(x = rank(desc(unique_transcripts)), y = unique_transcripts)) + geom_point(color = &quot;darkblue&quot;, size = 1) + # Points for each gene # Log scale for both axes scale_x_log10() + scale_y_log10() + # Title and labels labs( title = &quot;Unique Transcripts per Gene&quot;, x = &quot;Rank (log scale)&quot;, y = &quot;# Transcripts (log scale)&quot; ) + # Highlight and label the top 10 genes with gray background and black border around the text geom_label_repel( data = gene_transcript_counts %&gt;% filter(gene_id %in% top10$gene_id), aes(label = gene_id), fill = &quot;gray&quot;, # Gray background for the label color = &quot;black&quot;, # Black text color label.size = 0.25, # Border thickness around the label label.r = unit(0.15, &quot;lines&quot;), # Border radius (rounded corners) size = 3, box.padding = 0.2, max.overlaps = 14 ) + # Minimal theme and additional styling theme_minimal() + theme( plot.title = element_text(size = 14, face = &quot;bold&quot;, hjust = 0.5), # Centered title axis.text = element_text(size = 10, color = &quot;black&quot;), # Black axis tick labels axis.title = element_text(color = &quot;black&quot;), # Black axis titles panel.grid.minor = element_blank(), panel.border = element_rect(color = &quot;black&quot;, fill = NA, linewidth = 1) # Black border around the graph ) 6.3 Exploring MACF1 isoforms We are interested in isoforms that regulate neuronal differentiation, we can look at some genes of interest. Lets look at gene MACF1. This gene is know to…. [ref]. The gene seems to play some important role in neural migration which is not fully understood yet. First lets try and visualize the expression of these isofroms on a UMAP to see if we can uncover anything interesting. MACF1 has 35 expressed isofroms so lets only plot the top 12 most highly expressed. Code features &lt;- rownames(filt_seurat_object@assays$iso@features) # Define the gene of interest gene &lt;- &quot;MACF1&quot; # Access the data matrix for the &#39;iso&#39; assay expression_matrix &lt;- GetAssayData(filt_seurat_object, assay = &quot;iso&quot;, slot = &quot;data&quot;) # Filter features containing the gene name matching_features &lt;- grep(paste0(&quot;(^|-|\\\\b)&quot;, gene, &quot;($|\\\\b)&quot;), rownames(expression_matrix), value = TRUE) # Subset the expression matrix to include only the matching features subset_expression &lt;- expression_matrix[matching_features, , drop = FALSE] # Calculate the total expression for each matching feature total_expression &lt;- Matrix::rowSums(subset_expression) # Rank features by average expression top_features &lt;- names(sort(total_expression, decreasing = TRUE)) # Print the ranked features (optional) print(data.frame(Feature = top_features, Expression = total_expression[top_features])) ## Feature Expression ## ENST00000361689.7-MACF1 ENST00000361689.7-MACF1 143.862407 ## ENST00000289893.8-MACF1 ENST00000289893.8-MACF1 62.133601 ## ENST00000372925.6-MACF1 ENST00000372925.6-MACF1 45.932634 ## ENST00000372915.8-MACF1 ENST00000372915.8-MACF1 45.461522 ## ENST00000567887.5-MACF1 ENST00000567887.5-MACF1 45.092944 ## ENST00000686657.1-MACF1 ENST00000686657.1-MACF1 44.609476 ## ENST00000564288.6-MACF1 ENST00000564288.6-MACF1 40.689721 ## ENST00000524432.5-MACF1 ENST00000524432.5-MACF1 27.310250 ## ENST00000686687.1-MACF1 ENST00000686687.1-MACF1 19.939477 ## ENST00000497964.1-MACF1 ENST00000497964.1-MACF1 17.945311 ## ENST00000530275.3-MACF1 ENST00000530275.3-MACF1 16.728830 ## ENST00000691623.1-MACF1 ENST00000691623.1-MACF1 14.286232 ## ENST00000602528.2-MACF1 ENST00000602528.2-MACF1 13.942571 ## ENST00000687271.1-MACF1 ENST00000687271.1-MACF1 12.934634 ## ENST00000476350.1-MACF1 ENST00000476350.1-MACF1 12.210176 ## ENST00000496804.5-MACF1 ENST00000496804.5-MACF1 12.181141 ## ENST00000686067.1-MACF1 ENST00000686067.1-MACF1 10.238947 ## ENST00000690080.1-MACF1 ENST00000690080.1-MACF1 8.279051 ## ENST00000497807.1-MACF1 ENST00000497807.1-MACF1 8.021857 ## ENST00000693209.1-MACF1 ENST00000693209.1-MACF1 7.429056 ## ENST00000693392.1-MACF1 ENST00000693392.1-MACF1 7.317640 ## ENST00000472385.2-MACF1 ENST00000472385.2-MACF1 7.075353 ## ENST00000602421.5-MACF1 ENST00000602421.5-MACF1 6.698620 ## ENST00000686260.1-MACF1 ENST00000686260.1-MACF1 6.297806 ## ENST00000688426.1-MACF1 ENST00000688426.1-MACF1 6.232290 ## ENST00000687997.1-MACF1 ENST00000687997.1-MACF1 6.056226 ## ENST00000690939.1-MACF1 ENST00000690939.1-MACF1 5.445340 ## ENST00000683517.1-MACF1 ENST00000683517.1-MACF1 3.526815 ## ENST00000442046.5-MACF1 ENST00000442046.5-MACF1 3.018726 ## ENST00000689911.1-MACF1 ENST00000689911.1-MACF1 2.657853 ## ENST00000484793.5-MACF1 ENST00000484793.5-MACF1 2.181164 ## ENST00000467673.5-MACF1 ENST00000467673.5-MACF1 2.131094 ## ENST00000686941.1-MACF1 ENST00000686941.1-MACF1 1.058887 ## ENST00000672812.1-MACF1 ENST00000672812.1-MACF1 1.055652 ## ENST00000528611.1-MACF1 ENST00000528611.1-MACF1 0.401423 Code options(repr.plot.width=12, repr.plot.height=12) # Plot the top 16 features in descending order of their average expression plots &lt;- FeaturePlot( filt_seurat_object, features = head(top_features, 12), reduction = &quot;umap&quot;, order = TRUE, # Ensures higher-expressing cells are plotted on top pt.size = 1) # Adjust title size for each plot plots &lt;- lapply(plots, function(plot) { plot + theme(plot.title = element_text(size = 8)) }) # Combine the adjusted plots CombinePlots(plots = plots, ncol = 3) 6.4 Expression of MCAF1 isoforms Across Cell Types Lets look at isofroms ENST00000564288.6, ENST00000361689.7, ENST00000289893.8 and ENST00000524432.5 in some more detail and plot the normalized expression of these isoforms across each cell type. We can see that the expression of ENST00000524432.5 shows a cell type specific profile. Code features_MACF1 &lt;- c(&quot;ENST00000564288.6-MACF1&quot;, # cononical &quot;ENST00000361689.7-MACF1&quot;, # most cell types &quot;ENST00000289893.8-MACF1&quot;, # msot cell types &quot;ENST00000524432.5-MACF1&quot;) # radial glia VlnPlot(seu_obj, features = features_MACF1, ncol = 2) We can also show this enrichment with a dotplot. Code dittoDotPlot(seu_obj, vars = features_MACF1, group.by = &quot;sctype_db&quot;, scale = FALSE) lets look at our DE results comparing Glutamatergic neurons and Radial glia cells that we calcualted in the previous chapter and filter for significant MCAF1 isoforms. If we plot these features on a Volcano plot we see isoform ENST00000524432.5 is enriched in radial glia cells. In fact its enrichment compared to Glutamatergic neurons is pretty high with a Log2fold change of 4.16. Code glu_RG_iso %&gt;% rownames_to_column(&quot;isoform&quot;) %&gt;% filter(grepl(&quot;MACF1&quot;, isoform)) %&gt;% filter(p_val_adj &lt; 0.5) ## isoform p_val avg_log2FC pct.1 pct.2 p_val_adj ## 1 ENST00000524432.5-MACF1 1.025842e-10 -4.163237 0.011 0.384 6.539231e-06 Code EnhancedVolcano(glu_RG_iso, lab=rownames(glu_RG_iso), x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, #selectLab= &quot;VIM&quot;, pCutoff=0.05, FCcutoff=2, selectLab = &quot;ENST00000524432.5-MACF1&quot;, boxedLabels = TRUE, drawConnectors = TRUE, title = &quot;ENST00000524432.5-MACF1 is upregulated \\n in Radial glial Cells compared to Glutamatergic Neurons&quot;) 6.5 Visualization of Isoform Structures Now that we know some MCAF1 isoforms expression is significantly different in these two cell populations it may be of interest to visualize the isoform structures. This analysis will help us explore the similarities and differences between our isoforms of interest. There are many visualization options available to us and many of these are available in R. In fact FLAMES has its own visualization function FLAMES::plot_isoform_reduced_dim. This function is designed to work on single cell experiment object and not Seurat object. Although it is possible to switch between these formats, for the purpose of this tutorial we want to keep file conversations to a minimum to keep the analysis simple. We instead recommend using IsoViz (Wan et al., 2024), which was developed in the Clark Lab. The tool is a web application specifically designed for visualizing isoform structures. This visualization can provide valuable insights into the potential functions of different isoforms. First lets prepare the count data that we will load into Isoviz1 Code #extract some isoform expression data to visualize in isoviz #use pseudobulk counts we from above row.names(df) &lt;- NULL df$gene_id &lt;- NULL write.csv(df, &quot;output_files/Pseudobulk_exp.csv&quot;, row.names = FALSE) To use IsoViz click on the following link https://isomix.org/isovis/ and uplaod the isofrom_annotated.gtf file located in the FLAMES output dir and Pseudobulk_exp.csv generated above. For more detail on how to use Isoviz click the ‘IsoViz tutorial’ button or read the publication. Embedded bellow is the figure generated by Isoviz2. Here we and visualizing our 4 isofroms of interest. We can see MCAF1 is a very complex gene with many exons, a variety of alternative transcription start sites. Structural visualization aids in identifying critical variations such as alternative splicing events, unique protein-coding regions, and functional domains. Code knitr::include_graphics(&quot;images/IsoVis_ENSG00000127603.png&quot;) Figure 6.1: IsoViz visualization of 4 MACF1 isoforms. Our pseudobulk expression data clearly demonstrates that ENST00000524432.5 is predominantly expressed in radial glia cells. This isoform is particularly interesting, as it is significantly shorter than others and lacks many of the protein domains present in ENST00000564288.6 (the canonical isoform). Notably, all four isoforms exhibit different transcription start sites (TSS), suggesting that TSS variation may be linked to cell-type-specific expression or distinct proteaforms For example, ENST00000289893.8 shows comparably high expression levels across most cell types. However, a deeper exploration of this isoform reveals that it does not produce a functional protein. This is evident from examining the Ensembl data, accessible via the isoform hyperlink, where we can see that no open reading frames (ORFs) are associated with this transcript. There are lots of additional analysis that could be performed to further explore the function of our MCAF1 isofroms, these include domain enrichment analysis and protein folding to name a few. Please be careful when interpreting pseudubulk expression data. Although the data can give you some indication of relative expression across cell types, this numbers can be affected by the number of cells in each cluster.↩︎ When Viewing this data in the web browser users will have more functionality. This includes a zoom function, looking at protein domains and rearranging isoform tracks and known visualizing open reading frames.↩︎ "],["isoform-classification.html", "Chapter 7 Isoform Classification 7.1 Classification with SQANTI 7.2 Cell type specific isoforms", " Chapter 7 Isoform Classification 7.1 Classification with SQANTI In the previous Chapter we looked at some genes of interst like MCAF1 and some of the isoforms related to this gene. As you can see MCAF1 is a highly complex gene with many exons, varied Transcription strat sites and many splice junctions. Evaluating this information manually for each isoform is complex and time consuming. A tool that that is very useful here is SQANTI3 (Pardo-Palacios et al., 2024) which will categorize our isoforms3 and determine whether they are coding or non-coding. If you install SQANTI3 and run the following command in your FLAMES output folder you will generate a classifications.txt file. This output file is located in the data folder on the github page. SQANTI can also generate an HTML report with lots of figures summarizing your isoforms which can be very helpful. We will do something similar but instead plot this information stratified by cell type. Code GTF=&quot;gencode.v47.annotation.gtf&quot; genome=&quot;genome.fa&quot; #filter gtf file to remove annoatiuon of unknown strands awk &#39;$7 == &quot;+&quot; || $7 == &quot;-&quot;&#39; isoform_annotated.gtf &gt; remove_unknownstrand.gtf #run SQANTIpython3 #you may need need to activate a conda enviroment SQANTI3-5.2.1/sqanti3_qc.py remove_unknownstrand.gtf ${GTF} ${genome} If we examine the classifications file, we can see that each isoform in our GTF file has been categorized based on its structural characteristics, coding potential, and additional attributes. Code SQANTI &lt;- read.csv(&quot;data/remove_unknownstrand_classification.txt&quot;, sep =&#39;\\t&#39;) #SQANTI$isoform &lt;- sub(&quot;\\\\..*&quot;, &quot;&quot;, SQANTI$isoform) # remove numbers after . head(SQANTI, 3) ## isoform chrom strand length exons structural_category associated_gene associated_transcript ref_length ref_exons diff_to_TSS diff_to_TTS ## 1 BambuTx1 chr1 + 2381 3 novel_in_catalog ENSG00000294260.1 novel 1694 2 NA NA ## 2 BambuTx2 chr1 - 595 2 antisense novelGene_ENSG00000302070.1_AS novel NA NA NA NA ## 3 ENST00000003583.12 chr1 - 2544 8 full-splice_match ENSG00000001460.18 ENST00000003583.12 2544 8 0 0 ## diff_to_gene_TSS diff_to_gene_TTS subcategory RTS_stage all_canonical min_sample_cov min_cov min_cov_pos sd_cov FL n_indels n_indels_junc bite ## 1 -2481 -17 combination_of_known_splicesites FALSE canonical NA NA NA NA NA NA NA FALSE ## 2 NA NA multi-exon FALSE canonical NA NA NA NA NA NA NA FALSE ## 3 0 0 reference_match FALSE canonical NA NA NA NA NA NA NA FALSE ## iso_exp gene_exp ratio_exp FSM_class coding ORF_length CDS_length CDS_start CDS_end CDS_genomic_start CDS_genomic_end predicted_NMD perc_A_downstream_TTS ## 1 NA NA NA C non_coding NA NA NA NA NA NA NA 75 ## 2 NA NA NA A non_coding NA NA NA NA NA NA NA 95 ## 3 NA NA NA C coding 122 369 1009 1377 24358540 24358172 FALSE 15 ## seq_A_downstream_TTS dist_to_CAGE_peak within_CAGE_peak dist_to_polyA_site within_polyA_site polyA_motif polyA_dist polyA_motif_found ## 1 TAAAAAAAAAAAATAAGTGA NA NA NA NA NA NA NA ## 2 AAAAAAAAAAAAAAGAAAAA NA NA NA NA NA NA NA ## 3 TATTGAGCTTTTGGGTACCC NA NA NA NA NA NA NA ## ORF_seq ratio_TSS ## 1 &lt;NA&gt; NA ## 2 &lt;NA&gt; NA ## 3 MSHKVKENSSHQPTLPSVPRTFLRRRPIMSVAADNLGGGSTTLAWHPSRTAAIAFVLSWRHCSLETSPQPHRLQWLPEQKGGVDRAPWLLPHAPIQAAFRHDSLPQTEGTPEAQTSRRISPP NA There is a lots information one can extract from the classifications.txt file. to get a more complete picture of the isoforms in the sample Lets plot some of this information. Code #we can use the pseudobulk_data counts calculated previously # Select cell type columns and gather into long format long_data &lt;- pseudobulk_data %&gt;% pivot_longer( cols = starts_with(&quot;iso.&quot;), names_to = &quot;cell_type&quot;, values_to = &quot;expression&quot; ) # Filter for non-zero expression to identify genes and isoforms expressed in each cell type filtered_data &lt;- long_data %&gt;% filter(expression &gt; 0) %&gt;% dplyr::select(cell_type, transcript_id, gene_id) %&gt;% distinct() # Calculate unique gene and isoform counts for each cell type cell_type_summary &lt;- filtered_data %&gt;% group_by(cell_type) %&gt;% summarise( num_genes = n_distinct(gene_id), num_isoforms = n_distinct(transcript_id) ) %&gt;% pivot_longer(cols = c(num_genes, num_isoforms), names_to = &quot;Category&quot;, values_to = &quot;Count&quot;) # Plot the data p1 &lt;- ggplot(cell_type_summary, aes(x = cell_type, y = Count, fill = Category)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;, color = &quot;black&quot;, width = 0.8) + theme_minimal() + labs(title = &quot;Number of genes and isoforms \\n per cell type&quot;, x = &quot;Cell Type&quot;, y = &quot;Count&quot;) + theme( plot.title = element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), legend.title = element_blank() ) # plot the structural category per cell type merged_data &lt;- merge(pseudobulk_data, SQANTI, by.x = &quot;transcript_id&quot;, by.y = &quot;isoform&quot;, all.x = TRUE) # Pivot pseudobulk data to long format for cell types long_data &lt;- merged_data %&gt;% pivot_longer( cols = starts_with(&quot;iso.&quot;), names_to = &quot;cell_type&quot;, values_to = &quot;expression&quot; ) # Generate outr new df thatw e can use for plotting attributes deffiend by cell type filtered_data &lt;- long_data %&gt;% filter(expression &gt; 0) %&gt;% distinct() # Calculate unique counts of genes and isoforms per structural category and cell type category_summary &lt;- filtered_data %&gt;% group_by(cell_type, structural_category, subcategory, coding) %&gt;% summarise( num_genes = n_distinct(gene_id), num_isoforms = n_distinct(transcript_id), .groups = &quot;drop&quot; ) # Plot number of isoforms per structural category for each cell type p2 &lt;- ggplot(category_summary, aes(x = cell_type, y = num_isoforms, fill = structural_category)) + geom_bar(stat = &quot;identity&quot;, position = &quot;stack&quot;, width = 0.8) + theme_minimal() + labs( title = &quot;Isoforms by structural category \\n across cell types&quot;, x = &quot;Cell Type&quot;, y = &quot;Number of Isoforms&quot;, fill = &quot;Structural Category&quot; ) + theme( plot.title = element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), legend.title = element_text(size = 14), legend.text = element_text(size = 12) ) p3 &lt;- ggplot(category_summary, aes(x = cell_type, y = num_isoforms, fill = subcategory)) + geom_bar(stat = &quot;identity&quot;, position = &quot;stack&quot;, width = 0.8) + theme_minimal() + labs( title = &quot;Isoforms by structural subcategory \\n across cell types&quot;, x = &quot;Cell Type&quot;, y = &quot;Number of Isoforms&quot;, fill = &quot;subcategory&quot; ) + theme( plot.title = element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), legend.title = element_text(size = 14), legend.text = element_text(size = 12) ) p4 &lt;- ggplot(category_summary, aes(x = cell_type, y = num_isoforms, fill = coding)) + geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, width = 0.8) + theme_minimal() + labs( title = &quot;Proportion of coding isoforms \\n across cell types&quot;, x = &quot;Cell Type&quot;, y = &quot;Proportion of Isoforms&quot;, fill = &quot;Structural Category&quot; ) + scale_y_continuous(labels = scales::percent) + # This will show y-axis as percentages theme( plot.title = element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), legend.title = element_text(size = 14), legend.text = element_text(size = 12) ) #Plots cowplot::plot_grid(p1, p2, p3, p4, ncol = 2) 7.2 Cell type specific isoforms We can also look at isoforms that are unique to each Cell type. We define unique as an isofroms that has 5 or more counts in one cell type and ≤ 1 count in all other cell types. Users can adjust the thresholds mentioned bellow4. Code # Filter the data based on the expression cutoff # Set expression cutoff threshold expression_cutoff &lt;- 5 max_expression_in_all_other_cells_types = 1 # Filter isoforms based on the new criteria exclusive_isoforms &lt;- long_data %&gt;% group_by(transcript_id) %&gt;% filter( # Only one cell type where expression &gt; cutoff sum(expression &gt; expression_cutoff) &lt;= 1, # Ensure all other cell types have 0 expression all(expression &lt; max_expression_in_all_other_cells_types | expression &gt; expression_cutoff) ) %&gt;% ungroup() # Count the unique isoforms per cell type # Adjust counting logic exclusive_isoforms_count &lt;- exclusive_isoforms %&gt;% group_by(cell_type) %&gt;% summarise( unique_isoforms = sum(expression &gt; expression_cutoff) # Count only isoforms with valid expression ) %&gt;% ungroup() # Plot the results ggplot(exclusive_isoforms_count, aes(x = cell_type, y = unique_isoforms, fill = cell_type)) + geom_bar(stat = &quot;identity&quot;, color = &quot;black&quot;, width = 0.8) + theme_minimal() + labs( title = &quot;Number of isoforms unique \\n to each cell type&quot;, x = &quot;Cell Type&quot;, y = &quot;Number of Unique Isoforms&quot; ) + theme( plot.title = element_text(size = 20, face = &quot;bold&quot;, hjust = 0.5), axis.title.x = element_text(size = 14), axis.title.y = element_text(size = 14), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), legend.title = element_blank() ) These cell type specific isoforms may be particularly interesting to study further, as they likely play important roles in differentiation and cell function. We could extract these isoforms for further analysis. Lets use another helpful resource to explore these cell type specific isofroms. We can use the BioMart (Smedley et al., 2009) package to get some more metadata about each isoform. There is lots of data that can be extracted from BioMart. This is just a simple example of what can be done with this cell type specif data. Code library(&quot;biomaRt&quot;) exclusive_isoforms_uniq &lt;- exclusive_isoforms %&gt;% filter(expression &gt;= max_expression_in_all_other_cells_types) %&gt;% arrange(desc(expression)) exclusive_isoforms_uniq$transcript_id &lt;- sub(&quot;\\\\..*&quot;, &quot;&quot;, exclusive_isoforms_uniq$transcript_id) # Retrieve gene biotype from Ensembl mart &lt;- useMart(biomart = &quot;ensembl&quot;, dataset = &quot;hsapiens_gene_ensembl&quot;) biotype_info_transcript &lt;- getBM(attributes = c(&quot;ensembl_transcript_id&quot;, &quot;transcript_is_canonical&quot;, &#39;transcript_biotype&#39;, &#39;transcript_length&#39;), filters = &#39;ensembl_transcript_id&#39;, values = exclusive_isoforms_uniq$transcript_id, mart = mart) #merge excluive isofroms and biomart data togehter merged_biomart_data &lt;- merge(exclusive_isoforms_uniq, biotype_info_transcript, by.x = &quot;transcript_id&quot;, by.y = &quot;ensembl_transcript_id&quot;, all.x = TRUE) # Prepare the summary data category_summary &lt;- merged_biomart_data %&gt;% group_by(cell_type, transcript_biotype) %&gt;% summarise(num_isoforms = n(), .groups = &quot;drop&quot;) %&gt;% group_by(cell_type) %&gt;% mutate(proportion = num_isoforms / sum(num_isoforms)) %&gt;% ungroup() # Ensure consistent factor order for cell_type and transcript_biotype # Ensure consistent factor order for cell_type and transcript_biotype category_summary &lt;- category_summary %&gt;% mutate( cell_type = factor(cell_type, levels = unique(cell_type)), transcript_biotype = factor(transcript_biotype, levels = c( &quot;protein_coding&quot;, &quot;lncRNA&quot;, &quot;non_stop_decay&quot;, &quot;TEC&quot;, &quot;nonsense_mediated_decay&quot;, &quot;protein_coding_CDS_not_defined&quot;, &quot;retained_intron&quot;, &quot;processed_pseudogene&quot;, &quot;snoRNA&quot;, &quot;transcribed_processed_pseudogene&quot; )) ) # Create the plot p5 &lt;- ggplot(category_summary, aes(x = cell_type, y = proportion, fill = transcript_biotype)) + geom_bar(stat = &quot;identity&quot;, position = &quot;fill&quot;, width = 0.8) + geom_text(aes(label = scales::percent(proportion, accuracy = 0.1)), position = position_fill(vjust = 0.5), size = 2) + theme_minimal() + labs( title = &quot;BioMart Structural Categories \\n cell specific isoforms&quot;, x = &quot;Cell Type&quot;, y = &quot;Proportion of Isoforms&quot;, fill = &quot;BioMart structual Category&quot; ) + scale_y_continuous(labels = scales::percent) + theme( plot.title = element_text(size = 18, face = &quot;bold&quot;, hjust = 0.5), axis.title.x = element_text(size = 12), axis.title.y = element_text(size = 12), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), legend.title = element_text(size = 10), legend.text = element_text(size = 6) ) p6 &lt;- ggplot(merged_biomart_data, aes(x = cell_type, y = transcript_length, fill = cell_type)) + geom_violin(trim = TRUE, alpha = 0.6) + # Use violin plot for distribution geom_boxplot(width = 0.1, outlier.size = 0.5, alpha = 0.8) + # Add boxplot for summary statistics theme_minimal() + labs( title = &quot;Transcript length distribution \\n across cell types&quot;, x = &quot;Cell Type&quot;, y = &quot;Transcript Length (nt)&quot;, fill = &quot;Cell Type&quot; ) + theme( plot.title = element_text(size = 18, face = &quot;bold&quot;, hjust = 0.5), axis.title.x = element_text(size = 10), axis.title.y = element_text(size = 10), axis.text.x = element_text(size = 12, angle = 45, hjust = 1), axis.text.y = element_text(size = 12), legend.position = &quot;none&quot; ) cowplot::plot_grid(p5, p6, ncol = 1) For more detail about the classification system see the SQANTI publication.↩︎ It is essential to keep in mind that cell type classification, sequencing depth, and the number of cells in each cluster can significantly impact the results, especially in cases where isoforms are expressed at very low levels.↩︎ "],["novel-isoforms.html", "Chapter 8 Novel isoforms 8.1 Find all the genes that express at least 1 novel isoform 8.2 Visualizing OAZ2 novel isoform 8.3 Functional impacts of novel isoforms", " Chapter 8 Novel isoforms With long read sequencing its possible to explore both known and novel isofroms. Novel isoform can be interesting feature to explore and here we will provide some simple analysis that one can use to extract novel isoforms and explore them in some more detail. Although the bar plots above show that the vast majority of isofroms are full-splice-matches i.e they match the reference GTF there are a few we could extract. 8.1 Find all the genes that express at least 1 novel isoform First lets get a list of genes with at least one novel isoform Code # Find the genes that express at least one novel isoform and save them to a list # Convert row names to a data frame isoform_ids &lt;- as.data.frame(row.names(seu_obj@assays$iso$counts)) colnames(isoform_ids) &lt;- &quot;IDs&quot; #Add in total expression isoform_ids$Total_Expression &lt;- rowSums(seu_obj@assays$iso$counts) # Filter rows where &#39;IDs&#39; contains the string &quot;Bambu&quot; isoform_ids &lt;- as.data.frame(isoform_ids[grepl(&quot;Bambu&quot;, isoform_ids$IDs), ]) # can comment this out if we want to do this for all isofroms # Separate the &#39;IDs&#39; column into two columns filtered_df &lt;- isoform_ids %&gt;% separate(IDs, into = c(&quot;transcript_id&quot;, &quot;gene_id&quot;), sep = &quot;-&quot;, extra = &quot;merge&quot;) isoform_counts &lt;- filtered_df %&gt;% group_by(gene_id) %&gt;% summarise( Isoform_Count = n(), Total_Expression = sum(Total_Expression) ) %&gt;% arrange(desc(Total_Expression)) # Print or return the filtered data frame print(isoform_counts) ## # A tibble: 31 × 3 ## gene_id Isoform_Count Total_Expression ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 OAZ2 1 396. ## 2 ENSG00000291214 1 159. ## 3 BambuGene6113 1 141. ## 4 ENSG00000305512 1 140. ## 5 BambuGene19505 1 139. ## 6 ENSG00000305069 1 132 ## 7 BambuGene18812 1 95.8 ## 8 ZMAT5 1 76.0 ## 9 ENSG00000295459 1 68.7 ## 10 ENSG00000231748 1 62 ## # ℹ 21 more rows In this table we can see that we have a total of 31 novel isofroms. This number is smaller than we might expect but this is because Bambu (Chen et al., 2023) is quite conservative for single cell data and we haven’t sequenced these data very deeply. Users can change the sensitivity of Bambu when running FLAMES by setting the NDR parameter or using a different discovery method like stringtie2 (Kovaka et al., 2019). In the above table we have ordered the the genes that contain a novel isoform by total expression. OAZ2 is our top hit. We can look at the isoform structure using IsoViz as described in the section 6.5. Code knitr::include_graphics(&quot;images/IsoVis_ENSG00000180304.png&quot;) Figure 8.1: IsoViz visualization of Novel OAZ2 isoform. 8.2 Visualizing OAZ2 novel isoform Visualizing OAZ2 reveals that the primary distinction between the novel isoform and the canonical isoform, OAZ2-201 seems to be a shorter 5’ UTR. This minor alteration at face value should not affect the canonical open reading frame (ORF). However, according to SQANTI, BambuTx25 is classified as a novel_in_catalog isoform, meaning it is an isoform not present in the reference GTF and SQANTI suggests that BambuTx25 is non-coding, which is quite surprising! Interestingly, SQANTI also indicates that the primary difference between BambuTx25 and the canonical isoforms lies in intron retention (Specified in the subcategory column). Code # Load necessary libraries SQANTI[grep(&#39;BambuTx25&#39;, SQANTI$isoform), ] ## isoform chrom strand length exons structural_category associated_gene associated_transcript ref_length ref_exons diff_to_TSS diff_to_TTS diff_to_gene_TSS ## 21835 BambuTx25 chr15 - 1870 5 novel_in_catalog ENSG00000180304.14 novel 1934 6 NA NA -2 ## diff_to_gene_TTS subcategory RTS_stage all_canonical min_sample_cov min_cov min_cov_pos sd_cov FL n_indels n_indels_junc bite iso_exp gene_exp ratio_exp ## 21835 -1 intron_retention FALSE canonical NA NA NA NA NA NA NA FALSE NA NA NA ## FSM_class coding ORF_length CDS_length CDS_start CDS_end CDS_genomic_start CDS_genomic_end predicted_NMD perc_A_downstream_TTS seq_A_downstream_TTS ## 21835 C non_coding NA NA NA NA NA NA NA 10 GTGGTTGGTCTATTCTTTAT ## dist_to_CAGE_peak within_CAGE_peak dist_to_polyA_site within_polyA_site polyA_motif polyA_dist polyA_motif_found ORF_seq ratio_TSS ## 21835 NA NA NA NA NA NA NA &lt;NA&gt; NA To better understand these SQANTI results lets zoom in on exon 2 of OAZ2. Here, we observe a small break within the exon. The novel BambuTx25 does not contain this break so perhaps this change affects the resulting amino acid sequence. Code knitr::include_graphics(&quot;images/IsoVis_ENSG00000180304_zoom.png&quot;) Figure 8.2: IsoViz visualization of exon 2 of OAZ2. 8.3 Functional impacts of novel isoforms There are many ways to investigate the translated sequence and compare the protein generated from conanocial isoform and the novel one. Simple approaches may involve extracting the fasta sequence and looking for the open reading frames (ORFs) in a online tool like ‘expasy translate’ which can be found here https://web.expasy.org/translate/. Bellow we have written a function that will take a list of isoforms from a gene and plot the ORFs as defined by the package ORFik5 (Tjeldnes et al., 2021). We will visualize these ORFS in Gviz (Hahne &amp; Ivanek, 2016) an R package for visualizing genomic features. This analysis will help us determine if the ORF in the transcript BambuTx25 has been impacted by the change in nucleotide sequence. Code # Global cache for TxDb txdb_cache &lt;- list() get_txdb &lt;- function(reference_gtf) { # Check if the TxDb for this file is already in cache if (!is.null(txdb_cache[[reference_gtf]])) { message(&quot;Using cached TxDb...&quot;) return(txdb_cache[[reference_gtf]]) } # Create TxDb and cache it message(&quot;Creating TxDb object from reference GTF. This may take time...&quot;) txdb &lt;- txdbmaker::makeTxDbFromGFF(reference_gtf) txdb_cache[[reference_gtf]] &lt;&lt;- txdb return(txdb) } plot_isoform_ORFs &lt;- function(reference_gtf, target_gtf, isoforms_of_interest, chromosome, plot_start, plot_end) { # Load genome reference genomedb &lt;- BSgenome.Hsapiens.UCSC.hg38 # Retrieve cached TxDb or create if not available txdb &lt;- get_txdb(reference_gtf) # Import and filter GTF for specific isoforms gtf_data &lt;- import(target_gtf) gtf_filtered &lt;- gtf_data[gtf_data$transcript_id %in% isoforms_of_interest] txdb_filtered &lt;- txdbmaker::makeTxDbFromGRanges(gtf_filtered) # Extract exons and convert to GRangesList txs &lt;- GenomicFeatures::exonsBy(txdb_filtered, by = c(&quot;tx&quot;, &quot;gene&quot;), use.names = TRUE) txs_grl &lt;- GRangesList(txs) # Extract transcript sequences and identify ORFs tx_seqs &lt;- extractTranscriptSeqs(genomedb, txs_grl) ORFs &lt;- findMapORFs(txs_grl, tx_seqs, groupByTx = FALSE, longestORF = FALSE, minimumLength = 30, startCodon = &quot;ATG&quot;, stopCodon = stopDefinition(1)) # Unlist and prepare ORF data for plotting ORFs_unlisted &lt;- unlist(ORFs) ORFs_unlisted$type &lt;- &quot;exon&quot; ORFs_unlisted$transcript &lt;- ORFs_unlisted$names ORFs_unlisted$transcript &lt;- paste0(ORFs_unlisted$transcript, &quot;_ORF&quot;) #could add in a filter for ORFs here # Define start and stop codons starts &lt;- startCodons(ORFs, is.sorted = TRUE) stops &lt;- stopCodons(ORFs, is.sorted = TRUE) # Visualization Tracks gtrack &lt;- GenomeAxisTrack() itrack &lt;- IdeogramTrack(genome = &quot;hg38&quot;, chromosome = chromosome) ref_track &lt;- GeneRegionTrack( range = txdb, name = &quot;gencodev47&quot;, genome = &quot;hg38&quot;, chromosome = chromosome, col = &quot;darkblue&quot;, fill = &quot;lightblue&quot;, arrowHead = FALSE ) input_track &lt;- GeneRegionTrack( range = txdb_filtered, name = &quot;Isoforms (Exons)&quot;, genome = &quot;hg38&quot;, chromosome = chromosome, col = &quot;darkgreen&quot;, fill = &quot;lightgreen&quot;, arrowHead = FALSE ) orf_track &lt;- GeneRegionTrack( ORFs_unlisted, genome = &quot;hg38&quot;, chromosome = unique(seqnames(ORFs_unlisted)), transcriptAnnotation = &quot;transcript&quot;, name = &quot;ORFs&quot;, col = &quot;grey&quot;, fill = &quot;grey&quot;, stacking = &quot;squish&quot;, ) starts_track &lt;- AnnotationTrack( range = starts, name = &quot;Starts&quot;, genome = &quot;hg38&quot;, chromosome = seqnames(txs_grl[[1]])[1], col = &quot;green&quot;, fill = &quot;green&quot;, shape = &quot;box&quot;, # Ensure no arrows by using box shape stacking = &quot;dense&quot; ) stops_track &lt;- AnnotationTrack( range = stops, name = &quot;Stops&quot;, genome = &quot;hg38&quot;, chromosome = seqnames(txs_grl[[1]])[1], col = &quot;red&quot;, fill = &quot;red&quot;, shape = &quot;box&quot;, # Ensure no arrows by using box shape stacking = &quot;dense&quot; ) # Plot tracks plotTracks(list(itrack, gtrack, ref_track, input_track, orf_track, stops_track, starts_track), from = plot_start, to = plot_end, transcriptAnnotation = &quot;transcript&quot;) } # Example usage plot_isoform_ORFs( reference_gtf = &quot;data/gencode.v47.annotation.gtf&quot;, target_gtf = &quot;data/FLAMES_out/isoform_annotated_unfiltered.gtf&quot;, isoforms_of_interest = c(&quot;ENST00000326005.10&quot;, &quot;BambuTx25&quot;), chromosome = &quot;chr15&quot;, plot_start = 64687015, plot_end = 64703412 ) Code plot_isoform_ORFs( reference_gtf = &quot;data/gencode.v47.annotation.gtf&quot;, target_gtf = &quot;data/FLAMES_out/isoform_annotated_unfiltered.gtf&quot;, isoforms_of_interest = c(&quot;ENST00000326005.10&quot;, &quot;BambuTx25&quot;), chromosome = &quot;chr15&quot;, plot_start = 64691416, plot_end = 64691685 ) Visualizing ORFs using the above code chunck shows that the BambuTx25_1_ORF is incomplete. The additional sequence (retained intron as specified by SQANTI) results in a premature stop codon shown in red which likely triggers nonsense-mediated decay (NMD). The canonical ENST00000326005.10_3_ORF is complete. We can examine additional genes from our list. For instance, ZMAT5 has a novel isoform that utilizes a different, known splice junction in the 5’ UTR. Using the function above to examine ORFs, we can see that the ORF is unchanged compared to the canonical isoform. This may suggest some import regulatory role in the 5’ UTR yet the protein remains unchanged. Code knitr::include_graphics(&quot;images/IsoVis_ENSG00000100319.png&quot;) Figure 8.3: IsoViz visualization of Novel ZMAT5 isoform. Code plot_isoform_ORFs( reference_gtf = &quot;../../../../resources/gencode.v47.annotation.gtf&quot;, target_gtf = &quot;/data/scratch/users/yairp/FLAMES_Day55/outs/isoform_annotated_unfiltered.gtf&quot;, isoforms_of_interest = c(&quot;BambuTx32&quot;, &quot;ENST00000344318.4&quot;), chromosome = &quot;chr22&quot;, plot_start = 29728956, plot_end = 29769011 ) ## Creating TxDb object from reference GTF. This may take time... ## Import genomic features from the file as a GRanges object ... OK ## Prepare the &#39;metadata&#39; data frame ... OK ## Make the TxDb object ... OK ORFs found by the package ORFik may need to be filtered based on length or position when analysising differnt genes or isoforms.↩︎ "],["multisample-analysis.html", "Chapter 9 Multisample analysis 9.1 Standard pre-processing and quality control 9.2 Multi-Sample integration", " Chapter 9 Multisample analysis The FLAMES pipeline supports the analysis of multiple samples simultaneously, allowing users to efficiently process complex experimental datasets. This is achieved using the sc_long_multisample_pipeline function. The output generated by this function is similar to the single-sample analysis outlined in previous chapters but offers additional capabilities when the experimental design includes sample replicates. To take full advantage of these features we need to perform sample integration to generate a single object that we can use to integrate isoform expression across our conditions. First standard preprocessing as described in Chapters 3 and 4 is required. After integration we can perform the following key analysis: Sample Integration: Combine multiple sample together and add isoform counts. Trajectory Analysis: Explore genes that change along pseudotime trajectories. Differential Expression Analysis: Identify differentially expressed isoforms across time points or sample conditions. Differential Transcript Usage (DTU) Analysis: Investigate changes in isoform proportions between conditions. Most preprocessing and QC steps remain the same. However, we will also demonstrate how to proceed directly from FLAMES output to initial QC without performing empty droplet removal or ambient RNA normalization. Although these steps are recommended, they may not always be necessary depending on the data. 9.0.1 Dataset Information For this analysis, we are using a dataset comprising eight samples spanning four time points from an excitatory neuronal differentiation protocol. The protocol is the same as the one used for the D55 sample in previous chapters but utilizes a different cell line. Two samples were collected from each of the following time points: Day -1 or Stem cells (STC) Day 25 (D25) Day 55 (D55) Day 80 (D80) This comprehensive dataset will allow us to explore temporal changes in gene and isoform expression throughout neuronal differentiation. 9.1 Standard pre-processing and quality control As before we will modify the count matrix for each sample so we use gene_symbol instead of ENSG id. The Data generated from this multi-sample experiment is quite large. This is especially the case with Oarfish isoform quantification as there are many more features to consider. This means much of the workflow bellow is time consuming and computationally intensive. Please keep this in mind when processing your samples. In the tutorial we provide code for the required steps but do not evaluate many of the sections bellow due to these computations constraints. The raw counts are available in the multisample data folder if users wish to run through the analysis. Code # convert Gene_id to gene symbol for all counts #run aloop to run this fucntion on all count files. # Directory with input files set.seed(1234) input_dir &lt;- &quot;./data/muti_sample/&quot; output_dir &lt;- &quot;./data/muti_sample/&quot; # List all CSV files in the input directory input_files &lt;- list.files(input_dir, pattern = &quot;\\\\count.csv$&quot;, full.names = TRUE) # Initialize an empty list to store data frames result_list &lt;- list() # Process each file in the directory total_files &lt;- length(input_files) # Total number of files for (i in seq_along(input_files)) { file_path &lt;- input_files[i] # Extract file name without extension file_name &lt;- tools::file_path_sans_ext(basename(file_path)) # Construct the output file name output_file &lt;- file.path(output_dir, paste0(file_name, &quot;_gene_symbol.csv&quot;)) # Show progress to the user message(sprintf(&quot;Processing file %d of %d: %s&quot;, i, total_files, file_name)) # Call the function with return_df = TRUE to store the result result_list[[file_name]] &lt;- convert_ENSGID_to_geneSymbol( gene_count_matrix_path = file_path, output_file = output_file, return_df = TRUE ) } 9.1.1 Define QC function We have developed a multisample QC function @ref(Multisample QC function) for processing count matrices and constructing filtered Seurat objects, following best practices outlined in the Seurat tutorial. This function includes steps to identify and remove doublets, as well as generate key diagnostic plots for data inspection. We encourage users to customize this function to fit their specific needs, such as applying additional filtering criteria. For the purposes of presenting concise and readable code we will apply the default filtering parameters to all 8 objects. If users wish to be more specific about filtering each sample independent this is possible and can be done by running the perform_qc_filtering function on each sample with desired parameters. Code # Define sample names sample_names &lt;- c(&quot;C1_STC&quot;, &quot;C4_STC&quot;, &quot;C2_Day25&quot;, &quot;C5_Day25&quot;, &quot;C2_Day55&quot;, &quot;C3_Day55&quot;, &quot;C3_Day80&quot;, &quot;C5_Day80&quot;) # Initialize a list to store UMAP objects umap_objects &lt;- list() # Start the PDF for output pdf(file = &quot;./output_files/mutli_sample/QC/multisample_QC.pdf&quot;, width = 10, height = 6) # Loop through each sample and apply the QC filtering function for (i in seq_along(sample_names)) { sample_name &lt;- sample_names[i] # Print progress message message(paste0(&quot;Processing sample &quot;, i, &quot; of &quot;, length(sample_names), &quot;: &quot;, sample_name)) # Perform QC filtering result &lt;- perform_qc_filtering( result_list[paste0(sample_name, &quot;_matched_reads_gene_count&quot;)], fig_name = sample_name, project = sample_name ) # Store the UMAP object from the result umap_objects[[sample_name]] &lt;- result[[1]] } # Close the PDF device dev.off() #save the object #saveRDS(umap_objects, file = &quot;./output_files/mutli_sample/umap_objects.rds&quot;) 9.2 Multi-Sample integration First we will merge the seurat objects together and then perform integration. There are many options for sample integration and Seurat provides many wrappers for these functions. Here we will Harmony (Korsunsky et al., 2019) for fast and effective integration. As these processes are time consuming we will load our saved objects. Code # intergrate samples #from the fucntion above pull the filtered seurat object merged_seurat &lt;- merge( umap_objects[[&quot;C1_STC&quot;]], y = list( umap_objects[[&quot;C4_STC&quot;]], umap_objects[[&quot;C2_Day25&quot;]], umap_objects[[&quot;C5_Day25&quot;]], umap_objects[[&quot;C2_Day55&quot;]], umap_objects[[&quot;C3_Day55&quot;]], umap_objects[[&quot;C3_Day80&quot;]], umap_objects[[&quot;C5_Day80&quot;]] ), add.cell.ids = c( &quot;C1_STC&quot;, &quot;C4_STC&quot;, &quot;C2_Day25&quot;, &quot;C5_Day25&quot;, &quot;C2_Day55&quot;, &quot;C3_Day55&quot;, &quot;C3_Day80&quot;, &quot;C5_Day80&quot; ), project = &quot;Multi-sample_tutorial&quot; ) # create a sample column merged_seurat$sample &lt;- rownames(merged_seurat@meta.data) ## split sample column to makw a batch col merged_seurat@meta.data &lt;- separate(merged_seurat@meta.data, col = &#39;sample&#39;, into = c(&#39;batch&#39;, &#39;Day&#39;, &#39;Barcode&#39;), sep = &#39;_&#39;) #check some QC metrics VlnPlot(merged_seurat, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3, group.by = &quot;Day&quot;) + plot_annotation(title = &quot;Vln plots grouped by Day&quot;) #can plot based on any metadat col #VlnPlot(merged_seurat, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3, group.by = &quot;orig.ident&quot;) # Number of cells per group table(merged_seurat$orig.ident) table(merged_seurat$Day) # Apply normal preprocessing steps to merged file merged_seurat &lt;- NormalizeData(object = merged_seurat) merged_seurat &lt;- FindVariableFeatures(object = merged_seurat) merged_seurat &lt;- ScaleData(object = merged_seurat) merged_seurat &lt;- RunPCA(object = merged_seurat) ElbowPlot(merged_seurat) merged_seurat &lt;- FindNeighbors(object = merged_seurat, dims = 1:16) merged_seurat &lt;- FindClusters(object = merged_seurat, resolution = 0.6) merged_seurat &lt;- RunUMAP(object = merged_seurat, dims = 1:30) ##save merged object #saveRDS(merged_seurat, file = &quot;./output_files/mutli_sample/merged_seurat.rds&quot;) Code readRDS(merged_seurat, file = &quot;./output_files/mutli_sample/merged_seurat.rds&quot;) ## An object of class Seurat ## 51176 features across 7216 samples within 2 assays ## Active assay: RNA (25588 features, 2000 variable features) ## 25 layers present: counts.C1_STC, counts.C4_STC, counts.C2_Day25, counts.C5_Day25, counts.C2_Day55, counts.C3_Day55, counts.C3_Day80, counts.C5_Day80, data.C1_STC, scale.data.C1_STC, data.C4_STC, scale.data.C4_STC, data.C2_Day25, scale.data.C2_Day25, data.C5_Day25, scale.data.C5_Day25, data.C2_Day55, scale.data.C2_Day55, data.C3_Day55, scale.data.C3_Day55, data.C3_Day80, scale.data.C3_Day80, data.C5_Day80, scale.data.C5_Day80, scale.data ## 1 other assay present: joined ## 2 dimensional reductions calculated: pca, umap Code #Lets plot the merged file. p1 &lt;- FeaturePlot(merged_seurat, reduction = &#39;umap&#39;, features = &#39;nCount_RNA&#39;) p2 &lt;- FeaturePlot(merged_seurat, reduction = &quot;umap&quot;, features = &#39;nFeature_RNA&#39;) p3 &lt;- DimPlot(merged_seurat, reduction = &#39;umap&#39;, group.by = &#39;Day&#39;) p4 &lt;- DimPlot(merged_seurat, reduction = &#39;umap&#39;, group.by = &#39;orig.ident&#39;) grid.arrange(p1, p2, p3, p4, ncol = 2) Code merged_seurat &lt;- JoinLayers(object = merged_seurat) merged_seurat[[&quot;RNA&quot;]] &lt;- split(merged_seurat[[&quot;RNA&quot;]], f = merged_seurat$orig.ident) ## Splitting &#39;counts&#39;, &#39;data&#39; layers. Not splitting &#39;scale.data.C1_STC&#39;, &#39;scale.data.C4_STC&#39;, &#39;scale.data.C2_Day25&#39;, &#39;scale.data.C5_Day25&#39;, &#39;scale.data.C2_Day55&#39;, &#39;scale.data.C3_Day55&#39;, &#39;scale.data.C3_Day80&#39;, &#39;scale.data.C5_Day80&#39;, &#39;scale.data&#39;. If you would like to split other layers, set in `layers` argument. Code #perform intergation with Harmony obj &lt;- IntegrateLayers(object = merged_seurat, method = HarmonyIntegration, orig.reduction = &quot;pca&quot;, new.reduction = &#39;integrated.harm&#39;, verbose = FALSE ) ## Warning in harmony::HarmonyMatrix(data_mat = Embeddings(object = orig), : HarmonyMatrix is deprecated and will be removed in the future from the API in the future Code obj &lt;- FindNeighbors(obj, reduction=&quot;integrated.harm&quot;) ## Computing nearest neighbor graph ## Computing SNN Code obj &lt;- FindClusters(obj, resolution=0.6, cluster.name=&quot;harm_cluster&quot;) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 7216 ## Number of edges: 233901 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.9109 ## Number of communities: 12 ## Elapsed time: 0 seconds Code obj &lt;- RunUMAP(obj, reduction=&quot;integrated.harm&quot;, dims=1:20, reduction.name = &quot;umap.harm&quot;) ## 16:25:04 UMAP embedding parameters a = 0.9922 b = 1.112 ## 16:25:04 Read 7216 rows and found 20 numeric columns ## 16:25:04 Using Annoy for neighbor search, n_neighbors = 30 ## 16:25:04 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 16:25:04 Writing NN index file to temp file /tmp/RtmpFLSb7W/file2ef732f30d28 ## 16:25:04 Searching Annoy index using 1 thread, search_k = 3000 ## 16:25:06 Annoy recall = 100% ## 16:25:08 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 ## 16:25:11 Initializing from normalized Laplacian + noise (using RSpectra) ## 16:25:11 Commencing optimization for 500 epochs, with 289862 positive edges ## 16:25:19 Optimization finished Code DimPlot(obj, reduction = &quot;umap.harm&quot;, group.by = c(&quot;Day&quot;, &quot;orig.ident&quot;, &quot;harm_cluster&quot;), label = T) Code ### save object #saveRDS(obj, file = &quot;./output_files/mutli_sample/integrated_harm_seurat.rds&quot;) "],["add-isoform-counts.html", "Chapter 10 Add isoform counts", " Chapter 10 Add isoform counts Now we can add isoform level information to the merged Seurat object. When doing this you may need to convert the oafish files into a count.csv file the row names in the ENSTID_gene_symbol ID form. The function to do so can be found here @ref(Convert Oarfish files to count matrix) The workflow follows these steps. Create a Seurat object per sample Merge the objects together Filter the isoform merged object based on cell types that are high quality (based on gene level filtering) Add the isoform filtered and merged object to the gene level object as a new assay Integration on the isoform assay is possible but not shown here. Code ############ read in count matix and add isoform assay to Seurat object ######### # Define sample names sample_names &lt;- c(&quot;C1_STC&quot;, &quot;C4_STC&quot;, &quot;C2_Day25&quot;, &quot;C5_Day25&quot;, &quot;C2_Day55&quot;, &quot;C3_Day55&quot;, &quot;C3_Day80&quot;, &quot;C5_Day80&quot;) #Make Seurat objects not filtered # Function to read a CSV file and create a Seurat object create_seurat_object &lt;- function(sample_name, input_dir, project_name) { # Construct file path file_path &lt;- file.path(input_dir, paste0(&quot;gene_symbol_oarfish_&quot;, sample_name, &quot;_counts.csv&quot;)) # Read the CSV file counts &lt;- fread(file_path) counts &lt;- as.data.frame(counts) rownames(counts) &lt;- counts[[1]] # Set row names from the first column counts[[1]] &lt;- NULL # Create the Seurat object seurat_obj &lt;- CreateSeuratObject(counts = counts, project = project_name, min.cells = 5, min.features = 500) return(seurat_obj) } # Directory where the CSV files are stored input_directory &lt;- &quot;./output_files/mutli_sample/oarfish_counts/&quot; # Create an empty list to store Seurat objects iso_seurat_objects &lt;- list() total_samples &lt;- length(sample_names) for (i in seq_along(sample_names)) { sample &lt;- sample_names[i] message(sprintf(&quot;Processing sample %d of %d: %s&quot;, i, total_samples, sample)) iso_seurat_objects[[sample]] &lt;- create_seurat_object( sample_name = sample, input_dir = input_directory, project_name = sample ) } ####### Merge the samples into one object ###### iso.merged_seurat &lt;- merge( iso_seurat_objects[[&quot;C1_STC&quot;]], y = list( iso_seurat_objects[[&quot;C4_STC&quot;]], iso_seurat_objects[[&quot;C2_Day25&quot;]], iso_seurat_objects[[&quot;C5_Day25&quot;]], iso_seurat_objects[[&quot;C2_Day55&quot;]], iso_seurat_objects[[&quot;C3_Day55&quot;]], iso_seurat_objects[[&quot;C3_Day80&quot;]], iso_seurat_objects[[&quot;C5_Day80&quot;]] ), add.cell.ids = c( &quot;C1_STC&quot;, &quot;C4_STC&quot;, &quot;C2_Day25&quot;, &quot;C5_Day25&quot;, &quot;C2_Day55&quot;, &quot;C3_Day55&quot;, &quot;C3_Day80&quot;, &quot;C5_Day80&quot; ), project = &quot;iso-Multi-sample_tutorial&quot; ) # create a sample column iso.merged_seurat$sample &lt;- rownames(iso.merged_seurat@meta.data) ## split sample column to makw a batch col iso.merged_seurat@meta.data &lt;- separate(iso.merged_seurat@meta.data, col = &#39;sample&#39;, into = c(&#39;batch&#39;, &#39;Day&#39;, &#39;Barcode&#39;), sep = &#39;_&#39;) #### rember to laod in the correct seurat object ##### ## filter the data to iso and gene cells match merged_seurat_isoform_filtered &lt;- subset(iso.merged_seurat, cells =obj@graphs[[&quot;RNA_nn&quot;]]@Dimnames[[1]]) VlnPlot(merged_seurat_isoform_filtered, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) # perform standard workflow steps merged_seurat_isoform_filtered &lt;- NormalizeData(object = merged_seurat_isoform_filtered) # if using SCT dont run this merged_seurat_isoform_filtered &lt;- FindVariableFeatures(object = merged_seurat_isoform_filtered) # if using SCT dont run this merged_seurat_isoform_filtered &lt;- ScaleData(object = merged_seurat_isoform_filtered) # if using SCT dont run this merged_seurat_isoform_filtered &lt;- RunPCA(object = merged_seurat_isoform_filtered) ElbowPlot(merged_seurat_isoform_filtered) merged_seurat_isoform_filtered &lt;- FindNeighbors(object = merged_seurat_isoform_filtered, dims = 1:10) merged_seurat_isoform_filtered &lt;- FindClusters(object = merged_seurat_isoform_filtered, resolution = 0.6) merged_seurat_isoform_filtered &lt;- RunUMAP(object = merged_seurat_isoform_filtered, dims = 1:10) #Save file #saveRDS(merged_seurat_isoform_filtered, file = &quot;./output_files/mutli_sample/merged_seurat_isoform_filtered.rds&quot;) Code readRDS(merged_seurat_isoform_filtered, file = &quot;./output_files/mutli_sample/merged_seurat_isoform_filtered.rds&quot;) ## An object of class Seurat ## 163280 features across 7216 samples within 1 assay ## Active assay: RNA (163280 features, 2000 variable features) ## 3 layers present: data, counts, scale.data ## 2 dimensional reductions calculated: pca, umap Code ######### ######## #plots p5 &lt;- DimPlot(merged_seurat_isoform_filtered, reduction = &#39;umap&#39;, group.by = &#39;orig.ident&#39;) p6 &lt;- DimPlot(merged_seurat_isoform_filtered, reduction = &#39;umap&#39;, group.by = &#39;Day&#39;) p7 &lt;- FeaturePlot(merged_seurat_isoform_filtered, reduction = &#39;umap&#39;, features = &#39;nCount_RNA&#39;) p8 &lt;- FeaturePlot(merged_seurat_isoform_filtered, reduction = &quot;umap&quot;, features = &#39;nFeature_RNA&#39;) grid.arrange(p5, p6, p7, p8, ncol = 2) Code ##### merged_seurat_isoform_filtered &lt;- JoinLayers(merged_seurat_isoform_filtered) counts_table &lt;- merged_seurat_isoform_filtered[[&quot;RNA&quot;]]$counts obj[[&quot;iso&quot;]] &lt;- CreateAssay5Object(counts = counts_table) # Step 1: Normalize the new assay data obj &lt;- NormalizeData(obj, assay = &quot;iso&quot;) ## Normalizing layer: counts Code obj &lt;- FindVariableFeatures(obj, assay = &quot;iso&quot;) ## Finding variable features for layer counts Code obj &lt;- ScaleData(obj, assay = &quot;iso&quot;) ## Centering and scaling data matrix Code # Step 4: Perform PCA obj &lt;- RunPCA(obj, assay = &quot;iso&quot;, reduction.name = &quot;pca_iso&quot;) ## PC_ 1 ## Positive: ENST00000430027.3-DLX6-AS1, ENST00000303177.8-NSG2, ENST00000220876.12-STMN2, ENST00000304886.6-SNAP25, ENST00000367816.5-ATP1B1, ENST00000704697.1-SYT1, ENST00000373489.10-PBX3, ENST00000305124.11-GAP43, ENST00000249330.3-VGF, ENST00000261205.9-SYT1 ## ENST00000482108.1-PEG10, ENST00000420428.7-CELF4, ENST00000651844.1-COPG2IT1, ENST00000635795.1-DCX, ENST00000636035.2-DCX, ENST00000526355.7-GUCY1A2, ENST00000458352.5-DLX6-AS1, ENST00000360351.8-MAP2, ENST00000393658.7-GPM6A, ENST00000281523.8-ZNF385D ## ENST00000263630.13-CCDC88A, ENST00000381620.9-GABRA2, ENST00000259271.7-GAD2, ENST00000610778.1-ENSG00000274422, ENST00000682079.1-MAP2, ENST00000284292.11-NRGN, ENST00000264426.14-GRIA2, ENST00000302277.7-ZNF804A, ENST00000285900.10-GRIA1, ENST00000436346.7-CCDC88A ## Negative: ENST00000259915.13-POU5F1, ENST00000613865.5-RPS24, ENST00000335658.7-DPPA4, ENST00000252486.9-APOE, ENST00000396210.8-MGST1, ENST00000372692.8-SET, ENST00000498273.2-L1TD1, ENST00000228251.9-YBX3, ENST00000276602.10-TERF1, ENST00000301072.11-TUBA1C ## ENST00000296145.6-CRIPTO, ENST00000295830.13-RPL22L1, ENST00000326279.11-LIN28A, ENST00000223271.8-RARRES2, ENST00000308987.6-CKS1B, ENST00000314355.7-CKS2, ENST00000329305.6-TPM2, ENST00000282561.4-GJA1, ENST00000396925.1-CLDN6, ENST00000271638.3-S100A11 ## ENST00000258499.8-USP44, ENST00000316660.7-PMAIP1, ENST00000388835.4-KRT18, ENST00000319248.13-PRDX1, ENST00000374561.6-ID3, ENST00000265643.4-GAL, ENST00000473291.1-HHLA1, ENST00000377962.8-CNMD, ENST00000383763.6-TRIM71, ENST00000261769.10-CDH1 ## PC_ 2 ## Positive: ENST00000544301.7-VIM, ENST00000368444.8-FABP7, ENST00000373615.9-LHX2, ENST00000376530.8-TTYH1, ENST00000282928.5-ZIC1, ENST00000357727.7-CREB5, ENST00000380518.8-COL2A1, ENST00000296503.10-HMGB2, ENST00000454729.3-PANTR1, ENST00000245479.3-SOX9 ## ENST00000443988.8-PANTR1, ENST00000381192.10-CD99, ENST00000395566.9-MDK, ENST00000301905.9-PBK, ENST00000553456.5-EMX2, ENST00000399387.9-LINC01551, ENST00000295113.5-FRZB, ENST00000344113.8-SYNE2, ENST00000376925.8-CST3, ENST00000341267.9-DLK1 ## ENST00000378453.4-HES5, ENST00000718304.1-HMGN2, ENST00000439742.7-MXD3, ENST00000358025.7-SYNE2, ENST00000568223.7-METRN, ENST00000319420.4-SHISA2, ENST00000362074.8-NOTCH2NLA, ENST00000378700.8-ID4, ENST00000445125.2-ENSG00000225840, ENST00000530167.2-H2AX ## Negative: ENST00000303177.8-NSG2, ENST00000263735.9-EPCAM, ENST00000388948.8-LRRK1, ENST00000304886.6-SNAP25, ENST00000367816.5-ATP1B1, ENST00000259915.13-POU5F1, ENST00000613865.5-RPS24, ENST00000249330.3-VGF, ENST00000261205.9-SYT1, ENST00000473291.1-HHLA1 ## ENST00000296145.6-CRIPTO, ENST00000404735.1-RPS27A, ENST00000299529.7-CRABP1, ENST00000316902.12-SLC7A8, ENST00000498273.2-L1TD1, ENST00000276602.10-TERF1, ENST00000265643.4-GAL, ENST00000420428.7-CELF4, ENST00000396925.1-CLDN6, ENST00000396210.8-MGST1 ## ENST00000373489.10-PBX3, ENST00000261769.10-CDH1, ENST00000505215.4-MIR302CHG, ENST00000373713.7-FABP3, ENST00000377962.8-CNMD, ENST00000731552.1-MIR302CHG, ENST00000326279.11-LIN28A, ENST00000383763.6-TRIM71, ENST00000256362.5-VRTN, ENST00000381620.9-GABRA2 ## PC_ 3 ## Positive: ENST00000341267.9-DLK1, ENST00000368222.8-CRABP2, ENST00000445125.2-ENSG00000225840, ENST00000319420.4-SHISA2, ENST00000295113.5-FRZB, ENST00000627981.1-ENSG00000281181, ENST00000625598.1-ENSG00000280614, ENST00000631211.1-ENSG00000280800, ENST00000553456.5-EMX2, ENST00000373615.9-LHX2 ## ENST00000282928.5-ZIC1, BambuTx4122-ENSG00000286149, ENST00000325870.3-DMRTA1, ENST00000399387.9-LINC01551, ENST00000393957.7-TPPP3, ENST00000340857.4-H1-0, ENST00000474034.1-ZIC1, ENST00000331224.10-DLK1, ENST00000330233.11-CRIP1, ENST00000356545.7-RSPO1 ## ENST00000582401.6-TXNIP, ENST00000693335.1-GNG8, ENST00000649451.1-NNAT, ENST00000377028.10-DCT, ENST00000606645.4-ENSG00000272449, ENST00000422447.8-LDHA, ENST00000252506.11-GADD45G, ENST00000614247.2-H4C4, ENST00000366756.4-DLL1, ENST00000383075.8-ZIC4 ## Negative: ENST00000350763.9-TNC, ENST00000403491.8-NFIA, ENST00000554144.5-HOPX, ENST00000337881.12-HOPX, ENST00000603233.2-NFIA, ENST00000329117.10-BCAN, ENST00000681775.1-SLC1A3, ENST00000624112.2-SLC1A3, ENST00000262593.10-DOK5, ENST00000395882.6-NTRK2 ## ENST00000367963.8-MOXD1, ENST00000265113.9-SLC1A3, ENST00000453190.7-LIFR, ENST00000454189.7-GPM6B, ENST00000371941.4-PREX1, ENST00000578921.6-RAB31, ENST00000557010.5-DIO2, ENST00000329203.5-FAM181B, ENST00000296506.8-SCRG1, ENST00000273261.8-LRIG1 ## ENST00000286657.10-ADAMTS3, ENST00000242152.7-NPY, ENST00000360472.9-PEA15, ENST00000418533.6-LTBP1, ENST00000680205.1-SLC1A3, ENST00000265071.3-CDH6, ENST00000438257.9-DIO2, ENST00000680064.1-SLC1A3, ENST00000246070.3-LAMP5, ENST00000517956.5-FBXO32 ## PC_ 4 ## Positive: ENST00000693335.1-GNG8, ENST00000341267.9-DLK1, ENST00000376925.8-CST3, ENST00000395566.9-MDK, ENST00000355852.6-PCBP4, ENST00000393957.7-TPPP3, ENST00000633531.1-PON2, ENST00000325870.3-DMRTA1, ENST00000445125.2-ENSG00000225840, ENST00000331224.10-DLK1 ## ENST00000631211.1-ENSG00000280800, ENST00000625598.1-ENSG00000280614, ENST00000550697.6-MYL6, ENST00000368222.8-CRABP2, ENST00000378700.8-ID4, ENST00000627981.1-ENSG00000281181, ENST00000442544.7-DCC, ENST00000649451.1-NNAT, ENST00000440480.8-CDKN1C, ENST00000368444.8-FABP7 ## ENST00000544301.7-VIM, ENST00000659034.4-LINC02609, ENST00000252506.11-GADD45G, ENST00000551357.4-LHX5-AS1, BambuTx4122-ENSG00000286149, ENST00000501122.3-NEAT1, ENST00000389554.8-TBR1, ENST00000234091.8-ID2, ENST00000606645.4-ENSG00000272449, ENST00000428101.6-LMO1 ## Negative: ENST00000439742.7-MXD3, ENST00000271452.8-NUF2, ENST00000368654.8-MKI67, ENST00000301905.9-PBK, ENST00000366999.9-NEK2, ENST00000380026.8-CENPE, ENST00000394249.8-PRC1, ENST00000423485.6-TOP2A, ENST00000538862.7-CDCA3, ENST00000414849.6-NUSAP1 ## ENST00000372224.9-KIF2C, ENST00000454366.2-GTSE1, ENST00000260359.10-NUSAP1, ENST00000335756.9-CENPA, ENST00000357799.9-SGO2, ENST00000356455.9-UBE2C, ENST00000367409.9-ASPM, ENST00000366955.8-CENPF, ENST00000232458.9-ECT2, ENST00000300403.11-TPX2 ## ENST00000399668.7-KNL1, ENST00000340384.5-TUBB4B, ENST00000313288.9-TACC3, ENST00000335183.11-CDKN3, ENST00000373055.6-CDCA8, ENST00000302450.11-CKAP2L, ENST00000300093.9-PLK1, ENST00000400889.3-FAM72D, ENST00000264552.14-UBE2S, ENST00000310955.11-CDC20 ## PC_ 5 ## Positive: ENST00000318789.11-FOXP1, ENST00000295156.9-VSNL1, ENST00000372524.5-ZNF503, ENST00000313708.11-EBF1, ENST00000241416.12-ACVR2A, ENST00000521268.6-RALYL, ENST00000370544.10-LMO4, ENST00000525166.6-FAT3, ENST00000649528.3-FOXP1, ENST00000482108.1-PEG10 ## ENST00000488574.5-PEG10, ENST00000406316.6-NRXN1, ENST00000305124.11-GAP43, ENST00000255224.8-SYT4, ENST00000490035.7-LSAMP, ENST00000641206.2-ZFHX3, ENST00000260653.5-SIX3, ENST00000230658.12-ISL1, ENST00000435030.6-KIF5C, ENST00000394480.6-NTRK3 ## ENST00000265840.12-ELMOD1, ENST00000623230.1-ENSG00000279814, ENST00000397463.3-LYPD1, ENST00000651372.2-ZFHX4, ENST00000274289.8-PLK2, ENST00000287641.4-SST, ENST00000265361.8-SEMA3C, ENST00000629765.3-NTRK3, ENST00000233813.5-IGFBP5, ENST00000376544.7-TLE4 ## Negative: ENST00000377049.4-CORT, ENST00000315087.12-ST8SIA5, ENST00000295101.3-KCNJ3, ENST00000274382.9-LIX1, ENST00000295894.9-SYNPR, ENST00000478300.6-SYNPR, ENST00000338037.11-PLCB1, ENST00000377961.3-SCGN, ENST00000302005.3-HSPB3, ENST00000758276.1-MIR9-1HG ## ENST00000309950.8-DAPL1, ENST00000397016.6-CPNE6, ENST00000537691.5-CPNE6, ENST00000497824.6-MIR9-1HG, ENST00000636471.1-ZEB2, ENST00000451755.2-ENSG00000235431, ENST00000627532.3-ZEB2, ENST00000392056.8-SPHKAP, ENST00000436346.7-CCDC88A, ENST00000841000.1-LINC03112 ## ENST00000281523.8-ZNF385D, ENST00000409343.5-ZNF385B, ENST00000382496.10-SEMA5A, ENST00000361725.5-DLX1, ENST00000373713.7-FABP3, ENST00000315930.11-FGF13, ENST00000264426.14-GRIA2, ENST00000400991.8-MIR9-1HG, ENST00000445907.6-CHRM2, ENST00000402395.5-SELENOM ## Warning: Key &#39;PC_&#39; taken, using &#39;pcaiso_&#39; instead Code # Step 5: Run UMAP obj &lt;- RunUMAP(obj, reduction = &quot;pca_iso&quot;, dims = 1:20, assay = &quot;iso&quot;, reduction.name = &quot;umap_iso&quot;) ## 16:26:35 UMAP embedding parameters a = 0.9922 b = 1.112 ## 16:26:35 Read 7216 rows and found 20 numeric columns ## 16:26:35 Using Annoy for neighbor search, n_neighbors = 30 ## 16:26:35 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 16:26:36 Writing NN index file to temp file /tmp/RtmpFLSb7W/file2ef735d52bc25 ## 16:26:36 Searching Annoy index using 1 thread, search_k = 3000 ## 16:26:37 Annoy recall = 100% ## 16:26:39 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 ## 16:26:42 Found 2 connected components, falling back to &#39;spca&#39; initialization with init_sdev = 1 ## 16:26:42 Using &#39;irlba&#39; for PCA ## 16:26:42 PCA: 2 components explained 47.78% variance ## 16:26:42 Scaling init to sdev = 1 ## 16:26:42 Commencing optimization for 500 epochs, with 283368 positive edges ## 16:26:49 Optimization finished Code # Visualize the UMAP DimPlot(obj, label = TRUE, reduction = &quot;umap_iso&quot;) | DimPlot(obj, label = TRUE, reduction = &quot;umap.harm&quot;) Here will annotate the cell types using the sctype and some prior knowledge. Code gs_removal_list &lt;- c(&quot;Tanycytes&quot;, &quot;Dopaminergic neurons&quot;, &quot;Oligodendrocyte precursor cells&quot;, &quot;Non myelinating Schwann cells&quot;, &quot;Endothelial cells&quot;) # list of cell types from the db to remove obj &lt;- perform_sctype_analysis(obj, db_, tissue, gs_removal_list, metadat_col_prefix =&quot;sctype_db&quot;, figure_prefix = &quot;multi&quot;, output_file = &quot;multi&quot;, cluster_res = &quot;harm_cluster&quot;, reduction = &quot;umap.harm&quot;) ## # A tibble: 12 × 3 ## # Groups: cluster [12] ## cluster type scores ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Cancer stem cells 873. ## 2 4 Cancer stem cells 659. ## 3 5 Radial glial cells 1124. ## 4 3 Radial glial cells 929. ## 5 9 Immature neurons 480. ## 6 6 Mature neurons 951. ## 7 1 GABAergic neurons 616. ## 8 0 GABAergic neurons 688. ## 9 11 Schwann precursor cells 37.3 ## 10 7 GABAergic neurons 825. ## 11 8 Microglial cells 419. ## 12 10 Radial glial cells 1333. Code #change name of cancer stem cell to stem cell obj@meta.data$sctype_db &lt;- gsub(&quot;Cancer stem cells&quot;, &quot;Stem cells&quot;, obj@meta.data$sctype_db) DimPlot(obj, reduction=&quot;umap.harm&quot;, group.by = &quot;sctype_db&quot;, label = T) Code #saveRDS(obj, file = &quot;./output_files/mutli_sample/multisample_seurat.intergrated_harm.isofrom.rds&quot;) "],["trajectory-analysis.html", "Chapter 11 Trajectory analysis", " Chapter 11 Trajectory analysis Trajectory analysis is a powerful tool in single-cell RNA-seq allowing us to track how cells transition between different states over time, rather than simply classifying them into discrete clusters. This approach is particularly useful for studying dynamic processes such as cellular differentiation, cell cycle progression, or disease progression. One of the key advantages of trajectory analysis is the ability to identify genes or (in the case of long read data) isoforms whose expression patterns are correlated with pseudotime In our example dataset we are interested in looking at genes or isofroms that change as a function of pseudotime as this will highlight imporat features that control stem cell to neuronal differentiating into neural cells. In the bellow code block is the perform_trajectory_analysis function which uses monocle3 (Trapnell et al., 2014) to learn the trajectory and order the cells by pseudotime. We also provide an optional mode to to identify gene or isoforms that change with pseudotime. 6 It’s important to note that analyzing features in relation to pseudotime can be computationally intensive Users can choose to plot the trajectory without the added computational load of ordering features by pseudotime, making the analysis more flexible. The parameter quantile can be used to specify the number of features to test (0.75 means your testing the top 25% of features) .↩︎ "],["references.html", "References", " References Chen, Y., Sim, A., Wan, Y. K., Yeo, K., Lee, J. J. X., Ling, M. H., Love, M. I., &amp; Göke, J. (2023). Context-aware transcript quantification from long-read RNA-seq data with Bambu. Nature Methods, 20(8), 1187–1195. https://doi.org/10.1038/s41592-023-01908-w Hahne, F., &amp; Ivanek, R. (2016). Visualizing genomic data using gviz and bioconductor (pp. 335–351). Springer New York. https://doi.org/10.1007/978-1-4939-3578-9_16 Jousheghani, Z. Z., &amp; Patro, R. (2024). Oarfish: Enhanced probabilistic modeling leads to improved accuracy in long read transcriptome quantification. http://dx.doi.org/10.1101/2024.02.28.582591 Korsunsky, I., Millard, N., Fan, J., Slowikowski, K., Zhang, F., Wei, K., Baglaenko, Y., Brenner, M., Loh, P., &amp; Raychaudhuri, S. (2019). Fast, sensitive and accurate integration of single-cell data with Harmony. Nature Methods, 16(12), 1289–1296. https://doi.org/10.1038/s41592-019-0619-0 Kovaka, S., Zimin, A. V., Pertea, G. M., Razaghi, R., Salzberg, S. L., &amp; Pertea, M. (2019). Transcriptome assembly from long-read RNA-seq alignments with StringTie2. Genome Biology, 20(1). https://doi.org/10.1186/s13059-019-1910-1 Pardo-Palacios, F. J., Arzalluz-Luque, A., Kondratova, L., Salguero, P., Mestre-Tomás, J., Amorín, R., Estevan-Morió, E., Liu, T., Nanni, A., McIntyre, L., Tseng, E., &amp; Conesa, A. (2024). SQANTI3: curation of long-read transcriptomes for accurate identification of known and novel isoforms. Nature Methods, 21(5), 793–797. https://doi.org/10.1038/s41592-024-02229-2 Smedley, D., Haider, S., Ballester, B., Holland, R., London, D., Thorisson, G., &amp; Kasprzyk, A. (2009). BioMart biological queries made easy. BMC Genomics, 10(1). https://doi.org/10.1186/1471-2164-10-22 Tian, L., Jabbari, J. S., Thijssen, R., Gouil, Q., Amarasinghe, S. L., Voogd, O., Kariyawasam, H., Du, M. R. M., Schuster, J., Wang, C., Su, S., Dong, X., Law, C. W., Lucattini, A., Prawer, Y. D. J., Collar-Fernández, C., Chung, J. D., Naim, T., Chan, A., … Ritchie, M. E. (2021). Comprehensive characterization of single-cell full-length isoforms in human and mouse with long-read sequencing. Genome Biology, 22(1). https://doi.org/10.1186/s13059-021-02525-6 Tjeldnes, H., Labun, K., Torres Cleuren, Y., Chyżyńska, K., Świrski, M., &amp; Valen, E. (2021). ORFik: a comprehensive R toolkit for the analysis of translation. BMC Bioinformatics, 22(1). https://doi.org/10.1186/s12859-021-04254-w Trapnell, C., Cacchiarelli, D., Grimsby, J., Pokharel, P., Li, S., Morse, M., Lennon, N. J., Livak, K. J., Mikkelsen, T. S., &amp; Rinn, J. L. (2014). The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells. Nature Biotechnology, 32(4), 381–386. https://doi.org/10.1038/nbt.2859 Wan, C. Y., Davis, J., Chauhan, M., Gleeson, J., Prawer, Y. J., De Paoli-Iseppi, R., Wells, C., Choi, J., &amp; Clark, M. (2024). IsoVis a webserver for visualization and annotation of alternative RNA isoforms. Nucleic Acids Research, 52(W1), W341–W347. https://doi.org/10.1093/nar/gkae343 You, Y., Prawer, Y. D. J., De Paoli-Iseppi, R., Hunt, C. P. J., Parish, C. L., Shim, H., &amp; Clark, M. B. (2023). Identification of cell barcodes from long-read single-cell RNA-seq with BLAZE. Genome Biology, 24(1). https://doi.org/10.1186/s13059-023-02907-y "],["conclusion.html", "Conclusion Acknowledgements Session info", " Conclusion In this tutorial, we have demonstrated an end-to-end workflow for analyzing and visualising long-read single cell data generated by FLAMES. We have shown how to preprocess the data to retain high-quality cells, load gene and isoform counts into a Seurat object, identify differentially expressed genes and isoforms across cell types, visualize isoform expression and structure, and identify novel isoforms that may impact protein function. While this tutorial covers the core aspects of single-cell long-read data analysis, several additional avenues remain unexplored. Further analyses could include enrichment analysis of differentially expressed transcription factors or splicing regulators, motif analysis to investigate regulatory element binding, and alternative splicing events that may impact cellular functions. Integrating these analyses can provide a more comprehensive understanding of cellular diversity and regulatory mechanisms. Ultimately, this tutorial, in combination with long-read tools such as FLAMES, offers a powerful toolkit for exploring and analyzing isoform-level dynamics in single cells. This workflow can be applied to other experimental contexts to identify candidate isoforms involved in development or disease pathogenesis. Notes need to add in multiple mode. not sure if this goes in in a separate tutorial or chapter. This would include. Data integration Trajectory analysis and isoforms that change with pseudotime DTU using isoform switch analyser Acknowledgements Thank you to Manveer and Michaela for reviewing this book and providing valuable suggestions to improve its clarity and content. Your feedback has contributed to making this a more useful resource for researchers working with long-read single-cell RNA sequencing data. Session info ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Red Hat Enterprise Linux 9.4 (Plow) ## ## Matrix products: default ## BLAS/LAPACK: FlexiBLAS OPENBLAS; LAPACK version 3.10.1 ## ## locale: ## [1] LC_CTYPE=en_AU.UTF-8 LC_NUMERIC=C LC_TIME=en_AU.UTF-8 LC_COLLATE=en_AU.UTF-8 LC_MONETARY=en_AU.UTF-8 LC_MESSAGES=en_AU.UTF-8 ## [7] LC_PAPER=en_AU.UTF-8 LC_NAME=C LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_AU.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Australia/Melbourne ## tzcode source: system (glibc) ## ## attached base packages: ## [1] grid stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] shiny_1.9.1 SeuratWrappers_0.3.5 monocle3_1.3.7 ROCR_1.0-11 ## [5] KernSmooth_2.23-24 fields_16.2 viridisLite_0.4.2 spam_2.10-0 ## [9] biomaRt_2.62.0 EnhancedVolcano_1.24.0 ggrepel_0.9.6 dittoSeq_1.16.0 ## [13] gprofiler2_0.2.3 HGNChelper_0.8.14 data.tree_1.1.0 igraph_2.1.1 ## [17] ggraph_2.2.1 BSgenome.Hsapiens.UCSC.hg38_1.4.5 BSgenome_1.74.0 BiocIO_1.16.0 ## [21] Gviz_1.50.0 GenomicFeatures_1.58.0 AnnotationDbi_1.68.0 ORFik_1.26.1 ## [25] GenomicAlignments_1.40.0 Rsamtools_2.20.0 Biostrings_2.72.1 XVector_0.46.0 ## [29] lubridate_1.9.3 forcats_1.0.0 dplyr_1.1.4 purrr_1.0.2 ## [33] readr_2.1.5 tidyr_1.3.1 tibble_3.2.1 ggplot2_3.5.1 ## [37] tidyverse_2.0.0 patchwork_1.3.0 cowplot_1.1.3 stringr_1.5.1 ## [41] DoubletFinder_2.0.4 celda_1.20.0 Matrix_1.7-1 BiocParallel_1.40.0 ## [45] data.table_1.16.2 gridExtra_2.3 DropletUtils_1.26.0 SingleCellExperiment_1.28.0 ## [49] SummarizedExperiment_1.36.0 Biobase_2.66.0 MatrixGenerics_1.18.0 matrixStats_1.4.1 ## [53] Seurat_5.1.0 SeuratObject_5.0.2 sp_2.1-4 rtracklayer_1.64.0 ## [57] GenomicRanges_1.58.0 GenomeInfoDb_1.42.0 IRanges_2.40.0 S4Vectors_0.44.0 ## [61] BiocGenerics_0.52.0 ## ## loaded via a namespace (and not attached): ## [1] R.methodsS3_1.8.2 dichromat_2.0-0.1 progress_1.2.3 nnet_7.3-19 goftest_1.2-3 biomartr_1.0.7 ## [7] HDF5Array_1.34.0 vctrs_0.6.5 spatstat.random_3.3-1 proxy_0.4-27 digest_0.6.37 png_0.1-8 ## [13] deldir_2.0-4 parallelly_1.38.0 combinat_0.0-8 MASS_7.3-61 reshape2_1.4.4 httpuv_1.6.15 ## [19] foreach_1.5.2 withr_3.0.2 ggrastr_1.0.2 xfun_0.49 survival_3.7-0 memoise_2.0.1 ## [25] ggbeeswarm_0.7.2 systemfonts_1.0.5 ragg_1.2.6 zoo_1.8-12 pbapply_1.7-2 R.oo_1.27.0 ## [31] Formula_1.2-5 prettyunits_1.2.0 KEGGREST_1.46.0 promises_1.3.0 httr_1.4.7 restfulr_0.0.15 ## [37] globals_0.16.3 fitdistrplus_1.2-1 rhdf5filters_1.18.0 fstcore_0.9.18 rhdf5_2.50.0 rstudioapi_0.15.0 ## [43] UCSC.utils_1.2.0 miniUI_0.1.1.1 generics_0.1.3 base64enc_0.1-3 curl_6.0.0 zlibbioc_1.52.0 ## [49] polyclip_1.10-7 GenomeInfoDbData_1.2.13 SparseArray_1.6.0 RcppEigen_0.3.4.0.2 xtable_1.8-4 doParallel_1.0.17 ## [55] evaluate_1.0.1 S4Arrays_1.6.0 BiocFileCache_2.14.0 hms_1.1.3 bookdown_0.41 irlba_2.3.5.1 ## [61] colorspace_2.1-1 filelock_1.0.3 harmony_1.2.1 reticulate_1.39.0 spatstat.data_3.1-2 magrittr_2.0.3 ## [67] lmtest_0.9-40 viridis_0.6.5 later_1.3.2 lattice_0.22-6 spatstat.geom_3.3-2 future.apply_1.11.3 ## [73] scattermore_1.2 XML_3.99-0.17 scuttle_1.16.0 RcppAnnoy_0.0.22 Hmisc_5.2-0 pillar_1.9.0 ## [79] nlme_3.1-166 iterators_1.0.14 compiler_4.4.0 beachmat_2.22.0 RSpectra_0.16-2 stringi_1.8.4 ## [85] tensor_1.5 minqa_1.2.8 MCMCprecision_0.4.0 plyr_1.8.9 crayon_1.5.3 abind_1.4-8 ## [91] locfit_1.5-9.10 graphlayouts_1.2.0 bit_4.5.0 textshaping_0.3.7 codetools_0.2-20 bslib_0.8.0 ## [97] biovizBase_1.54.0 plotly_4.10.4 mime_0.12 splines_4.4.0 Rcpp_1.0.13-1 fastDummies_1.7.4 ## [103] fst_0.9.8 dbplyr_2.5.0 sparseMatrixStats_1.18.0 interp_1.1-6 knitr_1.48 blob_1.2.4 ## [109] utf8_1.2.4 AnnotationFilter_1.30.0 lme4_1.1-35.5 WriteXLS_6.7.0 listenv_0.9.1 checkmate_2.3.2 ## [115] DelayedMatrixStats_1.28.0 openxlsx_4.2.6.1 statmod_1.5.0 tzdb_0.4.0 pheatmap_1.0.12 tweenr_2.0.3 ## [121] pkgconfig_2.0.3 tools_4.4.0 cachem_1.1.0 RhpcBLASctl_0.23-42 RSQLite_2.3.7 DBI_1.2.3 ## [127] splitstackshape_1.4.8 fastmap_1.2.0 rmarkdown_2.29 scales_1.3.0 ica_1.0-3 sass_0.4.9 ## [133] BiocManager_1.30.25 dotCall64_1.2 VariantAnnotation_1.52.0 RANN_2.6.2 rpart_4.1.23 farver_2.1.2 ## [139] tidygraph_1.3.1 yaml_2.3.10 latticeExtra_0.6-30 foreign_0.8-87 cli_3.6.3 txdbmaker_1.0.1 ## [145] leiden_0.4.3.1 lifecycle_1.0.4 rsconnect_1.3.2 uwot_0.2.2 presto_1.0.0 backports_1.5.0 ## [151] timechange_0.3.0 gtable_0.3.6 rjson_0.2.23 ggridges_0.5.6 progressr_0.15.0 parallel_4.4.0 ## [157] limma_3.62.1 jsonlite_1.8.9 edgeR_4.4.0 RcppHNSW_0.6.0 bitops_1.0-9 assertthat_0.2.1 ## [163] bit64_4.5.2 Rtsne_0.17 spatstat.utils_3.1-1 zip_2.3.0 highr_0.11 jquerylib_0.1.4 ## [169] dqrng_0.4.1 enrichR_3.2 spatstat.univar_3.0-0 R.utils_2.12.3 lazyeval_0.2.2 htmltools_0.5.8.1 ## [175] sctransform_0.4.1 rappdirs_0.3.3 ensembldb_2.28.0 glue_1.8.0 httr2_0.2.3 RCurl_1.98-1.16 ## [181] jpeg_0.1-10 boot_1.3-31 R6_2.5.1 DESeq2_1.46.0 labeling_0.4.3 cluster_2.1.6 ## [187] Rhdf5lib_1.28.0 nloptr_2.1.1 vipor_0.4.7 DelayedArray_0.32.0 tidyselect_1.2.1 ProtGenerics_1.38.0 ## [193] maps_3.4.2 htmlTable_2.4.3 ggforce_0.4.2 xml2_1.3.5 future_1.34.0 rsvd_1.0.5 ## [199] munsell_0.5.1 htmlwidgets_1.6.4 RColorBrewer_1.1-3 rlang_1.1.4 spatstat.sparse_3.1-0 spatstat.explore_3.3-1 ## [205] remotes_2.5.0 fansi_1.0.6 beeswarm_0.4.0 "],["appendix.html", "Appendix 11.1 Calculating the ambient RNA profile 11.2 Multisample QC function 11.3 Convert Oarfish files to count matrix", " Appendix 11.1 Calculating the ambient RNA profile By calculating the ambient RNA profile, we can perform two important analyses to improve data quality: (1) removing empty droplets and (2) normalizing for background RNA contamination. Chapter 3 of the tutorial outlines both processes. However, the first step is to calculate the background RNA profile by quantifying gene expression for a list of barcodes known to represent background droplets rather than true cells. When running FLAMES, one of the outputs is the empty_bc_list.csv file, which contains 2,000 barcodes identified as background, not associated with cells. Users can manually add additional background barcodes if needed (for advanced users). For a detailed understanding of how this list is determined, refer to the BLAZE publication (You et al., 2023). To incorporate the background barcode list, users should run FLAMES as they did previously, but include the background barcode list as the barcode_file parameter. There is no need to identify or quantify isoforms so users can set the following parameters to false in the config file \"do_isoform_identification\": false, \"bambu_isoform_identification\": false, \"do_read_realignment\": false, \"do_transcript_quantification\": false Code # Run FLAMES using background barcode list genrated in the first run. sce &lt;- sc_long_pipeline(fastq=fastq, outdir=output, annot=GTF, genome_bookdfa=genome, #minimap=minimap_dir, k8=k8, config_file=config_file, expect_cell_number=1000, barcodes_file=&#39;path/to/emtpy_bc_list.csv&#39;) 11.2 Multisample QC function Code # Perform QC for each sample perform_qc_filtering &lt;- function(count.matrix=C1_STC, min.features = 5000 , max.features = 10000, max.counts = 100000, min.counts = 3000, npc = 15, cluster_res = 0.9, fig_name = &#39;1&#39;, project = &quot;2&quot;, MT = 10, doublet_rate = 0.039) { # Function to calculate min.features and max.features if not provided calculate_feature_range &lt;- function(nFeature_RNA) { min_feature &lt;- round(mean(nFeature_RNA) - (1.5 * sd(nFeature_RNA))) max_feature &lt;- round(mean(nFeature_RNA) + (1.5 * sd(nFeature_RNA))) return(list(min_feature = min_feature, max_feature = max_feature)) } # If min.features and max.features not provided, calculate them if (is.null(min.features) || is.null(max.features)) { seurat_obj_org &lt;- CreateSeuratObject(counts = count.matrix, project = project) feature_range &lt;- calculate_feature_range(seurat_obj_org$nFeature_RNA) min.features &lt;- feature_range$min_feature max.features &lt;- feature_range$max_feature } rst_figures &lt;- list() rst_table &lt;- data.frame() ##### remove features expressed in less than 1% of cells ##### # Calculate the percentage of cells expressing each gene #gene_percent_expression &lt;- base::rowMeans(count.matrix &gt; 0) * 100 # Select genes expressed in at least 1% of cells #genes_filter &lt;- names(gene_percent_expression[gene_percent_expression &gt; 1]) # Filter counts #counts_sub &lt;- count.matrix[genes_filter, ] # Record the number of features removed #removed_features &lt;- dim(count.matrix)[1] - length(genes_filter) ####### # Initialize Seurat object seurat_object &lt;- CreateSeuratObject(counts = count.matrix, project = project) plot_scatter1 &lt;- FeatureScatter(seurat_object, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + geom_smooth(method = &quot;lm&quot;) + NoLegend() + labs(title = &quot;Association between reads and \\nunique genes per cell BEFORE filtering&quot;) plot(plot_scatter1) # Add mitochondrial percentage seurat_object[[&quot;joined&quot;]] &lt;- JoinLayers(seurat_object[[&quot;RNA&quot;]]) seurat_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(seurat_object, pattern = &quot;^MT-&quot;) # Plot violin plots p1 &lt;- VlnPlot(seurat_object, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;)) p1 + plot_annotation(title = &quot;QC plots (gene level) BEFORE Filtering&quot;) plot(p1) # Remove low quality cells filt_seurat_object &lt;- subset(seurat_object, subset = nFeature_RNA &gt; min.features &amp; nFeature_RNA &lt; max.features &amp; percent.mt &lt; MT &amp; nCount_RNA &lt; max.counts &amp; nCount_RNA &gt; min.counts) # Plot quality metrics after filtering p2 &lt;- VlnPlot(filt_seurat_object, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;)) p2 + plot_annotation(title = &quot;QC metrics gene level AFTER Filtering&quot;) plot(p2) ####### # Normalize data filt_seurat_object &lt;- NormalizeData(filt_seurat_object, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) # Identify highly variable features filt_seurat_object &lt;- FindVariableFeatures(filt_seurat_object, selection.method = &quot;vst&quot;, nfeatures = 2000) # Apply linear transformation all_genes &lt;- rownames(filt_seurat_object) filt_seurat_object &lt;- ScaleData(filt_seurat_object, features = all_genes) # Perform PCA filt_seurat_object &lt;- RunPCA(filt_seurat_object, features = VariableFeatures(object = filt_seurat_object)) # Visualize PCA rst_figures &lt;- append(rst_figures, ElbowPlot(filt_seurat_object)) # Cluster cells filt_seurat_object &lt;- FindNeighbors(filt_seurat_object, dims = 1:npc) filt_seurat_object &lt;- FindClusters(filt_seurat_object, resolution = cluster_res) # Perform UMAP filt_seurat_object &lt;- RunUMAP(filt_seurat_object, dims = 1:npc) ### Filter out doublets (remember to modify doublet rate if samples have variable target cells) ## pK Identification (no ground-truth) --------------------------------------------------------------------------------------- sweep.res.list_pbmc &lt;- paramSweep(filt_seurat_object, PCs = 1:20, sct = FALSE) sweep.stats_pbmc &lt;- summarizeSweep(sweep.res.list_pbmc, GT = FALSE) bcmvn_pbmc &lt;- find.pK(sweep.stats_pbmc) pK &lt;- bcmvn_pbmc %&gt;% filter(BCmetric == max(BCmetric)) %&gt;% dplyr::select(pK) pK &lt;- as.numeric(as.character(pK[[1]])) ## Homotypic Doublet Proportion Estimate ------------------------------------------------------------------------------------- annotations &lt;- filt_seurat_object@meta.data$seurat_clusters homotypic.prop &lt;- modelHomotypic(annotations) nExp_poi &lt;- round(doublet_rate * nrow(filt_seurat_object@meta.data)) nExp_poi.adj &lt;- round(nExp_poi * (1 - homotypic.prop)) # Run doubletFinder filt_seurat_object &lt;- doubletFinder(filt_seurat_object, PCs = 1:20, pN = 0.25, pK = pK, nExp = nExp_poi.adj, reuse.pANN = FALSE, sct = FALSE) colnames(filt_seurat_object@meta.data) &lt;- sub(&quot;DF.classifications_.*$&quot;, &quot;DF.classifications&quot;, colnames(filt_seurat_object@meta.data)) # Summary doublets statsDoublets &lt;- filt_seurat_object@meta.data %&gt;% group_by(DF.classifications) %&gt;% dplyr::summarize(Median_nCount_RNA = median(nCount_RNA), Median_nFeature_RNA = median(nFeature_RNA), Count = n()) # Visualize doublets doublets &lt;- DimPlot(filt_seurat_object, reduction = &#39;umap&#39;, group.by = &quot;DF.classifications&quot;) ### i want to save the seurat object with doublets listed filt_seurat_object_doublets &lt;- filt_seurat_object filt_seurat_object &lt;- subset(filt_seurat_object, subset = DF.classifications == &#39;Singlet&#39;) # figures ggplot_list &lt;- list( ElbowPlot(filt_seurat_object) + labs(title = &#39;SD explained by each PC&#39;) + theme(text = element_text(size = 10)), FeatureScatter(filt_seurat_object, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + geom_smooth(method = &quot;lm&quot;) + NoLegend() + labs(title = &quot;Association between reads and \\nunique genes per cell AFTER filtering&quot;), DimPlot(filt_seurat_object, reduction = &quot;umap&quot;) + labs(color = &quot;Cluster \\n(from PCA)&quot;, title = &#39;&#39;) + theme(text = element_text(size = 10)), FeaturePlot(filt_seurat_object, reduction = &quot;umap&quot;, features = &#39;nCount_RNA&#39;) + labs(color = &quot;UMI count&quot;, title = &#39;&#39;) + theme(text = element_text(size = 10)), FeaturePlot(filt_seurat_object, reduction = &quot;umap&quot;, features = &#39;nFeature_RNA&#39;) + labs(color = str_wrap(&quot;Feature count (gene)&quot;, 15), title = &#39;&#39;) + theme(text = element_text(size = 10)), p2 ) combined_plots &lt;- plot_grid(plotlist = ggplot_list, ncol = 3) plot(combined_plots) plot(DimPlot(filt_seurat_object_doublets, reduction = &#39;umap&#39;, group.by = &quot;DF.classifications&quot;)) tbl_sts1 &lt;- tableGrob(statsDoublets) grid.newpage() grid.draw(tbl_sts1) # summary stats stats_sumary &lt;- rbind(&quot;Sample ID&quot; = project, &quot;Cells_before_filter&quot; = dim(seurat_object)[2], &quot;Cells_after_filter&quot; = dim(filt_seurat_object)[2], &quot;Median Feature per Cell before filter&quot; = median(seurat_object$nFeature_RNA), &quot;Median Reads per Gene before filter&quot; = median(seurat_object$nCount_RNA), &quot;Median Feature per Cell&quot; = median(filt_seurat_object$nFeature_RNA), &quot;Median Reads per Gene&quot; = median(filt_seurat_object$nCount_RNA), &quot;Max Features&quot; = max.features, &quot;Min Features&quot; = min.features, &quot;Min Counts&quot; = min.counts, &quot;Max Counts&quot; = max.counts, &quot;MT Percentage&quot; = MT, &quot;NPCs&quot; = npc, &quot;Median Percent MT before Filter&quot; = median(seurat_object@meta.data[[&quot;percent.mt&quot;]]), &quot;Median Percent MT after Filter&quot; = median(filt_seurat_object@meta.data[[&quot;percent.mt&quot;]]) ) tbl_sts2 &lt;- tableGrob(stats_sumary) grid.newpage() grid.draw(tbl_sts2) list(filt_seurat_object, statsDoublets, stats_sumary, filt_seurat_object_doublets) } 11.3 Convert Oarfish files to count matrix This is a function to take all oarfish files from FLAMES multisample output folder and convert the files into a gene count matrix that contains gene symbol ids instead of ENSGIDs. To use this fucntion ensure that the isoform_gene_dict.csv file has been genrated as decibed in ?? Code ### readSeurat### read in oarfish count files and add them to seurat objects ### process_oarfish_files_to_counts_matrix &lt;- function(sample_name, resource_table_path, output_dir, input_dir) { # Load required libraries library(Matrix) library(dplyr) # Read in the resource table (transcript_id, gene_id, gene_symbol) combined_data &lt;- fread(resource_table_path) # Define the file paths based on the sample name # Construct file paths count_matrix_path &lt;- file.path(input_dir, paste0(sample_name, &quot;.count.mtx&quot;)) barcodes_path &lt;- file.path(input_dir, paste0(sample_name, &quot;.barcodes.txt&quot;)) features_path &lt;- file.path(input_dir, paste0(sample_name, &quot;.features.txt&quot;)) # Read the data counts &lt;- readMM(count_matrix_path) barcodes &lt;- readLines(barcodes_path) features &lt;- read.delim(features_path, header = FALSE) # Transpose the matrix if needed (for Seurat compatibility) counts &lt;- t(counts) # Set row and column names rownames(counts) &lt;- features$V1 colnames(counts) &lt;- barcodes # Convert to a data frame counts_df &lt;- as.data.frame(counts) # Add transcript_id as the first column counts_df$transcript_id &lt;- rownames(counts_df) counts_df &lt;- counts_df[, c(ncol(counts_df), 1:(ncol(counts_df)-1))] # Merge with the resource table to add gene symbols df_genesymbol &lt;- counts_df %&gt;% left_join(combined_data, by = &quot;transcript_id&quot;) # Remove the gene_id column and reorder the columns df_genesymbol$gene_id &lt;- NULL df_genesymbol &lt;- df_genesymbol[, c(ncol(df_genesymbol), 1:(ncol(df_genesymbol)-1))] # Update row names to include gene symbol instead of transcript_id rownames(df_genesymbol) &lt;- paste0(df_genesymbol$transcript_id, &quot;_&quot;, df_genesymbol$gene_symbol) df_genesymbol$transcript_id &lt;- NULL df_genesymbol$gene_symbol &lt;- NULL # Write the output to a CSV file output_path &lt;- file.path(output_dir, paste0(&quot;gene_symbol_oarfish_&quot;, sample_name, &quot;_counts.csv&quot;)) fwrite(df_genesymbol, output_path, row.names = TRUE) cat(&quot;Processed sample:&quot;, sample_name, &quot;\\nOutput saved to:&quot;, output_path, &quot;\\n&quot;) } # Example usage: # List of sample names sample_names &lt;- c(&quot;C1_STC&quot;) #create a resource # Call the helper function defined in code block above to create a dictionary containing corresponding gene information for each isoform # This may take a few minutes # The FLAMES ref can be found in your selected output folder after running the Flames pipeline. FLAMES_gtf_file &lt;- &quot;./data/muti_sample/isoform_annotated.gtf&quot; #ensure file is unzipped reference_gtf_file &lt;- &quot;./data/gencode.v47.annotation.gtf&quot; # ensure file is unzipped output_file &lt;- &quot;multi_isoform_gene_dict.csv&quot; isoform_gene_dict &lt;- make_isoform_gene_symbol_dict(FLAMES_gtf_file, reference_gtf_file, output_file) # run this in the output FLAMES dir # Loop through each sample and process the count files for (sample in sample_names) { # Use tryCatch to handle errors tryCatch({ # Call the function to process the sample process_oarfish_files_to_counts_matrix( sample_name = sample, resource_table_path = &quot;./output_files/ref_files/multi_isoform_gene_dict.csv&quot;, output_dir = &quot;./output_files/mutli_sample/oarfish_counts&quot;, input_dir = &quot;./output_files/mutli_sample/oarfish_counts&quot; ) }, error = function(e) { # Print the error message and exit the loop cat(&quot;Error processing sample:&quot;, sample, &quot;\\nError message:&quot;, e$message, &quot;\\nExiting loop.\\n&quot;) stop(e) }) } "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
