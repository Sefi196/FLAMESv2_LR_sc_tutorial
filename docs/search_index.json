[["index.html", "Adding Isoform data to your object Chapter 1 Introduction", " Adding Isoform data to your object Sefi Prawer 2024-12-11 Chapter 1 Introduction Welcome to the FLAMES single sample tutorial! In this tutorial, we will guide you through a basic analysis of long-read single-cell RNA sequencing data. Our goal is to demonstrate how to use the output from our package, FLAMES, to create and process long-read single-cell data. Here we will focus on using Seurat and other very popular single cell tools for analysis and processing single cell data. Much of this analysis will follow standard short read single cell processing norms, yet with long read data we can also explore isoform-level expression in single cells. This can be very useful as we hope to demonstrate throughout this tutorial. This tutorial assumes that have; Run the sc_long_pipeline (to process a single sample) and have set your config file with these parameters set to TRUE “bambu_isoform_identification”: [true] “oarfish_quantification”: [true] And That you have run FLAMES to calculate the ambient RNA profile. An explanation of how to this can be found here: … [placeholder] If you wish to run through the tutorial using the data provided in the ‘data’ folder please ensure you unzip all the files. If you wish run through the tutorial using your own single sample output from FLAMES, there is no need to unzip your files please ensure you use the correct gtf. The gtf used when running FLAMES must be the same for subsequent analysis. The current version used in this tutorial can be downloaded using the following command wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_47/gencode.v47.annotation.gtf.gz Much of the workflow will remain the same if you decide to use other tools for quantification or isoform discovery, which FLAMES does support, but these are the tools that in our hands perform the best and what we would recommend using at this stage. This single sample tutorial will use data generated in the Clark lab. This is small dataset of approximately 400 cells. The cells are at Day55 of a excitatory neural differentiation protocol. More information on the dataset and sequencing methodology can be found here …. If you find this tutorial useful please cite our work… If you have questions or suggestions please email ‘sefi.prawer@unimelb.edu.au’ or leave a comment on this github page. "],["setup.html", "Chapter 2 Setup 2.1 load in required packages 2.2 Creating resource files. 2.3 Convert count matrices from Gene ID to gene Symbol", " Chapter 2 Setup 2.1 load in required packages 2.2 Creating resource files. To start, we’ll create a few essential files that will be used throughout the analysis. The first step is to generate a CSV file containing three key columns: ENSTID, ENSGID, and geneSymbol. This file will be used as a dictionary to rename entries in both the isoform and gene count matrices, replacing ENSGID with the corresponding gene symbol. By adopting this naming convention for ENSTID, we can easily identify the gene origin of each isoform, streamlining the interpretation and analysis of gene and isoform-level data. First lets define a helper function for this step: # Function to make csv naming resource make_isoform_gene_symbol_dict &lt;- function(FLAMES_gtf, reference_gtf, output_file) { # Import the first GTF file (transcripts GTF) gtf1 &lt;- import(FLAMES_gtf) gtf1_df &lt;- as.data.frame(gtf1) # Select relevant columns from the first GTF selected_columns1 &lt;- gtf1_df[, c(&quot;transcript_id&quot;, &quot;gene_id&quot;)] unique_selected_cols &lt;- unique(selected_columns1) # Import the second GTF file (reference GTF with gene symbols) gtf2 &lt;- import(reference_gtf) gtf2_df &lt;- as.data.frame(gtf2) # Select relevant columns from the second GTF selected_columns2 &lt;- gtf2_df[, c(&quot;gene_name&quot;, &quot;gene_id&quot;)] unique_gene_symbol &lt;- unique(selected_columns2) # Merge the two data frames on &#39;gene_id&#39; combined_data &lt;- merge(unique_selected_cols, unique_gene_symbol, by = &quot;gene_id&quot;, all.x = TRUE) # If &#39;gene_name&#39; is missing, replace it with &#39;gene_id&#39; combined_data$gene_symbol &lt;- ifelse(is.na(combined_data$gene_name), combined_data$gene_id, combined_data$gene_name) # Select relevant columns final_combined_data &lt;- combined_data[, c(&quot;transcript_id&quot;, &quot;gene_id&quot;, &quot;gene_symbol&quot;)] # Write to a CSV file write.csv(final_combined_data, file = file.path(&quot;output_files/ref_files&quot;, output_file), row.names = FALSE) return(final_combined_data) } Run this chunk to create the dictionary containing ENSTID, ENSGID, and geneSymbol information: # The FLAMES ref can be found in your selected output folder after running the Flames pipeline. FLAMES_gtf_file &lt;- &quot;./data/FLAMES_out/isoform_annotated.gtf&quot; #ensure file is unzipped reference_gtf_file &lt;- &quot;./data/gencode.v47.annotation.gtf&quot; # ensure file is unzipped output_file &lt;- &quot;isoform_gene_dict.csv&quot; # Call the helper function defined in code block above to create a dictionary containing corresponding gene information for each isoform # This may take a few minutes isoform_gene_dict &lt;- make_isoform_gene_symbol_dict(FLAMES_gtf_file, reference_gtf_file, output_file) 2.3 Convert count matrices from Gene ID to gene Symbol With the reference dictionary in place, we can now rename both our count matrix and background count matrix by converting ENSGIDs to geneSymbols. This conversion not only simplifies the interpretation of gene expression in single cells but is also necessary for some downstream tools that require gene symbols instead of ENSGIDs, such as automated cell annotation tools. Like before, lets define a generic helper function first to do this: convert_ENSGID_to_geneSymbol &lt;- function(gene_count_matrix_path, id_symbol_df = isoform_gene_dict, output_file, return_df = FALSE) { # Load the reference dictionary we made earlier - select gene-level cols id_symbol_df &lt;- id_symbol_df %&gt;% dplyr::select(gene_id, gene_symbol) # Load the data object with ENSGID row names gene_count_matrix &lt;- read.csv(gene_count_matrix_path, header = TRUE) colnames(gene_count_matrix)[1] &lt;- &quot;gene_id&quot; # Replace ENSGIDs with gene symbols in original flames gene-level count matrix formatted_gene_count_matrix &lt;- gene_count_matrix %&gt;% merge(id_symbol_df, by.x = &#39;gene_id&#39;, by.y = &#39;gene_id&#39;) %&gt;% # Add gene symbol information distinct(gene_symbol, .keep_all = TRUE) %&gt;% # Remove duplicates based on gene symbol select(-gene_id) %&gt;% # Remove the ENSGID column column_to_rownames(var = &quot;gene_symbol&quot;) # use the gene symbols we added as rownames # Write out the processed data frame write.csv(formatted_gene_count_matrix, output_file, row.names = TRUE) # Return the processed count matrix for further use if needed if(return_df){ return(formatted_gene_count_matrix) } } Run the chunk below to format gene-level count matrices for background and FLAMES data using the helper function from above: # convert Gene_id to gene symbol for gene counts convert_ENSGID_to_geneSymbol( gene_count_matrix_path = &quot;./data/FLAMES_out/gene_count.csv&quot;, output_file = &quot;./output_files/counts/geneSymbol_gene_count.csv&quot; ) # convert Gene_id to gene symbol for background counts convert_ENSGID_to_geneSymbol( gene_count_matrix_path = &quot;./data/background/gene_count.csv&quot;, output_file = &quot;./output_files/counts/background_geneSymbol_gene_count.csv&quot; ) Now we have the files we need to begin cleaning our data and removing unwanted noise. "],["removing-sources-of-unwanted-noise-from-the-single-cell-dataset.html", "Chapter 3 Removing sources of unwanted noise from the single cell dataset 3.1 Removing ambient RNA contamination 3.2 Standard gene QC to remove low quality cells", " Chapter 3 Removing sources of unwanted noise from the single cell dataset Now we will do some initial prepossessing of single cell data to ensure we have some high quality data. This will involve 3 main steps Removing empty droplets - droplets that do not contain true cells. Removing ambient RNA contamination - optional Removing low quality cells that 3.0.1 Empty droplets This function removes empty droplets, a critical step to ensure that only true cells are retained for analysis. In short-read analysis using CellRanger, this process is automated, and empty droplets are removed by the software. However, FLAMES does not perform this step automatically, so it must be done manually. The function provided here not only removes empty droplets but also generates general QC metrics, enabling users to assess the reasonableness of the number of cells removed. ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 344 ## Number of edges: 7209 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8510 ## Number of communities: 7 ## Elapsed time: 0 seconds 3.1 Removing ambient RNA contamination Now we will remove ambient RNA contamination using decontX (or SoupX). This step is optional, and it’s up to the user to decide whether it’s necessary. In this case, the barcode rank plot (found here…) shows a clear distinction between true barcodes and background barcodes, suggesting that ambient RNA contamination may not significantly contribute to noise in this dataset. However, we’ll demonstrate how to run this step in case your barcode rank plot is noisier and contamination is a concern. if users wish to skip this step take the ‘seurat_obj_rm_empty’ object and proceed to standard gene QC step. # Function to run decontX on a single Seurat object run_decontX &lt;- function(seurat_obj_path, background_counts_path, sample_id) { # Load the Seurat object seurat_obj &lt;- readRDS(seurat_obj_path) filtered_counts &lt;- as.matrix(GetAssayData(seurat_obj, layer = &quot;counts&quot;)) # Read background counts raw_counts &lt;- as.matrix(read.csv(background_counts_path, row.names = 1)) # Get cluster info from Seurat object cluster_info &lt;- setNames(seurat_obj$seurat_clusters, colnames(seurat_obj)) # Find common genes common_genes &lt;- intersect(rownames(filtered_counts), rownames(raw_counts)) raw_counts &lt;- raw_counts[common_genes, ] filtered_counts &lt;- filtered_counts[common_genes, ] # Create SingleCellExperiment objects sce_raw &lt;- SingleCellExperiment(list(counts = raw_counts)) sce_object &lt;- SingleCellExperiment(list(counts = filtered_counts)) # Run decontX with background sce &lt;- decontX(sce_object, z = cluster_info, background = sce_raw) # Summarize contamination levels contamination_summary &lt;- as.array(summary(sce$decontX_contamination)) print(contamination_summary) # Add contamination levels to Seurat object metadata contamination &lt;- colData(sce)$decontX_contamination seurat_obj &lt;- AddMetaData(seurat_obj, metadata = contamination, col.name = &quot;decontX_contamination&quot;) # Extract decontaminated counts from SCE object decontaminated_counts &lt;- assay(sce, &quot;decontXcounts&quot;) decontaminated_counts &lt;- as.matrix(decontaminated_counts) # Create a new assay with decontaminated counts and add it to Seurat object new_assay &lt;- CreateAssayObject(counts = decontaminated_counts) seurat_obj[[&quot;decontaminated&quot;]] &lt;- new_assay clusters_umap_orig &lt;- DimPlot( object = seurat_obj, group.by = &quot;seurat_clusters&quot;, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5 ) + labs(title = &quot;Old UMAP with Clusters&quot;) # Plot UMAP with contamination levels contamination_umap &lt;- FeaturePlot( object = seurat_obj, features = &quot;decontX_contamination&quot;, reduction = &quot;umap&quot; ) + labs(title = &quot;UMAP Colored by decontX_contamination&quot;) DefaultAssay(seurat_obj) &lt;- &quot;decontaminated&quot; # Normalization, variable feature selection, and scaling seurat_obj &lt;- NormalizeData(seurat_obj) seurat_obj &lt;- FindVariableFeatures(seurat_obj) seurat_obj &lt;- ScaleData(seurat_obj) # PCA and clustering seurat_obj &lt;- RunPCA(seurat_obj) seurat_obj &lt;- FindNeighbors(seurat_obj, dims = 1:20) seurat_obj &lt;- FindClusters(seurat_obj, resolution = 0.7) # UMAP seurat_obj &lt;- RunUMAP(seurat_obj, dims = 1:20) # Plot UMAP with updated clusters clusters_umap &lt;- DimPlot( object = seurat_obj, group.by = &quot;seurat_clusters&quot;, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5 ) + labs(title = &quot;UMAP with Corrected Clusters&quot;) # Combine plots combined_umap &lt;- cowplot::plot_grid(clusters_umap_orig, contamination_umap, clusters_umap, ncol = 3) cat(&quot;Making plots\\n&quot;) # Save the combined plot as a PDF #pdf(file = paste0(sample_id, &quot;_decontx_plots.pdf&quot;), width = 18, height = 6) print(combined_umap) #dev.off() cat(&quot;Saving seurat obj\\n&quot;) # Save the Seurat object saveRDS(seurat_obj, file = paste0(sample_id, &quot;_decontx_seurat_obj.rds&quot;)) # Save decontaminated counts and contamination summary cat(&quot;Saving decontx counts\\n&quot;) write.csv(decontaminated_counts, paste0(sample_id, &quot;_decontx_counts.csv&quot;)) # Print a message indicating that the contamination summary is being saved cat(&quot;Saving contamination summary\\n&quot;) # Ensure contamination_summary is a data frame contamination_summary_df &lt;- as.data.frame(contamination_summary) write.table(contamination_summary_df, file = paste0(sample_id, &quot;_contamination_summary.txt&quot;)) # Optionally return the results return(list(seurat_obj = seurat_obj, decontaminated_counts = decontaminated_counts, contamination_summary = contamination_summary)) } # Run decontX on the input Seurat object and background counts file deconx_results &lt;- run_decontX(&quot;./output_files/empty_drops/removed_empty_Day55.rds&quot;, &quot;./output_files/counts/background_geneSymbol_gene_count.csv&quot;, &quot;./output_files/decontx//Day55&quot;) ## -------------------------------------------------- ## Starting DecontX ## -------------------------------------------------- ## Wed Dec 11 17:06:57 2024 .. Analyzing all cells ## Wed Dec 11 17:06:57 2024 .... Converting to sparse matrix ## Wed Dec 11 17:06:57 2024 .... Generating UMAP ## Wed Dec 11 17:07:02 2024 .... Estimating contamination ## Wed Dec 11 17:07:03 2024 ...... Completed iteration: 10 | converge: 0.02483 ## Wed Dec 11 17:07:03 2024 ...... Completed iteration: 20 | converge: 0.009197 ## Wed Dec 11 17:07:03 2024 ...... Completed iteration: 30 | converge: 0.005009 ## Wed Dec 11 17:07:04 2024 ...... Completed iteration: 40 | converge: 0.003423 ## Wed Dec 11 17:07:04 2024 ...... Completed iteration: 50 | converge: 0.00254 ## Wed Dec 11 17:07:04 2024 ...... Completed iteration: 60 | converge: 0.002116 ## Wed Dec 11 17:07:04 2024 ...... Completed iteration: 70 | converge: 0.001571 ## Wed Dec 11 17:07:05 2024 ...... Completed iteration: 80 | converge: 0.00118 ## Wed Dec 11 17:07:05 2024 ...... Completed iteration: 87 | converge: 0.0009944 ## Wed Dec 11 17:07:05 2024 .. Calculating final decontaminated matrix ## -------------------------------------------------- ## Completed DecontX. Total time: 7.943764 secs ## -------------------------------------------------- ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.001336 0.040294 0.065590 0.095857 0.113042 0.810218 ## Centering and scaling data matrix ## PC_ 1 ## Positive: VIM, ADGRV1, GLI3, DOK5, CACHD1, DACH1, SMC4, SHROOM3, RCN1, PARD3 ## FBXL7, PHGDH, HMGA2, HMGN2, ID3, ENSG00000286757, ID4, LRIG1, SOX2, NBPF14 ## LTBP1, YAP1, HMGB2, ZFP36L1, SLC35F1, TRIM59-IFT80, SMC2, TUBA1B, COL4A5, LEF1 ## Negative: NRXN1, PTPRD, MYT1L, LRRC7, ANK3, MAPT, DCC, UNC79, PTPRN2, SLC4A10 ## KCNH7, ENOX1, ANKS1B, EPHA5, RALYL, PHACTR3, CNTNAP2, RUNX1T1, NBEA, CACNA1E ## THSD7A, CACNA1A, GRIA2, NSG2, LINC01122, NELL2, RBFOX1, CELF4, NFASC, NEUROD6 ## PC_ 2 ## Positive: HECW1, LHX2, MPPED2, IVNS1ABP, LEF1, SEZ6L, SFRP1, ENSG00000251680, CADPS, ROBO2 ## ADAMTS19, B3GAT2, LRRC3B, FUT9, LMNB1, SNCAIP, TMTC1, NKAIN3, LTBP1, FOXP1 ## NRG1, STOX1, SV2C, PANTR1, PREX2, SEMA3C, ITGA2, GLI3, UHRF1, ENSG00000301688 ## Negative: SLIT3, RSPO2, RBM47, DYNLRB2-AS1, PRTG, LMX1A, PCP4, WLS, ENSG00000287949, MAF ## GJA1, FYB2, RSPO1, PLS3, MIR4435-2HG, NR3C2, RBM20, ZIC1, KRT8, LGI1 ## EYA4, KRT18, ENSG00000241231, TPBG, TTR, OTX2, WNT2B, PTCHD1-AS, DLK1, IFITM1 ## PC_ 3 ## Positive: NHLH1, EBF2, SLC22A23, DISP3, ENSG00000285755, CECR2, LINC01830, FRMD4B, ARL4D, BHLHE22 ## ENC1, RASGEF1B, ENSG00000310169, BHLHE22-AS1, PPP1R17, CRABP1, CHD7, FAM149A, RBFOX3, NFIA-AS2 ## HYCC1, LMO1, NPTX1, HUNK, UNC5A, SERINC5, PGAP1, P2RX3, PRDM8, ENSG00000231252 ## Negative: OPCML, NAV3, FRMD4A, GRIN2B, XKR4, KIRREL3, NALF1, KCNMA1, CNTN1, NAV2 ## GRIK3, CALN1, LRP1B, SMARCA2, DGKI, NRG3, SYN3, PRKG1, MACROD2, GAREM1 ## SLCO3A1, MDGA2, SYT13, ATXN1, ULK4, GRID2, GABBR2, ZC3H12B, LMO3, RIMS1 ## PC_ 4 ## Positive: ZFPM2, ZFPM2-AS1, ZEB2, MYO5B, CSRP2, ZBTB18, PLXDC2, ST18, NEUROD6, CAP2 ## NELL2, ENSG00000307341, PDE1A, GAREM1, ADAMTS3, FLRT2, DLGAP1, EPHA7, NEUROD2, GRIA3 ## CTTNBP2, SLC24A2, PDGFC, DMD, SYNDIG1, CORO2B, CENPE, KCNH7, SDK1, THSD7A ## Negative: COPG2, PBX3, GAD2, COPG2IT1, VGF, ENSG00000259460, KCNMB2, MEIS2, KCNMB2-AS1, LINC01414 ## SIX3, ENSG00000270953, MEST, ENSG00000298285, SPRY4-AS1, PCDH7, DLX1, DLX6-AS1, SORCS3, SIX3-AS1 ## GRM7, KCNH1, CDH8, DLX2, SGCD, MDGA2, SLC35F3, NRXN3, GAD1, MIR325HG ## PC_ 5 ## Positive: CDC20, CCNB1, PLK1, UBE2S, DLGAP5, KNSTRN, CCNB2, ARL6IP1, TPX2, AURKA ## NEK2, PTTG1, CDKN3, TROAP, GTSE1, UBE2C, BUB1, SGO2, KIF20A, CEP55 ## PRR11, CENPE, GAS2L3, CDCA8, ASPM, PIMREG, ARHGAP11A, BIRC5, NDE1, DEPDC1 ## Negative: HECW1, DPP10, GPC6, LINC03051, BMPR1B, SLC1A3, SPIDR, DMD, ZFPM2, TMTC1 ## SDK1, ADAMTS6, ADAMTS19, ENSG00000301688, HDAC9, MEGF11, PVT1, MCM4, LRP4, RHBDL3 ## FREM2, TAFA1, STOX1, LAMA1, RORA, NCKAP5, HELLS, PDGFC, STOX2, KHDRBS2 ## Computing nearest neighbor graph ## Computing SNN ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 339 ## Number of edges: 7342 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8177 ## Number of communities: 8 ## Elapsed time: 0 seconds ## 17:07:06 UMAP embedding parameters a = 0.9922 b = 1.112 ## 17:07:06 Read 339 rows and found 20 numeric columns ## 17:07:06 Using Annoy for neighbor search, n_neighbors = 30 ## 17:07:06 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 17:07:06 Writing NN index file to temp file /tmp/Rtmp8EdkU0/file14d802962f794 ## 17:07:06 Searching Annoy index using 1 thread, search_k = 3000 ## 17:07:07 Annoy recall = 100% ## 17:07:08 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 ## 17:07:09 Initializing from normalized Laplacian + noise (using RSpectra) ## 17:07:09 Commencing optimization for 500 epochs, with 11376 positive edges ## 17:07:11 Optimization finished ## Making plots ## Saving seurat obj ## Saving decontx counts ## Saving contamination summary 3.2 Standard gene QC to remove low quality cells Now that we have removed empty drops and ambient RNA we will perform standard QC as described in the Seurat tutorial (found here). First we will determine what our filtering criteria should be using some basic QC plots. # standard QC filtering and also remove doublets #define sample name sample_id = &#39;Day55_tutorial&#39; # Create Seurat object seurat_object &lt;- CreateSeuratObject(counts = deconx_results$decontaminated_counts, project = sample_id) ## Warning: Data is of class matrix. Coercing to dgCMatrix. # Plot relationship between reads and unique genes per cell plot_scatter1 &lt;- FeatureScatter(seurat_object, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + geom_smooth(method = &quot;lm&quot;) + NoLegend() + labs(title = &quot;Reads vs Unique Genes per Cell BEFORE Filtering&quot;) plot(plot_scatter1) ## `geom_smooth()` using formula = &#39;y ~ x&#39; # Add mitochondrial percentage seurat_object[[&quot;joined&quot;]] &lt;- JoinLayers(seurat_object[[&quot;RNA&quot;]]) ## Warning: Key &#39;rna_&#39; taken, using &#39;joined_&#39; instead seurat_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(seurat_object, pattern = &quot;^MT-&quot;) p1 &lt;- VlnPlot(seurat_object, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;)) ## Warning: Default search for &quot;data&quot; layer in &quot;RNA&quot; assay yielded no results; ## utilizing &quot;counts&quot; layer instead. p1 + plot_annotation(title = &quot;QC plots (gene level) BEFORE Filtering&quot;) Based on these QC plots we will filter the data with the following values listed in the bellow code chunk. QC paramaters might vary based on your own data so please make sure you filter your data accordingly. Here we will also remove doublets - droplets that contain two or more cells - using the package ‘doubletfinder’. ## Warning: Default search for &quot;data&quot; layer in &quot;RNA&quot; assay yielded no results; ## utilizing &quot;counts&quot; layer instead. ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 319 ## Number of edges: 6816 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.7804 ## Number of communities: 8 ## Elapsed time: 0 seconds ## [1] &quot;Creating artificial doublets for pN = 5%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 10%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 15%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 20%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 25%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 30%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## NULL ## [1] &quot;Creating 106 artificial doublets...&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Computing pANN...&quot; ## [1] &quot;Classifying doublets..&quot; Now that we have filtered the object to ensure we retain high quality data we are going to add in the isoform level information. "],["add-isoform-counts-to-seurat-object.html", "Chapter 4 Add isoform counts to Seurat object", " Chapter 4 Add isoform counts to Seurat object Now that we have 309 high-quality cells for our downstream analysis, let’s incorporate isoform-level information into our Seurat object. The first step is to read in the outputs from FLAMES, which provides isoform-level counts from Oarfish. We’ll create a new Seurat object for this data, specifically for the isoform counts, and add it as a new assay to our existing object. This setup will allow us to explore both gene-level and isoform-level counts within a single Seurat object, giving us a more comprehensive view of our data. ## Processed sample: oarfish ## Output saved to: ./output_files/counts//gene_symbol_oarfish_counts.csv We have now created a Seurat object with isoform-level count data. Users can take this object and follow similar processing steps as at the gene level 3, which might include filtering out low-quality cells and removing ambient RNA counts. In our case, we evaluated these steps and found they don’t add much value as low quality cells are already removed at the gene level and we can leverage this information rather than processing the isoform counts in the same way. Additionally, tools like DeconX and SoupX haven’t been tested on isoform count data, so we decided to exclude this analysis. Instead, we believe the most valuable approach is to append the isoform data to our gene-level Seurat object, resulting in two assays: one for gene-level and one for isoform-level data. If users have short-read data, they could similarly add it as a third assay. Since we’ve already filtered out low-quality cells based on our gene-level data, we’ll use these high-quality cells to filter our isoform data. ## An object of class Seurat ## 93557 features across 309 samples within 3 assays ## Active assay: RNA (14906 features, 2000 variable features) ## 3 layers present: counts, data, scale.data ## 2 other assays present: joined, iso ## 4 dimensional reductions calculated: pca, umap, pca_iso, umap_iso Great! We now have an object containing both assays, so we can start by plotting some of our favorite genes and isoforms. This setup gives us the flexibility to visualize gene expression on isoform UMAPs and vice versa, allowing us to integrate and explore the expression of both gene and isoform expression within single cells on the same dimensional reduction. Let’s begin by plotting VIM and TBR1. VIM is a marker of progenitor cells, while TBR1 is a marker of deep layer neurons. ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: Could not find ENST00000224237.9-VIM in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000487938.5-VIM in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000485947.1-VIM in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000469543.5-VIM in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: Could not find ENST00000224237.9-VIM in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000487938.5-VIM in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000485947.1-VIM in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000469543.5-VIM in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: Could not find ENST00000389554.8-TBR1 in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000463544.1-TBR1 in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000410035.1-TBR1 in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: No layers found matching search pattern provided ## Warning: Could not find ENST00000389554.8-TBR1 in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000463544.1-TBR1 in the default search locations, ## found in &#39;iso&#39; assay instead ## Warning: Could not find ENST00000410035.1-TBR1 in the default search locations, ## found in &#39;iso&#39; assay instead We observe that the expression of VIM and TBR genes is localized to two distinct clusters, which aligns with our expectations. This suggests that some cells remain in the progenitor/radial glial stage, while others have already begun differentiating into neurons. Furthermore, our data reveals isoform-level expression for each of our genes, including TBR1, which shows distinct isoform expression patterns across different cell populations. To plot genes and expressed isoforms from that gene simply change the ‘gene’ value to your favorite gene and run the code chunk above. Now we have a count matrix with two assays, gene and isoform. There are many avenues for analysis. We will begin with finding DE genes and isoforms. Then we identify cell types and perform trajectory analysis. finally we look into interesting isoforms unique to each cluster "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
