[["index.html", "FLAMES Single-Cell RNA-seq Tutorial Chapter 1 Introduction", " FLAMES Single-Cell RNA-seq Tutorial Sefi Prawer 2025-01-22 Chapter 1 Introduction Welcome to the FLAMES single sample tutorial! In this tutorial, we will guide you through a basic analysis of long-read single-cell RNA sequencing data. Our goal is to demonstrate how to use the output from our package, FLAMES (Tian et al., 2021), to create and process long-read single-cell data. Here we will focus on using Seurat and other very popular single cell tools for analysis and processing single cell data. Much of this analysis will follow standard short read single cell processing norms, yet with long read data we can also explore isoform-level expression in single cells. This can be very useful as we hope to demonstrate throughout this tutorial. This tutorial assumes that have; Run the sc_long_pipeline (to process a single sample) and have set your config file with these parameters set to TRUE \"bambu_isoform_identification\": [true] \"oarfish_quantification\": [true] and that you have run FLAMES to calculate the ambient RNA profile. An explanation of how to this can be found here: … [placeholder] If you wish to run through the tutorial using the data provided in the ‘data’ folder please ensure you unzip all the files. If you wish run through the tutorial using your own single sample output from FLAMES, there is no need to unzip your files please ensure you use the correct gtf. The gtf used when running FLAMES must be the same for subsequent analysis. The current version used in this tutorial can be downloaded using the following command wget https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_47/gencode.v47.annotation.gtf.gz Much of the workflow will remain the same if you decide to use other tools for quantification or isoform discovery, which FLAMES does support, but these are the tools that in our hands perform the best and what we would recommend using at this stage. This single sample tutorial will use data generated in the Clark lab from the University of Melbourne. This is small dataset of approximately 400 cells. The cells are at Day55 of a excitatory neural differentiation protocol. More information on the dataset and sequencing methodology and differentiation protocal can be found in this publication (You et al., 2023) If you find this tutorial useful please cite our work [PLACE HOLDER] If you have questions or suggestions please email sefi.prawer@unimelb.edu.au or leave a comment on this github page https://github.com/Sefi196/FLAMESv2_LR_sc_tutorial. References Tian, L., Jabbari, J. S., Thijssen, R., Gouil, Q., Amarasinghe, S. L., Voogd, O., Kariyawasam, H., Du, M. R. M., Schuster, J., Wang, C., Su, S., Dong, X., Law, C. W., Lucattini, A., Prawer, Y. D. J., Collar-Fernández, C., Chung, J. D., Naim, T., Chan, A., … Ritchie, M. E. (2021). Comprehensive characterization of single-cell full-length isoforms in human and mouse with long-read sequencing. Genome Biology, 22(1). https://doi.org/10.1186/s13059-021-02525-6 You, Y., Prawer, Y. D. J., De Paoli-Iseppi, R., Hunt, C. P. J., Parish, C. L., Shim, H., &amp; Clark, M. B. (2023). Identification of cell barcodes from long-read single-cell RNA-seq with BLAZE. Genome Biology, 24(1). https://doi.org/10.1186/s13059-023-02907-y "],["setup.html", "Chapter 2 Setup 2.1 load in required packages 2.2 Creating resource files. 2.3 Convert count matrices from Gene ID to gene Symbol", " Chapter 2 Setup 2.1 load in required packages Code #install packages if required. Note some packages require installation via bioconductor. See installation instruction for each package to ensure installation is successful. library(rtracklayer) library(Seurat) library(DropletUtils) library(gridExtra) library(data.table) library(BiocParallel) library(celda) library(SingleCellExperiment) library(DoubletFinder) library(stringr) library(cowplot) library(grid) library(patchwork) library(tidyverse) # Set working directory and create folders for output files setwd(&quot;.&quot;) # Set this to correct location dir.create(&quot;./output_files/ref_files&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/counts&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/seu_objects&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/empty_drops&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/decontx&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/QC&quot;, recursive = TRUE, showWarnings = FALSE) dir.create(&quot;./output_files/DE&quot;, recursive = TRUE, showWarnings = FALSE) 2.2 Creating resource files. To start, we’ll create a few essential files that will be used throughout the analysis. The first step is to generate a CSV file containing three key columns: ENSTID, ENSGID, and geneSymbol. This file will be used as a dictionary to rename entries in both the isoform and gene count matrices, replacing ENSGID with the corresponding gene symbol. By adopting this naming convention for ENSTID, we can easily identify the gene origin of each isoform, streamlining the interpretation and analysis of gene and isoform-level data. First lets define a helper function for this step: Code # Function to make csv naming resource make_isoform_gene_symbol_dict &lt;- function(FLAMES_gtf, reference_gtf, output_file) { # Import the first GTF file (transcripts GTF) gtf1 &lt;- import(FLAMES_gtf) gtf1_df &lt;- as.data.frame(gtf1) # Select relevant columns from the first GTF selected_columns1 &lt;- gtf1_df[, c(&quot;transcript_id&quot;, &quot;gene_id&quot;)] unique_selected_cols &lt;- unique(selected_columns1) # Import the second GTF file (reference GTF with gene symbols) gtf2 &lt;- import(reference_gtf) gtf2_df &lt;- as.data.frame(gtf2) # Select relevant columns from the second GTF selected_columns2 &lt;- gtf2_df[, c(&quot;gene_name&quot;, &quot;gene_id&quot;)] unique_gene_symbol &lt;- unique(selected_columns2) # Merge the two data frames on &#39;gene_id&#39; combined_data &lt;- merge(unique_selected_cols, unique_gene_symbol, by = &quot;gene_id&quot;, all.x = TRUE) # If &#39;gene_name&#39; is missing, replace it with &#39;gene_id&#39; combined_data$gene_symbol &lt;- ifelse(is.na(combined_data$gene_name), combined_data$gene_id, combined_data$gene_name) # Select relevant columns final_combined_data &lt;- combined_data[, c(&quot;transcript_id&quot;, &quot;gene_id&quot;, &quot;gene_symbol&quot;)] # Write to a CSV file write.csv(final_combined_data, file = file.path(&quot;output_files/ref_files&quot;, output_file), row.names = FALSE) return(final_combined_data) } Run this chunk to create the dictionary containing ENSTID, ENSGID, and geneSymbol information: Code # The FLAMES ref can be found in your selected output folder after running the Flames pipeline. FLAMES_gtf_file &lt;- &quot;./data/FLAMES_out/isoform_annotated.gtf&quot; #ensure file is unzipped reference_gtf_file &lt;- &quot;./data/gencode.v47.annotation.gtf&quot; # ensure file is unzipped output_file &lt;- &quot;isoform_gene_dict.csv&quot; # Call the helper function defined in code block above to create a dictionary containing corresponding gene information for each isoform # This may take a few minutes isoform_gene_dict &lt;- make_isoform_gene_symbol_dict(FLAMES_gtf_file, reference_gtf_file, output_file) 2.3 Convert count matrices from Gene ID to gene Symbol With the reference dictionary in place, we can now rename both our count matrix and background count matrix by converting ENSGIDs to geneSymbols. This conversion not only simplifies the interpretation of gene expression in single cells but is also necessary for some downstream tools that require gene symbols instead of ENSGIDs, such as automated cell annotation tools. Like before, lets define a generic helper function first to do this: Code convert_ENSGID_to_geneSymbol &lt;- function(gene_count_matrix_path, id_symbol_df = isoform_gene_dict, output_file, return_df = FALSE) { # Load the reference dictionary we made earlier - select gene-level cols id_symbol_df &lt;- id_symbol_df %&gt;% dplyr::select(gene_id, gene_symbol) # Load the data object with ENSGID row names gene_count_matrix &lt;- read.csv(gene_count_matrix_path, header = TRUE) colnames(gene_count_matrix)[1] &lt;- &quot;gene_id&quot; # Replace ENSGIDs with gene symbols in original flames gene-level count matrix formatted_gene_count_matrix &lt;- gene_count_matrix %&gt;% merge(id_symbol_df, by.x = &#39;gene_id&#39;, by.y = &#39;gene_id&#39;) %&gt;% # Add gene symbol information distinct(gene_symbol, .keep_all = TRUE) %&gt;% # Remove duplicates based on gene symbol select(-gene_id) %&gt;% # Remove the ENSGID column column_to_rownames(var = &quot;gene_symbol&quot;) # use the gene symbols we added as rownames # Write out the processed data frame write.csv(formatted_gene_count_matrix, output_file, row.names = TRUE) # Return the processed count matrix for further use if needed if(return_df){ return(formatted_gene_count_matrix) } } Run the chunk below to format gene-level count matrices for background and FLAMES data using the helper function from above: Code # convert Gene_id to gene symbol for gene counts convert_ENSGID_to_geneSymbol( gene_count_matrix_path = &quot;./data/FLAMES_out/gene_count.csv&quot;, output_file = &quot;./output_files/counts/geneSymbol_gene_count.csv&quot; ) # convert Gene_id to gene symbol for background counts convert_ENSGID_to_geneSymbol( gene_count_matrix_path = &quot;./data/background/gene_count.csv&quot;, output_file = &quot;./output_files/counts/background_geneSymbol_gene_count.csv&quot; ) Now we have the files we need to begin cleaning our data and removing unwanted noise. "],["removing-sources-of-unwanted-noise-from-the-single-cell-dataset.html", "Chapter 3 Removing sources of unwanted noise from the single cell dataset 3.1 Empty droplets 3.2 Removing ambient RNA contamination 3.3 Standard gene QC to remove low quality cells", " Chapter 3 Removing sources of unwanted noise from the single cell dataset Now we will do some initial prepossessing of single cell data to ensure we have some high quality data. This will involve 3 main steps Removing empty droplets - droplets that do not contain true cells. Removing ambient RNA contamination - optional Removing low quality cells that 3.1 Empty droplets This function removes empty droplets, a critical step to ensure that only true cells are retained for analysis. In short-read analysis using CellRanger, this process is automated, and empty droplets are removed by the software. However, FLAMES does not perform this step automatically, so it must be done manually. The function provided here not only removes empty droplets but also generates general QC metrics, enabling users to assess the reasonableness of the number of cells removed. Code ### notes: This fucnion should be refactored and cleaed up. Its very long and complex. perform_empty_drops_analysis &lt;- function(output_path, gene_count_file, empty_drops_file, output_seurat_file, fdr_threshold = 0.001, lower = 100) { # Load required libraries # Read in data df &lt;- read.csv(gene_count_file, row.names = 1) df_emptydrops &lt;- read.csv(empty_drops_file, row.names = 1) # Combine the dataframes by row names combined_df &lt;- merge(df, df_emptydrops, by = &quot;row.names&quot;, all = TRUE) rownames(combined_df) &lt;- combined_df[, 1] combined_df[, 1] &lt;- NULL combined_df[is.na(combined_df)] &lt;- 0 # Perform standard pre-processing before empty drops analysis seurat_obj &lt;- CreateSeuratObject(counts = df, project = &quot;Day_55&quot;, min.features = 20) seurat_obj[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(seurat_obj, pattern = &quot;^MT-&quot;) VlnPlot(seurat_obj, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;), ncol = 3) #seurat_obj &lt;- subset(seurat_obj, subset = nFeature_RNA &gt; 10 &amp; nFeature_RNA &lt; 100000 &amp; percent.mt &lt; 100) seurat_obj &lt;- NormalizeData(seurat_obj, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) seurat_obj &lt;- FindVariableFeatures(seurat_obj, selection.method = &quot;vst&quot;, nfeatures = 2000) all.genes &lt;- rownames(seurat_obj) seurat_obj &lt;- ScaleData(seurat_obj, features = all.genes) seurat_obj &lt;- RunPCA(seurat_obj, features = VariableFeatures(object = seurat_obj)) ElbowPlot(seurat_obj) seurat_obj &lt;- FindNeighbors(seurat_obj, dims = 1:10) seurat_obj &lt;- FindClusters(seurat_obj, resolution = 0.5) seurat_obj &lt;- RunUMAP(seurat_obj, dims = 1:10) DimPlot(seurat_obj, reduction = &quot;umap&quot;) # Define function to make dgCMatrix from combined counts makedgcmatrix &lt;- function(count.matrix) { seurat_object &lt;- CreateSeuratObject(counts = count.matrix, project = &quot;singlecell&quot;) list(seurat_object[[&quot;RNA&quot;]]$counts) } # Empty Drops Analysis combined_df[] &lt;- lapply(combined_df, function(x) as.numeric(as.character(x))) outs.ddcmatrix &lt;- makedgcmatrix(combined_df)[[1]] br.out &lt;- DropletUtils::barcodeRanks(outs.ddcmatrix) e.out &lt;- emptyDrops(outs.ddcmatrix, lower = lower, niters = 10000, test.ambient = TRUE, BPPARAM = SerialParam()) is.cell &lt;- e.out$FDR &lt; fdr_threshold # Create a dataframe with FDR of TRUE cells is.true.cell_CR &lt;- as.data.frame(e.out@listData[[&quot;FDR&quot;]], e.out@rownames) is.true.cell_CR &lt;- is.true.cell_CR %&gt;% filter(is.true.cell_CR$`e.out@listData[[&quot;FDR&quot;]]` &lt;= fdr_threshold) is.true.cell_CR &lt;- tibble::rownames_to_column(is.true.cell_CR, &quot;cell_id&quot;) # Function for retrieving the Seurat cells and cluster in dataframe overlap_true_cell &lt;- function(seurat_object) { seurat_cluster.df &lt;- as.data.frame(seurat_object$seurat_clusters) seurat_cluster.df &lt;- tibble::rownames_to_column(seurat_cluster.df, &quot;cell_id&quot;) seurat_cluster.df } # Obtain cluster dataframe from Seurat object overlap_CR &lt;- overlap_true_cell(seurat_obj) # Check overlaps between Seurat object and true cells summary(overlap_CR$cell_id %in% is.true.cell_CR$cell_id) # Function to add metadata to Seurat object True.cells &lt;- function(e.out) { cells &lt;- as.data.frame(e.out@rownames) fdr &lt;- as.data.frame(e.out$FDR) T.F.cells &lt;- cbind(cells, fdr) T.F.cells &lt;- data.frame(T.F.cells[,-1], row.names = T.F.cells[,1]) setnames(T.F.cells, c(&#39;FDR&#39;)) T.F.cells %&gt;% mutate(FDR = case_when(FDR &lt; fdr_threshold ~ &quot;Cells&quot;, FDR &gt; fdr_threshold ~ &quot;Empty_drops&quot;)) } cells_CR &lt;- True.cells(e.out) seurat_obj &lt;- AddMetaData(seurat_obj, metadata = cells_CR, col.name = &#39;is.cell&#39;) # Plot Empty drops on Gene UMAP # Create a ggplot object rankplot &lt;- ggplot(br.out, aes(x = rank, y = total)) + geom_point() + scale_x_log10() + scale_y_log10() + labs(x = &quot;Rank&quot;, y = &quot;Total&quot;) + geom_line(aes(y = fitted), color = &quot;red&quot;, linetype = &quot;solid&quot;) + geom_hline(yintercept = metadata(br.out)$knee, color = &quot;dodgerblue&quot;, linetype = &quot;dashed&quot;) + geom_hline(yintercept = metadata(br.out)$inflection, color = &quot;forestgreen&quot;, linetype = &quot;dashed&quot;) + theme( legend.position = &quot;bottomleft&quot; ) + guides(colour = guide_legend(override.aes = list(linetype = c(&quot;dashed&quot;, &quot;dashed&quot;)))) + annotate(&quot;text&quot;, x = Inf, y = metadata(br.out)$knee, label = &quot;knee&quot;, color = &quot;dodgerblue&quot;, vjust = -1, hjust = 1) + annotate(&quot;text&quot;, x = Inf, y = metadata(br.out)$inflection, label = &quot;inflection&quot;, color = &quot;forestgreen&quot;, vjust = -1, hjust = 1) # Summary table -&gt; may want to add a bunch of other summary metrics # Extract counts with checks for NULL cell_counts &lt;- as.data.frame(table(seurat_obj@meta.data$is.cell)) count_true_cells &lt;- ifelse(length(cell_counts$Freq[cell_counts$Var1 == &quot;Cells&quot;]) &gt; 0, cell_counts$Freq[cell_counts$Var1 == &quot;Cells&quot;], 0) count_empty_drops &lt;- ifelse(length(cell_counts$Freq[cell_counts$Var1 == &quot;Empty_drops&quot;]) &gt; 0, cell_counts$Freq[cell_counts$Var1 == &quot;Empty_drops&quot;], 0) # Create the summary table summary_table &lt;- data.frame( Description = c(&#39;fdr&#39;, &#39;lower Counts&#39;, &#39;number of true cells&#39;, &#39;number of empty drops&#39;), Value = c(fdr_threshold, lower, count_true_cells, count_empty_drops) ) summary_grob &lt;- tableGrob(summary_table, rows = NULL, cols = NULL) # Create the combined plot plot1 &lt;- grid.arrange( rankplot, DimPlot(seurat_obj, reduction = &quot;umap&quot;, group.by = &#39;is.cell&#39;) + labs(color = &quot;is.cell&quot;, title = &#39;Seurat Object&#39;) + theme(text = element_text(size = 10), plot.background = element_rect(fill = &quot;white&quot;)), FeaturePlot(seurat_obj, features = &quot;nCount_RNA&quot;) + theme(plot.background = element_rect(fill = &quot;white&quot;)), FeaturePlot(seurat_obj, features = &quot;nFeature_RNA&quot;) + theme(plot.background = element_rect(fill = &quot;white&quot;)), summary_grob, ncol = 2, top = textGrob(&#39;Empty drops vs real cells&#39;) ) #output the plot and summary stats pdf(file = file.path(output_path, paste0(output_seurat_file, &quot;_plots.pdf&quot;)), width = 6, height = 6, bg = &quot;white&quot;) plot(plot1) dev.off() # Subset the Seurat object to remove cells marked as empty drops seurat_obj_rm_empty &lt;- subset(seurat_obj, subset = is.cell == &#39;Cells&#39;) #save the seurat objects saveRDS(seurat_obj, file = file.path(output_path, paste0(&quot;with_empty_&quot;, output_seurat_file, &quot;.rds&quot;))) saveRDS(seurat_obj_rm_empty, file = file.path(output_path, paste0(&quot;removed_empty_&quot;, output_seurat_file, &quot;.rds&quot;))) } ##################### # usage perform_empty_drops_analysis( gene_count_file = &quot;./output_files/counts/geneSymbol_gene_count.csv&quot;, empty_drops_file = &quot;./output_files/counts/background_geneSymbol_gene_count.csv&quot;, output_path = &quot;./output_files/empty_drops/&quot;, output_seurat_file = &quot;Day55&quot;, fdr_threshold = 0.001, # see droplet utils if you want to adjust these params lower = 500 # see droplet utils if you want to adjust these params ) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 344 ## Number of edges: 7209 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8510 ## Number of communities: 7 ## Elapsed time: 0 seconds 3.2 Removing ambient RNA contamination Now we will remove ambient RNA contamination using decontX (or SoupX). This step is optional, and it’s up to the user to decide whether it’s necessary. In this case, the barcode rank plot (Figure 3.1) shows a clear distinction between true barcodes and background barcodes, suggesting that ambient RNA contamination may not significantly contribute to noise in this dataset. However, we’ll demonstrate how to run this step in case your barcode rank plot is noisier and contamination is a concern. if users wish to skip this step take the ‘seurat_obj_rm_empty’ object and proceed to standard gene QC step. Code knitr::include_graphics(&quot;images/knee_plot.png&quot;) Figure 3.1: Barcode rank plot produced by FLAMES. Code # Function to run decontX on a single Seurat object run_decontX &lt;- function(seurat_obj_path, background_counts_path, sample_id) { # Load the Seurat object seurat_obj &lt;- readRDS(seurat_obj_path) filtered_counts &lt;- as.matrix(GetAssayData(seurat_obj, layer = &quot;counts&quot;)) # Read background counts raw_counts &lt;- as.matrix(read.csv(background_counts_path, row.names = 1)) # Get cluster info from Seurat object cluster_info &lt;- setNames(seurat_obj$seurat_clusters, colnames(seurat_obj)) # Find common genes common_genes &lt;- intersect(rownames(filtered_counts), rownames(raw_counts)) raw_counts &lt;- raw_counts[common_genes, ] filtered_counts &lt;- filtered_counts[common_genes, ] # Create SingleCellExperiment objects sce_raw &lt;- SingleCellExperiment(list(counts = raw_counts)) sce_object &lt;- SingleCellExperiment(list(counts = filtered_counts)) # Run decontX with background sce &lt;- decontX(sce_object, z = cluster_info, background = sce_raw) # Summarize contamination levels contamination_summary &lt;- as.array(summary(sce$decontX_contamination)) print(contamination_summary) # Add contamination levels to Seurat object metadata contamination &lt;- colData(sce)$decontX_contamination seurat_obj &lt;- AddMetaData(seurat_obj, metadata = contamination, col.name = &quot;decontX_contamination&quot;) # Extract decontaminated counts from SCE object decontaminated_counts &lt;- assay(sce, &quot;decontXcounts&quot;) decontaminated_counts &lt;- as.matrix(decontaminated_counts) # Create a new assay with decontaminated counts and add it to Seurat object new_assay &lt;- CreateAssayObject(counts = decontaminated_counts) seurat_obj[[&quot;decontaminated&quot;]] &lt;- new_assay clusters_umap_orig &lt;- DimPlot( object = seurat_obj, group.by = &quot;seurat_clusters&quot;, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5 ) + labs(title = &quot;UMAP with Clusters&quot;) # Plot UMAP with contamination levels contamination_umap &lt;- FeaturePlot( object = seurat_obj, features = &quot;decontX_contamination&quot;, reduction = &quot;umap&quot; ) + labs(title = &quot;decontX contamination value&quot;) DefaultAssay(seurat_obj) &lt;- &quot;decontaminated&quot; # Normalization, variable feature selection, and scaling seurat_obj &lt;- NormalizeData(seurat_obj) seurat_obj &lt;- FindVariableFeatures(seurat_obj) seurat_obj &lt;- ScaleData(seurat_obj) # PCA and clustering seurat_obj &lt;- RunPCA(seurat_obj) seurat_obj &lt;- FindNeighbors(seurat_obj, dims = 1:20) seurat_obj &lt;- FindClusters(seurat_obj, resolution = 0.7) # UMAP seurat_obj &lt;- RunUMAP(seurat_obj, dims = 1:20) # Plot UMAP with updated clusters clusters_umap &lt;- DimPlot( object = seurat_obj, group.by = &quot;seurat_clusters&quot;, reduction = &quot;umap&quot;, label = TRUE, pt.size = 0.5 ) + labs(title = &quot;UMAP with Corrected Clusters&quot;) # Combine plots combined_umap &lt;- cowplot::plot_grid(clusters_umap_orig, contamination_umap, clusters_umap, ncol = 2) cat(&quot;Making plots\\n&quot;) # Save the combined plot as a PDF #pdf(file = paste0(sample_id, &quot;_decontx_plots.pdf&quot;), width = 18, height = 6) print(combined_umap) #dev.off() cat(&quot;Saving seurat obj\\n&quot;) # Save the Seurat object saveRDS(seurat_obj, file = paste0(sample_id, &quot;_decontx_seurat_obj.rds&quot;)) # Save decontaminated counts and contamination summary cat(&quot;Saving decontx counts\\n&quot;) write.csv(decontaminated_counts, paste0(sample_id, &quot;_decontx_counts.csv&quot;)) # Print a message indicating that the contamination summary is being saved cat(&quot;Saving contamination summary\\n&quot;) # Ensure contamination_summary is a data frame contamination_summary_df &lt;- as.data.frame(contamination_summary) write.table(contamination_summary_df, file = paste0(sample_id, &quot;_contamination_summary.txt&quot;)) # Optionally return the results return(list(seurat_obj = seurat_obj, decontaminated_counts = decontaminated_counts, contamination_summary = contamination_summary)) } # Run decontX on the input Seurat object and background counts file deconx_results &lt;- run_decontX(&quot;./output_files/empty_drops/removed_empty_Day55.rds&quot;, &quot;./output_files/counts/background_geneSymbol_gene_count.csv&quot;, &quot;./output_files/decontx//Day55&quot;) ## -------------------------------------------------- ## Starting DecontX ## -------------------------------------------------- ## Thu Jan 9 16:57:25 2025 .. Analyzing all cells ## Thu Jan 9 16:57:25 2025 .... Converting to sparse matrix ## Thu Jan 9 16:57:25 2025 .... Generating UMAP ## Thu Jan 9 16:57:31 2025 .... Estimating contamination ## Thu Jan 9 16:57:31 2025 ...... Completed iteration: 10 | converge: 0.02483 ## Thu Jan 9 16:57:31 2025 ...... Completed iteration: 20 | converge: 0.009197 ## Thu Jan 9 16:57:32 2025 ...... Completed iteration: 30 | converge: 0.005009 ## Thu Jan 9 16:57:32 2025 ...... Completed iteration: 40 | converge: 0.003423 ## Thu Jan 9 16:57:32 2025 ...... Completed iteration: 50 | converge: 0.00254 ## Thu Jan 9 16:57:32 2025 ...... Completed iteration: 60 | converge: 0.002116 ## Thu Jan 9 16:57:33 2025 ...... Completed iteration: 70 | converge: 0.001571 ## Thu Jan 9 16:57:33 2025 ...... Completed iteration: 80 | converge: 0.00118 ## Thu Jan 9 16:57:33 2025 ...... Completed iteration: 87 | converge: 0.0009944 ## Thu Jan 9 16:57:33 2025 .. Calculating final decontaminated matrix ## -------------------------------------------------- ## Completed DecontX. Total time: 8.46105 secs ## -------------------------------------------------- ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.001336 0.040294 0.065590 0.095857 0.113042 0.810218 ## Centering and scaling data matrix ## PC_ 1 ## Positive: VIM, ADGRV1, GLI3, DOK5, CACHD1, DACH1, SMC4, SHROOM3, RCN1, PARD3 ## FBXL7, PHGDH, HMGA2, HMGN2, ID3, ENSG00000286757, ID4, LRIG1, SOX2, NBPF14 ## LTBP1, YAP1, HMGB2, ZFP36L1, SLC35F1, TRIM59-IFT80, SMC2, TUBA1B, COL4A5, LEF1 ## Negative: NRXN1, PTPRD, MYT1L, LRRC7, ANK3, MAPT, DCC, UNC79, PTPRN2, SLC4A10 ## KCNH7, ENOX1, ANKS1B, EPHA5, RALYL, PHACTR3, CNTNAP2, RUNX1T1, NBEA, CACNA1E ## THSD7A, CACNA1A, GRIA2, NSG2, LINC01122, NELL2, RBFOX1, CELF4, NFASC, NEUROD6 ## PC_ 2 ## Positive: HECW1, LHX2, MPPED2, IVNS1ABP, LEF1, SEZ6L, SFRP1, ENSG00000251680, CADPS, ROBO2 ## ADAMTS19, B3GAT2, LRRC3B, FUT9, LMNB1, SNCAIP, TMTC1, NKAIN3, LTBP1, FOXP1 ## NRG1, STOX1, SV2C, PANTR1, PREX2, SEMA3C, ITGA2, GLI3, UHRF1, ENSG00000301688 ## Negative: SLIT3, RSPO2, RBM47, DYNLRB2-AS1, PRTG, LMX1A, PCP4, WLS, ENSG00000287949, MAF ## GJA1, FYB2, RSPO1, PLS3, MIR4435-2HG, NR3C2, RBM20, ZIC1, KRT8, LGI1 ## EYA4, KRT18, ENSG00000241231, TPBG, TTR, OTX2, WNT2B, PTCHD1-AS, DLK1, IFITM1 ## PC_ 3 ## Positive: NHLH1, EBF2, SLC22A23, DISP3, ENSG00000285755, CECR2, LINC01830, FRMD4B, ARL4D, BHLHE22 ## ENC1, RASGEF1B, ENSG00000310169, BHLHE22-AS1, PPP1R17, CRABP1, CHD7, FAM149A, RBFOX3, NFIA-AS2 ## HYCC1, LMO1, NPTX1, HUNK, UNC5A, SERINC5, PGAP1, P2RX3, PRDM8, ENSG00000231252 ## Negative: OPCML, NAV3, FRMD4A, GRIN2B, XKR4, KIRREL3, NALF1, KCNMA1, CNTN1, NAV2 ## GRIK3, CALN1, LRP1B, SMARCA2, DGKI, NRG3, SYN3, PRKG1, MACROD2, GAREM1 ## SLCO3A1, MDGA2, SYT13, ATXN1, ULK4, GRID2, GABBR2, ZC3H12B, LMO3, RIMS1 ## PC_ 4 ## Positive: ZFPM2, ZFPM2-AS1, ZEB2, MYO5B, CSRP2, ZBTB18, PLXDC2, ST18, NEUROD6, CAP2 ## NELL2, ENSG00000307341, PDE1A, GAREM1, ADAMTS3, FLRT2, DLGAP1, EPHA7, NEUROD2, GRIA3 ## CTTNBP2, SLC24A2, PDGFC, DMD, SYNDIG1, CORO2B, CENPE, KCNH7, SDK1, THSD7A ## Negative: COPG2, PBX3, GAD2, COPG2IT1, VGF, ENSG00000259460, KCNMB2, MEIS2, KCNMB2-AS1, LINC01414 ## SIX3, ENSG00000270953, MEST, ENSG00000298285, SPRY4-AS1, PCDH7, DLX1, DLX6-AS1, SORCS3, SIX3-AS1 ## GRM7, KCNH1, CDH8, DLX2, SGCD, MDGA2, SLC35F3, NRXN3, GAD1, MIR325HG ## PC_ 5 ## Positive: CDC20, CCNB1, PLK1, UBE2S, DLGAP5, KNSTRN, CCNB2, ARL6IP1, TPX2, AURKA ## NEK2, PTTG1, CDKN3, TROAP, GTSE1, UBE2C, BUB1, SGO2, KIF20A, CEP55 ## PRR11, CENPE, GAS2L3, CDCA8, ASPM, PIMREG, ARHGAP11A, BIRC5, NDE1, DEPDC1 ## Negative: HECW1, DPP10, GPC6, LINC03051, BMPR1B, SLC1A3, SPIDR, DMD, ZFPM2, TMTC1 ## SDK1, ADAMTS6, ADAMTS19, ENSG00000301688, HDAC9, MEGF11, PVT1, MCM4, LRP4, RHBDL3 ## FREM2, TAFA1, STOX1, LAMA1, RORA, NCKAP5, HELLS, PDGFC, STOX2, KHDRBS2 ## Computing nearest neighbor graph ## Computing SNN ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 339 ## Number of edges: 7342 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.8177 ## Number of communities: 8 ## Elapsed time: 0 seconds ## 16:57:34 UMAP embedding parameters a = 0.9922 b = 1.112 ## 16:57:34 Read 339 rows and found 20 numeric columns ## 16:57:34 Using Annoy for neighbor search, n_neighbors = 30 ## 16:57:34 Building Annoy index with metric = cosine, n_trees = 50 ## 0% 10 20 30 40 50 60 70 80 90 100% ## [----|----|----|----|----|----|----|----|----|----| ## **************************************************| ## 16:57:35 Writing NN index file to temp file /tmp/RtmpaSrlUm/file5e84c2f90d2 ## 16:57:35 Searching Annoy index using 1 thread, search_k = 3000 ## 16:57:35 Annoy recall = 100% ## 16:57:35 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 ## 16:57:37 Initializing from normalized Laplacian + noise (using RSpectra) ## 16:57:37 Commencing optimization for 500 epochs, with 11376 positive edges ## 16:57:38 Optimization finished ## Making plots ## Saving seurat obj ## Saving decontx counts ## Saving contamination summary 3.3 Standard gene QC to remove low quality cells Now that we have removed empty drops and ambient RNA we will perform standard QC as described in the Seurat tutorial (found here). First we will determine what our filtering criteria should be using some basic QC plots. Code # standard QC filtering and also remove doublets #define sample name sample_id = &#39;Day55_tutorial&#39; # Create Seurat object seurat_object &lt;- CreateSeuratObject(counts = deconx_results$decontaminated_counts, project = sample_id) ## Warning: Data is of class matrix. Coercing to dgCMatrix. Code # Plot relationship between reads and unique genes per cell plot_scatter1 &lt;- FeatureScatter(seurat_object, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + geom_smooth(method = &quot;lm&quot;) + NoLegend() + labs(title = &quot;Reads vs Unique Genes per Cell BEFORE Filtering&quot;) plot(plot_scatter1) ## `geom_smooth()` using formula = &#39;y ~ x&#39; Code # Add mitochondrial percentage seurat_object[[&quot;joined&quot;]] &lt;- JoinLayers(seurat_object[[&quot;RNA&quot;]]) ## Warning: Key &#39;rna_&#39; taken, using &#39;joined_&#39; instead Code seurat_object[[&quot;percent.mt&quot;]] &lt;- PercentageFeatureSet(seurat_object, pattern = &quot;^MT-&quot;) p1 &lt;- VlnPlot(seurat_object, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;)) ## Warning: Default search for &quot;data&quot; layer in &quot;RNA&quot; assay yielded no results; utilizing &quot;counts&quot; layer instead. Code p1 + plot_annotation(title = &quot;QC plots (gene level) BEFORE Filtering&quot;) Based on these QC plots we will filter the data with the following values listed in the bellow code chunk. QC paramaters might vary based on your own data so please make sure you filter your data accordingly. Here we will also remove doublets - droplets that contain two or more cells - using the package ‘doubletfinder’. Code # Filter cells based on feature and count thresholds ## define the filtering params - (change these based on your data) max.features = 10000 min.features = 1000 min.counts = 800 max.counts = 100000 MT = 10 npc = 15 doublet_rate = 0.039 cluster_res = 0.9 #now we filter the seurat object based on the QC params listed above filt_seurat_object &lt;- subset(seurat_object, subset = nFeature_RNA &gt; min.features &amp; nFeature_RNA &lt; max.features &amp; percent.mt &lt; MT &amp; nCount_RNA &lt; max.counts &amp; nCount_RNA &gt; min.counts) # Plot quality metrics after filtering p2 &lt;- VlnPlot(filt_seurat_object, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;, &quot;percent.mt&quot;)) ## Warning: Default search for &quot;data&quot; layer in &quot;RNA&quot; assay yielded no results; utilizing &quot;counts&quot; layer instead. Code p2 + plot_annotation(title = &quot;QC metrics gene level AFTER Filtering&quot;) Code # Normalize data filt_seurat_object &lt;- NormalizeData(filt_seurat_object, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000) # Identify highly variable features filt_seurat_object &lt;- FindVariableFeatures(filt_seurat_object, selection.method = &quot;vst&quot;, nfeatures = 2000) # Apply linear transformation all_genes &lt;- rownames(filt_seurat_object) filt_seurat_object &lt;- ScaleData(filt_seurat_object, features = all_genes) # Perform PCA filt_seurat_object &lt;- RunPCA(filt_seurat_object, features = VariableFeatures(object = filt_seurat_object)) # Cluster cells filt_seurat_object &lt;- FindNeighbors(filt_seurat_object, dims = 1:npc) filt_seurat_object &lt;- FindClusters(filt_seurat_object, resolution = cluster_res) ## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck ## ## Number of nodes: 319 ## Number of edges: 6816 ## ## Running Louvain algorithm... ## Maximum modularity in 10 random starts: 0.7804 ## Number of communities: 8 ## Elapsed time: 0 seconds Code # Perform UMAP filt_seurat_object &lt;- RunUMAP(filt_seurat_object, dims = 1:npc) ### Filter out doublets (remember to modify doublet rate if samples have variable target cells) ## pK Identification (no ground-truth) sweep.res.list_pbmc &lt;- paramSweep(filt_seurat_object, PCs = 1:npc, sct = FALSE) ## [1] &quot;Creating artificial doublets for pN = 5%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 10%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 15%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 20%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 25%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; ## [1] &quot;Creating artificial doublets for pN = 30%&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Defining neighborhoods...&quot; ## [1] &quot;Computing pANN across all pK...&quot; ## [1] &quot;pK = 0.03...&quot; ## [1] &quot;pK = 0.04...&quot; ## [1] &quot;pK = 0.05...&quot; ## [1] &quot;pK = 0.06...&quot; ## [1] &quot;pK = 0.07...&quot; ## [1] &quot;pK = 0.08...&quot; ## [1] &quot;pK = 0.09...&quot; ## [1] &quot;pK = 0.1...&quot; ## [1] &quot;pK = 0.11...&quot; ## [1] &quot;pK = 0.12...&quot; ## [1] &quot;pK = 0.13...&quot; ## [1] &quot;pK = 0.14...&quot; ## [1] &quot;pK = 0.15...&quot; ## [1] &quot;pK = 0.16...&quot; ## [1] &quot;pK = 0.17...&quot; ## [1] &quot;pK = 0.18...&quot; ## [1] &quot;pK = 0.19...&quot; ## [1] &quot;pK = 0.2...&quot; ## [1] &quot;pK = 0.21...&quot; ## [1] &quot;pK = 0.22...&quot; ## [1] &quot;pK = 0.23...&quot; ## [1] &quot;pK = 0.24...&quot; ## [1] &quot;pK = 0.25...&quot; ## [1] &quot;pK = 0.26...&quot; ## [1] &quot;pK = 0.27...&quot; ## [1] &quot;pK = 0.28...&quot; ## [1] &quot;pK = 0.29...&quot; ## [1] &quot;pK = 0.3...&quot; Code sweep.stats_pbmc &lt;- summarizeSweep(sweep.res.list_pbmc, GT = FALSE) bcmvn_pbmc &lt;- find.pK(sweep.stats_pbmc) ## NULL Code ##### pK &lt;- bcmvn_pbmc %&gt;% filter(BCmetric == max(BCmetric)) %&gt;% dplyr::select(pK) pK &lt;- as.numeric(as.character(pK[[1]])) ## Homotypic Doublet Proportion Estimate annotations &lt;- filt_seurat_object@meta.data$seurat_clusters homotypic.prop &lt;- modelHomotypic(annotations) nExp_poi &lt;- round(doublet_rate * nrow(filt_seurat_object@meta.data)) nExp_poi.adj &lt;- round(nExp_poi * (1 - homotypic.prop)) # Run doubletFinder filt_seurat_object &lt;- doubletFinder(filt_seurat_object, PCs = 1:npc, pN = 0.25, pK = pK, nExp = nExp_poi.adj, reuse.pANN = FALSE, sct = FALSE) ## [1] &quot;Creating 106 artificial doublets...&quot; ## [1] &quot;Creating Seurat object...&quot; ## [1] &quot;Normalizing Seurat object...&quot; ## [1] &quot;Finding variable genes...&quot; ## [1] &quot;Scaling data...&quot; ## [1] &quot;Running PCA...&quot; ## [1] &quot;Calculating PC distance matrix...&quot; ## [1] &quot;Computing pANN...&quot; ## [1] &quot;Classifying doublets..&quot; Code colnames(filt_seurat_object@meta.data) &lt;- sub(&quot;DF.classifications_.*$&quot;, &quot;DF.classifications&quot;, colnames(filt_seurat_object@meta.data)) # Summary doublets statsDoublets &lt;- filt_seurat_object@meta.data %&gt;% group_by(DF.classifications) %&gt;% summarize(Median_nCount_RNA = median(nCount_RNA), Median_nFeature_RNA = median(nFeature_RNA), Count = n()) ###Save the seurat object with doublets listed filt_seurat_object_doublets &lt;- filt_seurat_object filt_seurat_object &lt;- subset(filt_seurat_object, subset = DF.classifications == &#39;Singlet&#39;) # figures ggplot_list &lt;- list( ElbowPlot(filt_seurat_object) + labs(title = &#39;SD explained by each PC&#39;) + theme(text = element_text(size = 10)), FeatureScatter(filt_seurat_object, feature1 = &quot;nCount_RNA&quot;, feature2 = &quot;nFeature_RNA&quot;) + geom_smooth(method = &quot;lm&quot;) + NoLegend() + labs(title = &quot;Association between reads and \\nunique genes per cell AFTER filtering&quot;), DimPlot(filt_seurat_object, reduction = &quot;umap&quot;) + labs(color = &quot;Cluster \\n(from PCA)&quot;, title = &#39;&#39;) + theme(text = element_text(size = 10)), FeaturePlot(filt_seurat_object, reduction = &quot;umap&quot;, features = &#39;nCount_RNA&#39;) + labs(color = &quot;UMI count&quot;, title = &#39;&#39;) + theme(text = element_text(size = 10)), FeaturePlot(filt_seurat_object, reduction = &quot;umap&quot;, features = &#39;nFeature_RNA&#39;) + labs(color = str_wrap(&quot;Feature count (gene)&quot;, 15), title = &#39;&#39;) + theme(text = element_text(size = 10)), p2 ) combined_plots &lt;- plot_grid(plotlist = ggplot_list, ncol = 2) plot(combined_plots) Code plot(DimPlot(filt_seurat_object_doublets, reduction = &#39;umap&#39;, group.by = &quot;DF.classifications&quot;)) Code tbl_sts1 &lt;- tableGrob(statsDoublets) grid.newpage() grid.draw(tbl_sts1) Code stats_sumary &lt;- rbind(&quot;Sample ID&quot; = sample_id, &quot;Cells_before_filter&quot; = dim(seurat_object)[2], &quot;Cells_after_filter&quot; = dim(filt_seurat_object)[2], &quot;Median Feature per Cell before filter&quot; = median(seurat_object$nFeature_RNA), &quot;Median Reads per Gene before filter&quot; = median(seurat_object$nCount_RNA), &quot;Median Feature per Cell&quot; = median(filt_seurat_object$nFeature_RNA), &quot;Median Reads per Gene&quot; = median(filt_seurat_object$nCount_RNA), &quot;Max Features&quot; = max.features, &quot;Min Features&quot; = min.features, &quot;Min Counts&quot; = min.counts, &quot;Max Counts&quot; = max.counts, &quot;MT Percentage&quot; = MT, &quot;NPCs&quot; = npc, &quot;Median Percent MT before Filter&quot; = median(seurat_object@meta.data[[&quot;percent.mt&quot;]]), &quot;Median Percent MT after Filter&quot; = median(filt_seurat_object@meta.data[[&quot;percent.mt&quot;]]) ) tbl_sts2 &lt;- tableGrob(stats_sumary) grid.newpage() grid.draw(tbl_sts2) Code #save files saveRDS(filt_seurat_object, file = paste0(&quot;./output_files/QC/&quot;, sample_id, &quot;_umap_object.rds&quot;)) saveRDS(filt_seurat_object_doublets, file = paste0(&quot;./output_files/QC/&quot;,sample_id, &quot;_with_doublets_umap_object.rds&quot;)) write.table(stats_sumary, file = paste0(&quot;./output_files/QC/&quot;, sample_id, &quot;_stats.csv&quot;)) Now that we have filtered the object to ensure we retain high quality data we are going to add in the isoform level information. "],["add-isoform-counts-to-seurat-object.html", "Chapter 4 Add isoform counts to Seurat object 4.1 Create a Seurat object with isoform expression data 4.2 Filter the new Seurat object based on gene level information 4.3 Add the isoform assay to the Seurat object", " Chapter 4 Add isoform counts to Seurat object 4.1 Create a Seurat object with isoform expression data Now that we have 309 high-quality cells for our downstream analysis, let’s incorporate isoform-level information into our Seurat object. The first step is to read in the outputs from FLAMES, which provides isoform-level counts from Oarfish. We’ll create a new Seurat object for this data, specifically for the isoform counts, and add it as a new assay to our existing object. This setup will allow us to explore both gene-level and isoform-level counts within a single Seurat object, giving us a more comprehensive view of our data. Code #This function reads in Oarfish count files and creates a csv file of count data. The function also appends the gene symbol to the ENSTID process_oarfish_files_to_counts_matrix &lt;- function(flames_output_folder, sample_name, output_dir) { # Read in the resource table (transcript_id, gene_id, gene_symbol) # Define the file paths based on the sample name count_matrix_path &lt;- file.path(flames_output_folder, paste0(sample_name, &quot;.count.mtx&quot;)) barcodes_path &lt;- file.path(flames_output_folder, paste0(sample_name, &quot;.barcodes.txt&quot;)) features_path &lt;- file.path(flames_output_folder, paste0(sample_name, &quot;.features.txt&quot;)) # Read the data counts &lt;- readMM(count_matrix_path) barcodes &lt;- readLines(barcodes_path) features &lt;- read.delim(features_path, header = FALSE) # Transpose the matrix for Seurat compatibility counts &lt;- t(counts) # Set row and column names rownames(counts) &lt;- features$V1 colnames(counts) &lt;- barcodes # Convert to a data frame counts_df &lt;- as.data.frame(counts) # Add transcript_id as the first column counts_df$transcript_id &lt;- rownames(counts_df) counts_df &lt;- counts_df[, c(ncol(counts_df), 1:(ncol(counts_df)-1))] # Merge with the resource table to add gene symbols df_genesymbol &lt;- counts_df %&gt;% left_join(isoform_gene_dict, by = &quot;transcript_id&quot;) # Remove the gene_id column and reorder the columns df_genesymbol$gene_id &lt;- NULL df_genesymbol &lt;- df_genesymbol[, c(ncol(df_genesymbol), 1:(ncol(df_genesymbol)-1))] # Update row names to include gene symbol instead of transcript_id rownames(df_genesymbol) &lt;- paste0(df_genesymbol$transcript_id, &quot;_&quot;, df_genesymbol$gene_symbol) df_genesymbol$transcript_id &lt;- NULL df_genesymbol$gene_symbol &lt;- NULL # Write the output to a CSV file output_path &lt;- file.path(output_dir, paste0(&quot;gene_symbol_&quot;, sample_name, &quot;_counts.csv&quot;)) write.csv(df_genesymbol, output_path) cat(&quot;Processed sample:&quot;, sample_name, &quot;\\nOutput saved to:&quot;, output_path, &quot;\\n&quot;) return(df_genesymbol) } oarfish_counts &lt;- process_oarfish_files_to_counts_matrix( flames_output_folder = &quot;/data/scratch/users/yairp/FLAMES_Day55/outs/&quot;, sample_name = &quot;oarfish&quot;, output_dir = &quot;./output_files/counts/&quot; ) ## Processed sample: oarfish ## Output saved to: ./output_files/counts//gene_symbol_oarfish_counts.csv Code # Create the Seurat object with iso counts iso_seurat_obj &lt;- CreateSeuratObject(counts = oarfish_counts, project = sample_id) VlnPlot(iso_seurat_obj, features = c(&quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;), ncol = 2) + plot_annotation(title = &quot;QC plots (isoform level) BEFORE Filtering&quot;) 4.2 Filter the new Seurat object based on gene level information We have now created a Seurat object with isoform-level count data. Users can take this object and follow similar processing steps as at the gene level 3, which might include filtering out low-quality cells and removing ambient RNA counts. In our case, we evaluated these steps and found they don’t add much value as low quality cells are already removed at the gene level and we can leverage this information rather than processing the isoform counts in the same way. Additionally, tools like DeconX and SoupX haven’t been tested on isoform count data, so we decided to exclude this analysis. Instead, we believe the most valuable approach is to append the isoform data to our gene-level Seurat object, resulting in two assays: one for gene-level and one for isoform-level data. If users have short-read data, they could similarly add it as a third assay. Since we’ve already filtered out low-quality cells based on our gene-level data, we’ll use these high-quality cells to filter our isoform data. Code #### isofrom assay ## filter the data so iso and gene cells match oarfish_iso_matched_gene &lt;- subset(iso_seurat_obj, cells =filt_seurat_object@graphs[[&quot;RNA_nn&quot;]]@Dimnames[[1]]) #Rejoin data sets after integration oarfish_iso_matched_gene &lt;- JoinLayers(oarfish_iso_matched_gene) counts_table_iso &lt;- oarfish_iso_matched_gene[[&quot;RNA&quot;]]$counts as.data.frame(counts_table_iso) -&gt; df_iso # Remove rows where the sum is 0 df_iso &lt;- df_iso[rowSums(df_iso) != 0, ] filt_seurat_object[[&quot;iso&quot;]] &lt;- CreateAssay5Object(counts = df_iso) # Normalize the new assay data filt_seurat_object &lt;- NormalizeData(filt_seurat_object, assay = &quot;iso&quot;) filt_seurat_object &lt;- FindVariableFeatures(filt_seurat_object, assay = &quot;iso&quot;) filt_seurat_object &lt;- ScaleData(filt_seurat_object, assay = &quot;iso&quot;) filt_seurat_object &lt;- RunPCA(filt_seurat_object, assay = &quot;iso&quot;, reduction.name = &quot;pca_iso&quot;) #Run UMAP filt_seurat_object &lt;- RunUMAP(filt_seurat_object, reduction = &quot;pca_iso&quot;, dims = 1:15, assay = &quot;iso&quot;, reduction.name = &quot;umap_iso&quot;) #check to see that we have two assays filt_seurat_object ## An object of class Seurat ## 93557 features across 309 samples within 3 assays ## Active assay: RNA (14906 features, 2000 variable features) ## 3 layers present: counts, data, scale.data ## 2 other assays present: joined, iso ## 4 dimensional reductions calculated: pca, umap, pca_iso, umap_iso Code # visualize the UMAP for Gene and isoform DimPlot(filt_seurat_object, label = TRUE, reduction = &quot;umap&quot;) + ggtitle(&quot;UMAP gene level clustering&quot;) | DimPlot(filt_seurat_object, label = TRUE, reduction = &quot;umap_iso&quot;) + ggtitle(&quot;UMAP isoform level clustering&quot;) Code seu_obj &lt;- filt_seurat_object saveRDS(seu_obj, file = &quot;./output_files/seu_objects/Day55_tutorial_gene_and_isoform_seurat.rds&quot;) 4.3 Add the isoform assay to the Seurat object Great! We now have an object containing both assays, so we can start by plotting some of our favorite genes and isoforms. This setup gives us the flexibility to visualize gene expression on isoform UMAPs and vice versa, allowing us to integrate and explore the expression of both gene and isoform expression within single cells on the same dimensional reduction. Let’s begin by plotting VIM and TBR1. VIM is a marker of progenitor cells, while TBR1 is a marker of deep layer neurons. Code ####### test plotting on iso assays ## features &lt;- rownames(filt_seurat_object@assays$iso@features) gene &lt;- &quot;VIM&quot; plot_features_list &lt;- grep(paste0(&quot;(^|-|\\\\b)&quot;, gene, &quot;($|\\\\b)&quot;), features, value = TRUE) #We can now plot our favorite gene and all its corresponding isoforms on either the gene or isoform UMAPs. To switch between them, simply change the reduction argument to the desired UMAP (either the gene or isoform reduction) FeaturePlot(filt_seurat_object, features = plot_features_list, reduction = &quot;umap_iso&quot;) Code FeaturePlot(filt_seurat_object, features = gene, reduction = &quot;umap&quot;) Code #lets also plot the isoform data on the gene level clsuters. FeaturePlot(filt_seurat_object, features = plot_features_list, reduction = &quot;umap&quot;) + plot_annotation( title = &#39;VIM isoform expresstion plotted on gene level clusters&#39;, #caption = &#39;made with patchwork&#39;, theme = theme(plot.title = element_text(size = 20)) ) Code gene &lt;- &quot;TBR1&quot; plot_features_list &lt;- grep(paste0(&quot;(^|-|\\\\b)&quot;, gene, &quot;($|\\\\b)&quot;), features, value = TRUE) #We can now plot our favorite gene and all its corresponding isoforms on either the gene or isoform UMAPs. To switch between them, simply change the reduction argument to the desired UMAP (either the gene or isoform reduction) FeaturePlot(filt_seurat_object, features = plot_features_list, reduction = &quot;umap_iso&quot;) Code FeaturePlot(filt_seurat_object, features = gene, reduction = &quot;umap&quot;) Code #lets also plot the isoform data on the gene level clsuters. FeaturePlot(filt_seurat_object, features = plot_features_list, reduction = &quot;umap&quot;) + plot_annotation( title = &#39;TBR1 isoform expresstion plotted on gene level clusters&#39;, #caption = &#39;made with patchwork&#39;, theme = theme(plot.title = element_text(size = 20)) ) We observe that the expression of VIM and TBR1 are is localized to two distinct clusters, which aligns with our expectations. This suggests that some cells remain in the progenitor/radial glial stage, while others have already begun differentiating into neurons. Furthermore, our data reveals isoform-level expression for each of our genes, including TBR1, which shows distinct isoform expression patterns across different cell populations. To plot genes and expressed isoforms from that gene simply change the ‘gene’ value to your favorite gene and run the code chunk above. Now we have a count matrix with two assays, gene and isoform. There are many avenues for analysis. We will begin with finding DE genes and isoforms. Then we identify cell types and perform trajectory analysis. finally we look into interesting isoforms unique to each cluster "],["finding-differentially-expressed-genes-and-isoforms.html", "Chapter 5 Finding differentially expressed genes and isoforms 5.1 Differentially expressed genes by cluster identity 5.2 Identifying cell types 5.3 DE genes and isofroms based on annotaed cell types. 5.4 Volcano plots", " Chapter 5 Finding differentially expressed genes and isoforms 5.1 Differentially expressed genes by cluster identity First we can look at marker genes for each cluster. This will help us identify which genes are DE in each cluster and indicate the identity of each cluster. We will also look at DE isoforms using the same methodology. Code #Find markers for all clusters using the &quot;RNA&quot; and &quot;iso&quot; assay all_markers_gene_cluster &lt;- FindAllMarkers(seu_obj, assay = &quot;RNA&quot;, do.print = TRUE, logfc.threshold = 0.5, min.pct = 0.20, only.pos = TRUE) %&gt;% dplyr::filter(p_val_adj &lt; 0.05) all_markers_iso_cluster &lt;- FindAllMarkers(seu_obj, assay = &quot;iso&quot;, do.print = TRUE, logfc.threshold = 0.5, min.pct = 0.20, only.pos = TRUE) %&gt;% dplyr::filter(p_val_adj &lt; 0.05) #save the list of DE genes write.csv(all_markers_gene_cluster, &quot;./output_files/DE/all_markers_one_gene.csv&quot;) write.csv(all_markers_iso_cluster, &quot;./output_files/DE/all_markers_one_iso.csv&quot;) 5.2 Identifying cell types Based on these differentially expressed (DE) genes, we can identify the cell types present in our sample. This process is often complex and requires prior knowledge of cell markers as well as an understanding of the cell types expected in the sample. An alternative approach is to use automated cell type identification tools. In this tutorial, we will use scType [ref]. However, it is important to note that the accuracy of automated tools varies and depends heavily on the reference database they utilize. Therefore, it is recommended to use a combination of methods to cross-validate cell type identification and ensure robust results. Code # load libraries from sctype lapply(c(&quot;ggraph&quot;,&quot;igraph&quot;,&quot;tidyverse&quot;, &quot;data.tree&quot;), library, character.only = T) ## [[1]] ## [1] &quot;dittoSeq&quot; &quot;FLAMES&quot; &quot;EnhancedVolcano&quot; &quot;ggrepel&quot; &quot;gprofiler2&quot; ## [6] &quot;HGNChelper&quot; &quot;data.tree&quot; &quot;igraph&quot; &quot;ggraph&quot; &quot;lubridate&quot; ## [11] &quot;forcats&quot; &quot;dplyr&quot; &quot;purrr&quot; &quot;readr&quot; &quot;tidyr&quot; ## [16] &quot;tibble&quot; &quot;ggplot2&quot; &quot;tidyverse&quot; &quot;patchwork&quot; &quot;grid&quot; ## [21] &quot;cowplot&quot; &quot;stringr&quot; &quot;DoubletFinder&quot; &quot;celda&quot; &quot;Matrix&quot; ## [26] &quot;BiocParallel&quot; &quot;data.table&quot; &quot;gridExtra&quot; &quot;DropletUtils&quot; &quot;SingleCellExperiment&quot; ## [31] &quot;SummarizedExperiment&quot; &quot;Biobase&quot; &quot;MatrixGenerics&quot; &quot;matrixStats&quot; &quot;Seurat&quot; ## [36] &quot;SeuratObject&quot; &quot;sp&quot; &quot;rtracklayer&quot; &quot;GenomicRanges&quot; &quot;GenomeInfoDb&quot; ## [41] &quot;IRanges&quot; &quot;S4Vectors&quot; &quot;BiocGenerics&quot; &quot;stats4&quot; &quot;stats&quot; ## [46] &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [51] &quot;base&quot; ## ## [[2]] ## [1] &quot;dittoSeq&quot; &quot;FLAMES&quot; &quot;EnhancedVolcano&quot; &quot;ggrepel&quot; &quot;gprofiler2&quot; ## [6] &quot;HGNChelper&quot; &quot;data.tree&quot; &quot;igraph&quot; &quot;ggraph&quot; &quot;lubridate&quot; ## [11] &quot;forcats&quot; &quot;dplyr&quot; &quot;purrr&quot; &quot;readr&quot; &quot;tidyr&quot; ## [16] &quot;tibble&quot; &quot;ggplot2&quot; &quot;tidyverse&quot; &quot;patchwork&quot; &quot;grid&quot; ## [21] &quot;cowplot&quot; &quot;stringr&quot; &quot;DoubletFinder&quot; &quot;celda&quot; &quot;Matrix&quot; ## [26] &quot;BiocParallel&quot; &quot;data.table&quot; &quot;gridExtra&quot; &quot;DropletUtils&quot; &quot;SingleCellExperiment&quot; ## [31] &quot;SummarizedExperiment&quot; &quot;Biobase&quot; &quot;MatrixGenerics&quot; &quot;matrixStats&quot; &quot;Seurat&quot; ## [36] &quot;SeuratObject&quot; &quot;sp&quot; &quot;rtracklayer&quot; &quot;GenomicRanges&quot; &quot;GenomeInfoDb&quot; ## [41] &quot;IRanges&quot; &quot;S4Vectors&quot; &quot;BiocGenerics&quot; &quot;stats4&quot; &quot;stats&quot; ## [46] &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [51] &quot;base&quot; ## ## [[3]] ## [1] &quot;dittoSeq&quot; &quot;FLAMES&quot; &quot;EnhancedVolcano&quot; &quot;ggrepel&quot; &quot;gprofiler2&quot; ## [6] &quot;HGNChelper&quot; &quot;data.tree&quot; &quot;igraph&quot; &quot;ggraph&quot; &quot;lubridate&quot; ## [11] &quot;forcats&quot; &quot;dplyr&quot; &quot;purrr&quot; &quot;readr&quot; &quot;tidyr&quot; ## [16] &quot;tibble&quot; &quot;ggplot2&quot; &quot;tidyverse&quot; &quot;patchwork&quot; &quot;grid&quot; ## [21] &quot;cowplot&quot; &quot;stringr&quot; &quot;DoubletFinder&quot; &quot;celda&quot; &quot;Matrix&quot; ## [26] &quot;BiocParallel&quot; &quot;data.table&quot; &quot;gridExtra&quot; &quot;DropletUtils&quot; &quot;SingleCellExperiment&quot; ## [31] &quot;SummarizedExperiment&quot; &quot;Biobase&quot; &quot;MatrixGenerics&quot; &quot;matrixStats&quot; &quot;Seurat&quot; ## [36] &quot;SeuratObject&quot; &quot;sp&quot; &quot;rtracklayer&quot; &quot;GenomicRanges&quot; &quot;GenomeInfoDb&quot; ## [41] &quot;IRanges&quot; &quot;S4Vectors&quot; &quot;BiocGenerics&quot; &quot;stats4&quot; &quot;stats&quot; ## [46] &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [51] &quot;base&quot; ## ## [[4]] ## [1] &quot;dittoSeq&quot; &quot;FLAMES&quot; &quot;EnhancedVolcano&quot; &quot;ggrepel&quot; &quot;gprofiler2&quot; ## [6] &quot;HGNChelper&quot; &quot;data.tree&quot; &quot;igraph&quot; &quot;ggraph&quot; &quot;lubridate&quot; ## [11] &quot;forcats&quot; &quot;dplyr&quot; &quot;purrr&quot; &quot;readr&quot; &quot;tidyr&quot; ## [16] &quot;tibble&quot; &quot;ggplot2&quot; &quot;tidyverse&quot; &quot;patchwork&quot; &quot;grid&quot; ## [21] &quot;cowplot&quot; &quot;stringr&quot; &quot;DoubletFinder&quot; &quot;celda&quot; &quot;Matrix&quot; ## [26] &quot;BiocParallel&quot; &quot;data.table&quot; &quot;gridExtra&quot; &quot;DropletUtils&quot; &quot;SingleCellExperiment&quot; ## [31] &quot;SummarizedExperiment&quot; &quot;Biobase&quot; &quot;MatrixGenerics&quot; &quot;matrixStats&quot; &quot;Seurat&quot; ## [36] &quot;SeuratObject&quot; &quot;sp&quot; &quot;rtracklayer&quot; &quot;GenomicRanges&quot; &quot;GenomeInfoDb&quot; ## [41] &quot;IRanges&quot; &quot;S4Vectors&quot; &quot;BiocGenerics&quot; &quot;stats4&quot; &quot;stats&quot; ## [46] &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [51] &quot;base&quot; Code lapply(c(&quot;dplyr&quot;,&quot;Seurat&quot;,&quot;HGNChelper&quot;), library, character.only = T) ## [[1]] ## [1] &quot;dittoSeq&quot; &quot;FLAMES&quot; &quot;EnhancedVolcano&quot; &quot;ggrepel&quot; &quot;gprofiler2&quot; ## [6] &quot;HGNChelper&quot; &quot;data.tree&quot; &quot;igraph&quot; &quot;ggraph&quot; &quot;lubridate&quot; ## [11] &quot;forcats&quot; &quot;dplyr&quot; &quot;purrr&quot; &quot;readr&quot; &quot;tidyr&quot; ## [16] &quot;tibble&quot; &quot;ggplot2&quot; &quot;tidyverse&quot; &quot;patchwork&quot; &quot;grid&quot; ## [21] &quot;cowplot&quot; &quot;stringr&quot; &quot;DoubletFinder&quot; &quot;celda&quot; &quot;Matrix&quot; ## [26] &quot;BiocParallel&quot; &quot;data.table&quot; &quot;gridExtra&quot; &quot;DropletUtils&quot; &quot;SingleCellExperiment&quot; ## [31] &quot;SummarizedExperiment&quot; &quot;Biobase&quot; &quot;MatrixGenerics&quot; &quot;matrixStats&quot; &quot;Seurat&quot; ## [36] &quot;SeuratObject&quot; &quot;sp&quot; &quot;rtracklayer&quot; &quot;GenomicRanges&quot; &quot;GenomeInfoDb&quot; ## [41] &quot;IRanges&quot; &quot;S4Vectors&quot; &quot;BiocGenerics&quot; &quot;stats4&quot; &quot;stats&quot; ## [46] &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [51] &quot;base&quot; ## ## [[2]] ## [1] &quot;dittoSeq&quot; &quot;FLAMES&quot; &quot;EnhancedVolcano&quot; &quot;ggrepel&quot; &quot;gprofiler2&quot; ## [6] &quot;HGNChelper&quot; &quot;data.tree&quot; &quot;igraph&quot; &quot;ggraph&quot; &quot;lubridate&quot; ## [11] &quot;forcats&quot; &quot;dplyr&quot; &quot;purrr&quot; &quot;readr&quot; &quot;tidyr&quot; ## [16] &quot;tibble&quot; &quot;ggplot2&quot; &quot;tidyverse&quot; &quot;patchwork&quot; &quot;grid&quot; ## [21] &quot;cowplot&quot; &quot;stringr&quot; &quot;DoubletFinder&quot; &quot;celda&quot; &quot;Matrix&quot; ## [26] &quot;BiocParallel&quot; &quot;data.table&quot; &quot;gridExtra&quot; &quot;DropletUtils&quot; &quot;SingleCellExperiment&quot; ## [31] &quot;SummarizedExperiment&quot; &quot;Biobase&quot; &quot;MatrixGenerics&quot; &quot;matrixStats&quot; &quot;Seurat&quot; ## [36] &quot;SeuratObject&quot; &quot;sp&quot; &quot;rtracklayer&quot; &quot;GenomicRanges&quot; &quot;GenomeInfoDb&quot; ## [41] &quot;IRanges&quot; &quot;S4Vectors&quot; &quot;BiocGenerics&quot; &quot;stats4&quot; &quot;stats&quot; ## [46] &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [51] &quot;base&quot; ## ## [[3]] ## [1] &quot;dittoSeq&quot; &quot;FLAMES&quot; &quot;EnhancedVolcano&quot; &quot;ggrepel&quot; &quot;gprofiler2&quot; ## [6] &quot;HGNChelper&quot; &quot;data.tree&quot; &quot;igraph&quot; &quot;ggraph&quot; &quot;lubridate&quot; ## [11] &quot;forcats&quot; &quot;dplyr&quot; &quot;purrr&quot; &quot;readr&quot; &quot;tidyr&quot; ## [16] &quot;tibble&quot; &quot;ggplot2&quot; &quot;tidyverse&quot; &quot;patchwork&quot; &quot;grid&quot; ## [21] &quot;cowplot&quot; &quot;stringr&quot; &quot;DoubletFinder&quot; &quot;celda&quot; &quot;Matrix&quot; ## [26] &quot;BiocParallel&quot; &quot;data.table&quot; &quot;gridExtra&quot; &quot;DropletUtils&quot; &quot;SingleCellExperiment&quot; ## [31] &quot;SummarizedExperiment&quot; &quot;Biobase&quot; &quot;MatrixGenerics&quot; &quot;matrixStats&quot; &quot;Seurat&quot; ## [36] &quot;SeuratObject&quot; &quot;sp&quot; &quot;rtracklayer&quot; &quot;GenomicRanges&quot; &quot;GenomeInfoDb&quot; ## [41] &quot;IRanges&quot; &quot;S4Vectors&quot; &quot;BiocGenerics&quot; &quot;stats4&quot; &quot;stats&quot; ## [46] &quot;graphics&quot; &quot;grDevices&quot; &quot;utils&quot; &quot;datasets&quot; &quot;methods&quot; ## [51] &quot;base&quot; Code # load gene set preparation function source(&quot;https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/gene_sets_prepare.R&quot;) # load cell type annotation function source(&quot;https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/R/sctype_score_.R&quot;) #### # define functions perform_sctype_analysis &lt;- function(seurat_obj, db_, tissue, gs_removal_list = c(), metadat_col_prefix = &quot;db_prefix&quot;, figure_prefix =&quot;fig_name&quot; , cluster_res = &quot;RNA_snn_res.0.9&quot;, output_file = &quot;&quot;) { # Prepare gene sets gs_list &lt;- gene_sets_prepare(db_, tissue) # Remove specified gene sets for (gs in gs_removal_list) { gs_list[[&quot;gs_positive&quot;]][[gs]] &lt;- NULL } # Calculate sctype scores es.max &lt;- sctype_score(scRNAseqData = seurat_obj@assays$RNA$scale.data, scaled = TRUE, gs = gs_list$gs_positive, gs2 = gs_list$gs_negative) # Set identities in Seurat object Idents(seurat_obj) &lt;- cluster_res # Merge by cluster cL_results &lt;- do.call(&quot;rbind&quot;, lapply(unique(seurat_obj@meta.data[[cluster_res]]), function(cl) { es.max.cl &lt;- sort(rowSums(es.max[, rownames(seurat_obj@meta.data[seurat_obj@meta.data[[cluster_res]] == cl, ])]), decreasing = TRUE) head(data.frame(cluster = cl, type = names(es.max.cl), scores = es.max.cl, ncells = sum(seurat_obj@meta.data[[cluster_res]] == cl)), 10) })) sctype_scores &lt;- cL_results %&gt;% group_by(cluster) %&gt;% top_n(n = 1, wt = scores) # Set low-confident clusters to &quot;Unknown&quot; sctype_scores$scores &lt;- as.numeric(sctype_scores$scores) sctype_scores$type[sctype_scores$scores &lt; sctype_scores$ncells / 4] &lt;- &quot;Unknown&quot; print(sctype_scores[, 1:3]) # Overlay the labels seurat_obj@meta.data[[metadat_col_prefix]] &lt;- &quot;&quot; for (j in unique(sctype_scores$cluster)) { cl_type &lt;- sctype_scores[sctype_scores$cluster == j,] seurat_obj@meta.data[[metadat_col_prefix]][seurat_obj@meta.data[[cluster_res]] == j] &lt;- as.character(cl_type$type[1]) } # Plotting pclass &lt;- DimPlot(seurat_obj, reduction = &quot;umap&quot;, label = TRUE, repel = TRUE, group.by = metadat_col_prefix) print(pclass) # Save the plot to a PDF pdf(file = paste0(figure_prefix, &quot;_&quot;, metadat_col_prefix, &quot;_sctype_genes.pdf&quot;), width = 8, height = 8) print(pclass + ggtitle(figure_prefix)) dev.off() # Save the updated Seurat object to an RDS file if (output_file != &quot;&quot;) { saveRDS(seurat_obj, file = paste0(output_file, &quot;.rds&quot;)) } # Return the updated Seurat object return(seurat_obj) } # Define variables db_ = &quot;https://raw.githubusercontent.com/IanevskiAleksandr/sc-type/master/ScTypeDB_full.xlsx&quot;; # this is a defualt databse from sctype tissue &lt;- &quot;Brain&quot; gs_removal_list &lt;- c(&quot;Tanycytes&quot;) # list of cell types from the db to remove seu_obj &lt;- perform_sctype_analysis(seu_obj, db_, tissue, gs_removal_list, metadat_col_prefix =&quot;sctype_db&quot;, figure_prefix = &quot;Day_55&quot;, output_file = &quot;Day_55&quot;, cluster_res = &quot;RNA_snn_res.0.9&quot;) ## # A tibble: 8 × 3 ## # Groups: cluster [8] ## cluster type scores ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2 Immature neurons 81.3 ## 2 7 Myelinating Schwann cells 7.18 ## 3 0 Mature neurons 108. ## 4 6 Mature neurons 37.4 ## 5 3 Radial glial cells 85.1 ## 6 4 GABAergic neurons 82.8 ## 7 5 Radial glial cells 92.0 ## 8 1 Radial glial cells 94.0 Sctype gives us some indication of which cell types we have in our data. We can use the DE genes to get some more specific info. Glutatergic Neuronal Markers “SLC17A7”,“SLC17A6”,“GRIN1”,“GRIN2B” are all DE in cluster 0 - the mature neuron cluster. This suggests these cells are likely glutamatergic neurons. Code # markers for FeaturePlot(seu_obj, features = c(&quot;SLC17A7&quot;,&quot;SLC17A6&quot;,&quot;GRIN1&quot;,&quot;GRIN2B&quot;)) Code library(gprofiler2) background_genes &lt;- rownames(GetAssayData(seu_obj, assay = &quot;RNA&quot;, layer = &quot;counts&quot;))[ Matrix::rowSums(GetAssayData(seu_obj, assay = &quot;RNA&quot;, layer = &quot;counts&quot;) &gt; 0) &gt; 0 ] # link to production server set_base_url(&quot;https://biit.cs.ut.ee/gprofiler_beta&quot;) # Filter for significant genes in the current cluster sig_genes &lt;- all_markers_gene_cluster %&gt;% filter(cluster == 0 &amp; p_val_adj &lt; 0.05) %&gt;% # Filter for cluster 0 and adjusted p-value &lt; 0.05 pull(gene) # Extract gene names # Step 5: Run g:Profiler for pathway enrichment analysis pathway_results &lt;- gprofiler2::gost( query = sig_genes, ordered_query = TRUE, correction_method = &#39;fdr&#39;, custom_bg = background_genes, sources = c(&quot;GO&quot;, &quot;KEGG&quot;, &quot;REACTOME&quot;) ) # Prepare the data for plotting df_path &lt;- as_tibble(pathway_results$result) %&gt;% filter(term_size &lt; 3000, term_size &gt; 5) %&gt;% filter(!term_id %in% unlist(pathway_results$parents)) # Step 6: Plot top 5 results per database df_path %&gt;% group_by(source) %&gt;% slice_min(p_value, n = 5, with_ties = TRUE) %&gt;% ungroup() %&gt;% ggplot(aes(x = reorder(term_name, -p_value), y = -log10(p_value), fill = source)) + geom_bar(stat = &#39;identity&#39;, position = position_identity()) + coord_flip() + theme_bw() + labs(x = &quot;&quot;) + facet_grid(source ~ ., space = &#39;free&#39;, scales = &#39;free&#39;) + theme(legend.position = &#39;none&#39;) + ggtitle(paste(&quot;Pathway Enrichment for cluster 0&quot;)) # Add title with cluster name Based on the enriched terms, we can confidently conclude that the cell type is neuronal. Both the KEGG and the GO:MF terms support the hypothesis that the cells in cluster 0 have glutamatergic synapses. This analysis can be done on all the clusters in the Seurat object. We can now change the Mature neurons label to Glutamatergic neurons and plot the updated UMAP. Code ## Change the names of ScType DF to Glutatertergic neurons in metadat seu_obj@meta.data$sctype_db &lt;- gsub(&quot;Mature neurons&quot;, &quot;Glutamatergic neurons&quot;, seu_obj@meta.data$sctype_db) DimPlot(seu_obj, group.by = &quot;sctype_db&quot;) | DimPlot(seu_obj, reduction =&quot;umap_iso&quot;, group.by = &quot;sctype_db&quot;) Cell type identification is an iterative process and often one of the most challenging aspects of single-cell analysis. For this example, we will assume that our combined approach, using automated cell type identification, differential expression (DE) analysis based on clusters and Gene set enrichment, provides a good indication of the cell types present in our data. It is possible to explore the radial glial cells in more detail as there are likely many subtypes. For the purposes of the tutorial we will leave this annoation as is. Based on this we have 5 main cell types. Radial glial cells Immature neurons Glutamatergic neurons GABAergic neuorns Myelinating Schwann cells We can use a very nice package called dittoSeq (https://bioconductor.org/packages/devel/bioc/vignettes/dittoSeq/inst/doc/dittoSeq.html) to Visualise scRNA seq data directly from a seurat object. We can plot the distrubtion of the 5 cell types in a few different ways using dittoBarPlot Code library(dittoSeq) dittoBarPlot(seu_obj, &quot;orig.ident&quot;, group.by = &quot;sctype_db&quot;, scale = &quot;count&quot;) | dittoBarPlot(seu_obj, &quot;sctype_db&quot;, group.by = &quot;orig.ident&quot;, scale = &quot;percent&quot;) 5.3 DE genes and isofroms based on annotaed cell types. With this foundation, we can refine our DE analysis by focusing on cell types rather than clusters. This step is critical in nearly all transcriptomic analyses, offering a wide range of possibilities for downstream investigations. A common downstream approach involves generating volcano plots to visualize DE genes and isoforms. performing gene set enrichment analysis, In the following sections, we will demonstrate how to perform these types of analyses and explore their potential applications. The code chunk below provides an example of how to execute these analyses: Code #Set identities based on cell type Idents(seu_obj) &lt;- &quot;sctype_db&quot; all_markers_gene_celltype &lt;- FindAllMarkers( object = seu_obj, assay = &quot;RNA&quot;, group.by = &quot;sctype_db&quot;, # Replace with your metadata column name logfc.threshold = 0.5, min.pct = 0.20, only.pos = FALSE # changed this to false to get negatively DE genes to ) all_markers_iso_celltype &lt;- FindAllMarkers( object = seu_obj, assay = &quot;iso&quot;, group.by = &quot;sctype_db&quot;, # Replace with your metadata column name logfc.threshold = 0.5, min.pct = 0.20, only.pos = FALSE # changed this to false to get negatively DE genes to ) #save the list of DE genes write.csv(all_markers_gene_celltype, &quot;./output_files/DE/all_markers_one_gene_celltype.csv&quot;) write.csv(all_markers_iso_celltype, &quot;./output_files/DE/all_markers_one_iso_celltype.csv&quot;) A basic way of exploring this data is to plot these markers on a heatmap. Seurat has a nice function to do so. Let us plot the top 5 marker gene and isofroms in each cell type Code all_markers_gene_celltype %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% slice_head(n = 5) %&gt;% ungroup() -&gt; G_top5 DoHeatmap(seu_obj, features = G_top5$gene, assay = &quot;RNA&quot;) + NoLegend() Code all_markers_iso_celltype %&gt;% group_by(cluster) %&gt;% dplyr::filter(avg_log2FC &gt; 1) %&gt;% slice_head(n = 5) %&gt;% ungroup() -&gt; I_top5 DoHeatmap(seu_obj, features = I_top5$gene, assay = &quot;iso&quot;) + NoLegend() Personally i find the same plots generated by dittoHeatmap much nicer. The function can also take a list of genes or isofroms of interest. Just remember to set the default assay accordingly. Code #list_of_genes &lt;- c(&quot;VIM&quot;, &quot;MAPT&quot;, &quot;KLC1&quot;, &quot;RBFOX1&quot;, &quot;RBFOX3&quot;) DefaultAssay(seu_obj) &lt;- &quot;RNA&quot; dittoHeatmap(seu_obj, head(G_top5$gene, 25), scaled.to.max = FALSE, complex = FALSE, heatmap.colors.max.scaled = FALSE, annot.by = c(&quot;sctype_db&quot;)) Code DefaultAssay(seu_obj) &lt;- &quot;iso&quot; dittoHeatmap(seu_obj, head(I_top5$gene, 25), scaled.to.max = FALSE, complex = FALSE, heatmap.colors.max.scaled = FALSE, annot.by = c(&quot;sctype_db&quot;)) 5.4 Volcano plots 5.4.1 FIndAllMarkers DE Next we can explore this data by generating some volcano plots. This analysis can be useful to identify genes and isoforms that are DE and also have large fold changes. Often these types of features are the interesting for further analysis. This can be done for any of the cell types defined in our object. For the sake of brevity we will look a the Glutamatergic neurons. When plotting the volcano plots, we observe that many genes exhibit both statistically significant p-values (p &lt; 0.05) and log2 fold changes -2&lt; or &gt;2. To highlight key findings, we have labeled some glutamatergic marker genes, demonstrating that the genes we expect to be upregulated in this cell type are indeed showing the expected pattern. Additionally, we have labeled VIM, a marker of radial glial and projenitor cells. As anticipated, VIM expression is downregulated in these neurons, which aligns with our expectations. Code library(EnhancedVolcano) #filter for the cell type of interest glut_DE_iso &lt;- dplyr::filter(all_markers_iso_celltype, cluster == &quot;Glutamatergic neurons&quot;) glut_DE_gene &lt;- dplyr::filter(all_markers_gene_celltype, cluster == &quot;Glutamatergic neurons&quot;) #we can plot our colcano plot EnhancedVolcano(glut_DE_gene, lab=glut_DE_gene$gene, x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, pCutoff=0.05, FCcutoff=2, boxedLabels = TRUE, drawConnectors = TRUE, selectLab= c(&quot;SLC17A7&quot;,&quot;SLC17A6&quot;,&#39;GRIN1&#39;,&quot;GRIN2B&quot;,&#39;VIM&#39;), title = &quot;Volcano Plot of Differentially Expressed Genes \\n in the Glutamatergic Neurons&quot;) Interestingly our long read data allows us to perform the same analysis but at the isoform level. This can be hard to interpret as there are many more features to plot on the volcano plot. for the sake a clarity we have just labelled TBR1 isoforms. This code bellow will allow users to plot all the isofroms from a given gene on the Volaco plot making interpretation of the data a bit cleaner. Here just like in 3.1 (this is wrong just cheeking the citation works) we can see two different isoforms of the TBR1 gene showing regulation this cell type Code gene &lt;- &quot;TBR1&quot; plot_features_list &lt;- grep(paste0(&quot;(^|-|\\\\b)&quot;, gene, &quot;($|\\\\b)&quot;), features, value = TRUE) EnhancedVolcano(glut_DE_iso, lab=glut_DE_iso$gene, x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, pCutoff=0.05, FCcutoff=2, boxedLabels = TRUE, drawConnectors = TRUE, selectLab= plot_features_list, title = &quot;Volcano Plot of Differentially Expressed Isoforms \\n in the Glutamatergic Neurons&quot;) 5.4.2 FindMarkers DE Finding All Markers is just one type of differential expression (DE) analysis that can be performed. Seurat offers the FindAllMarkers function, which tests the cell type of interest against all other cells. While this approach is often sufficient for identifying marker genes, users may also want to test differences between two specific cell types. For instance, you might want to identify DE genes when comparing glutamatergic neurons to radial glial cells. Below, we demonstrate how to perform this type of analysis with the FindMarkers function. Code DefaultAssay(seu_obj) &lt;- &#39;RNA&#39; # difeine the gne assay as default glu_RG_gene &lt;- FindMarkers(seu_obj, ident.1 = &quot;Glutamatergic neurons&quot;, ident.2 = &quot;Radial glial cells&quot;, logfc.threshold = 0.5, min.pct = 0.02) DefaultAssay(seu_obj) &lt;- &#39;iso&#39; # difeine the gne assay as default glu_RG_iso &lt;- FindMarkers(seu_obj, ident.1 = &quot;Glutamatergic neurons&quot;, ident.2 = &quot;Radial glial cells&quot;, logfc.threshold = 0.5, min.pct = 0.02) #Volcano plots # to plot at gene level #EnhancedVolcano(glu_RG_gene, lab=rownames(glu_RG_gene), # x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, # #selectLab= &quot;VIM&quot;, # pCutoff=0.05, FCcutoff=2, # title = &quot;Volcano Plot of Differentially Expressed Gene \\n Glutamatergic Neurons vs Radial glial #Cells&quot;) #Volcano plots EnhancedVolcano(glu_RG_iso, lab=rownames(glu_RG_iso), x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, #selectLab= &quot;VIM&quot;, pCutoff=0.05, FCcutoff=2, title = &quot;Volcano Plot of Differentially Expressed Isoforms \\n Glutamatergic Neurons vs Radial glial Cells&quot;) The volcano plot above is a useful tool for visualizing differentially expressed (DE) isoforms between two cell types. In this plot, red-labeled isoforms on the right-hand side indicate those that are upregulated in glutamatergic neurons compared to radial glial cells, while red dots on the left represent isoforms that are upregulated in radial glial cells compared to glutamatergic neurons. This analysis serves as an initial overview, and users can further explore the DE list (glu_RG_iso) to select specific isoforms of interest for more detailed analysis. "],["exploring-isoforms-of-interest.html", "Chapter 6 Exploring isoforms of interest 6.1 Isoforms expressed per gene 6.2 Top 10 Genes with Most Isoforms 6.3 Exploring MACF1 isoforms 6.4 Expression of MCAF1 isoforms Across Cell Types 6.5 Visualization of Isoform Structures", " Chapter 6 Exploring isoforms of interest One of the most powerful aspects of long-read single-cell sequencing is its ability to profile isoform-specific information at single-cell resolution. This capability opens up numerous avenues for analysis. In our lab we are interested in exploring the role of RNA isofroms in neuronal differentiation. There are many examples in the literate of isofroms regurgitating this process. We will cover some very general analysis with this focus in mind. For users of long-read single-cell tools who are interested in exploring additional biological questions, we encourage you to share your suggestions and we can expand this section to include analytical approaches that may cover a wider range of applications. 6.1 Isoforms expressed per gene With long-read single-cell data, we have the ability to analyze all the isoforms expressed by a given gene. In our data we can see that most genes express more than one isoform. Code #lets aggeragte the expresstion data by cell type counts &lt;- AggregateExpression( seu_obj, assays = &quot;iso&quot;, return.seurat = FALSE, group.by = &quot;sctype_db&quot; ) as.data.frame(counts) -&gt; df row.names(df) -&gt; df$gene #split transcript ids into gene and transcript id df &lt;- df %&gt;% separate(gene, into = c(&quot;transcript_id&quot;, &quot;gene_id&quot;), sep = &quot;-&quot;, extra = &quot;merge&quot;) #df$transcript_id &lt;- sub(&quot;\\\\..*&quot;, &quot;&quot;, df$transcript_id) # 2. Count the number of isoforms per gene isoform_count_per_gene &lt;- df %&gt;% group_by(gene_id) %&gt;% summarise(n_isoforms = n_distinct(transcript_id)) # 3. count isforms per category isoform_count_per_gene &lt;- isoform_count_per_gene %&gt;% mutate(isoform_category = case_when( n_isoforms == 1 ~ &quot;1&quot;, n_isoforms &gt;= 2 &amp; n_isoforms &lt;= 3 ~ &quot;2-3&quot;, n_isoforms &gt;= 4 &amp; n_isoforms &lt;= 5 ~ &quot;4-5&quot;, n_isoforms &gt;= 6 ~ &quot;6+&quot; )) # 4. Calculate the percentage of genes in each bin isoform_count_summary &lt;- isoform_count_per_gene %&gt;% count(isoform_category) %&gt;% mutate(percent = (n / sum(n)) * 100) ggplot(isoform_count_summary, aes(x = isoform_category, y = percent)) + geom_bar(stat = &quot;identity&quot;, fill = &quot;lightblue&quot;, color = &quot;black&quot;) + labs(title = &quot;Number of Isoforms per Gene&quot;, x = &quot;Isoforms per Gene&quot;, y = &quot;Genes, %&quot;) + theme_minimal() + theme(legend.position = &quot;none&quot;, plot.title = element_text(hjust = 0.5)) 6.2 Top 10 Genes with Most Isoforms We can see that about 45% of genes express a single isoform, however there are some genes like MIR9-1HG that have alot of unique isofroms, 97 in fact. The top 10 genes with the most isofroms are listed bellow. Code # Genes ranked by the number of transcript isoforms detected across all samples gene_transcript_counts &lt;- df %&gt;% group_by(gene_id) %&gt;% summarise(unique_transcripts = n_distinct(transcript_id)) %&gt;% arrange(desc(unique_transcripts)) # Select the top 10 genes based on unique transcript counts top10 &lt;- gene_transcript_counts %&gt;% top_n(10, unique_transcripts) top10 ## # A tibble: 10 × 2 ## gene_id unique_transcripts ## &lt;chr&gt; &lt;int&gt; ## 1 MIR9-1HG 97 ## 2 GAS5 69 ## 3 NUTM2A-AS1 50 ## 4 SNHG1 50 ## 5 FRG1HP 43 ## 6 TMEM161B-DT 43 ## 7 SNHG29 42 ## 8 ENSG00000300022 41 ## 9 FAM66A 39 ## 10 SNHG14 38 We can also plot unique transcripts per gene on a log scale showing that the number of isofroms per gene varies alot across out data. Code # Plot ranked genes by unique &quot;BambuTx&quot; transcript count ggplot(gene_transcript_counts, aes(x = rank(desc(unique_transcripts)), y = unique_transcripts)) + geom_point(color = &quot;darkblue&quot;, size = 1) + # Points for each gene # Log scale for both axes scale_x_log10() + scale_y_log10() + # Title and labels labs( title = &quot;Unique Transcripts per Gene&quot;, x = &quot;Rank (log scale)&quot;, y = &quot;# Transcripts (log scale)&quot; ) + # Highlight and label the top 10 genes with gray background and black border around the text geom_label_repel( data = gene_transcript_counts %&gt;% filter(gene_id %in% top10$gene_id), aes(label = gene_id), fill = &quot;gray&quot;, # Gray background for the label color = &quot;black&quot;, # Black text color label.size = 0.25, # Border thickness around the label label.r = unit(0.15, &quot;lines&quot;), # Border radius (rounded corners) size = 3, box.padding = 0.2, max.overlaps = 14 ) + # Minimal theme and additional styling theme_minimal() + theme( plot.title = element_text(size = 14, face = &quot;bold&quot;, hjust = 0.5), # Centered title axis.text = element_text(size = 10, color = &quot;black&quot;), # Black axis tick labels axis.title = element_text(color = &quot;black&quot;), # Black axis titles panel.grid.minor = element_blank(), panel.border = element_rect(color = &quot;black&quot;, fill = NA, linewidth = 1) # Black border around the graph ) 6.3 Exploring MACF1 isoforms We are interested in isoforms that regulate neuronal differentiation, we can look at some genes of interest. Lets look at gene MACF1. This gene is know to…. [ref]. The gene seems to play some important role in neural migration which is not fully understood yet. First lets try and visualize the expression of these isofroms on a UMAP to see if we can uncover anything interesting. MACF1 has 35 expressed isofroms so lets only plot the top 12 most highly expressed. Code features &lt;- rownames(filt_seurat_object@assays$iso@features) # Define the gene of interest gene &lt;- &quot;MACF1&quot; # Access the data matrix for the &#39;iso&#39; assay expression_matrix &lt;- GetAssayData(filt_seurat_object, assay = &quot;iso&quot;, slot = &quot;data&quot;) # Filter features containing the gene name matching_features &lt;- grep(paste0(&quot;(^|-|\\\\b)&quot;, gene, &quot;($|\\\\b)&quot;), rownames(expression_matrix), value = TRUE) # Subset the expression matrix to include only the matching features subset_expression &lt;- expression_matrix[matching_features, , drop = FALSE] # Calculate the total expression for each matching feature total_expression &lt;- Matrix::rowSums(subset_expression) # Rank features by average expression top_features &lt;- names(sort(total_expression, decreasing = TRUE)) # Print the ranked features (optional) print(data.frame(Feature = top_features, Expression = total_expression[top_features])) ## Feature Expression ## ENST00000361689.7-MACF1 ENST00000361689.7-MACF1 143.862407 ## ENST00000289893.8-MACF1 ENST00000289893.8-MACF1 62.133601 ## ENST00000372925.6-MACF1 ENST00000372925.6-MACF1 45.932634 ## ENST00000372915.8-MACF1 ENST00000372915.8-MACF1 45.461522 ## ENST00000567887.5-MACF1 ENST00000567887.5-MACF1 45.092944 ## ENST00000686657.1-MACF1 ENST00000686657.1-MACF1 44.609476 ## ENST00000564288.6-MACF1 ENST00000564288.6-MACF1 40.689721 ## ENST00000524432.5-MACF1 ENST00000524432.5-MACF1 27.310250 ## ENST00000686687.1-MACF1 ENST00000686687.1-MACF1 19.939477 ## ENST00000497964.1-MACF1 ENST00000497964.1-MACF1 17.945311 ## ENST00000530275.3-MACF1 ENST00000530275.3-MACF1 16.728830 ## ENST00000691623.1-MACF1 ENST00000691623.1-MACF1 14.286232 ## ENST00000602528.2-MACF1 ENST00000602528.2-MACF1 13.942571 ## ENST00000687271.1-MACF1 ENST00000687271.1-MACF1 12.934634 ## ENST00000476350.1-MACF1 ENST00000476350.1-MACF1 12.210176 ## ENST00000496804.5-MACF1 ENST00000496804.5-MACF1 12.181141 ## ENST00000686067.1-MACF1 ENST00000686067.1-MACF1 10.238947 ## ENST00000690080.1-MACF1 ENST00000690080.1-MACF1 8.279051 ## ENST00000497807.1-MACF1 ENST00000497807.1-MACF1 8.021857 ## ENST00000693209.1-MACF1 ENST00000693209.1-MACF1 7.429056 ## ENST00000693392.1-MACF1 ENST00000693392.1-MACF1 7.317640 ## ENST00000472385.2-MACF1 ENST00000472385.2-MACF1 7.075353 ## ENST00000602421.5-MACF1 ENST00000602421.5-MACF1 6.698620 ## ENST00000686260.1-MACF1 ENST00000686260.1-MACF1 6.297806 ## ENST00000688426.1-MACF1 ENST00000688426.1-MACF1 6.232290 ## ENST00000687997.1-MACF1 ENST00000687997.1-MACF1 6.056226 ## ENST00000690939.1-MACF1 ENST00000690939.1-MACF1 5.445340 ## ENST00000683517.1-MACF1 ENST00000683517.1-MACF1 3.526815 ## ENST00000442046.5-MACF1 ENST00000442046.5-MACF1 3.018726 ## ENST00000689911.1-MACF1 ENST00000689911.1-MACF1 2.657853 ## ENST00000484793.5-MACF1 ENST00000484793.5-MACF1 2.181164 ## ENST00000467673.5-MACF1 ENST00000467673.5-MACF1 2.131094 ## ENST00000686941.1-MACF1 ENST00000686941.1-MACF1 1.058887 ## ENST00000672812.1-MACF1 ENST00000672812.1-MACF1 1.055652 ## ENST00000528611.1-MACF1 ENST00000528611.1-MACF1 0.401423 Code options(repr.plot.width=12, repr.plot.height=12) # Plot the top 16 features in descending order of their average expression plots &lt;- FeaturePlot( filt_seurat_object, features = head(top_features, 12), reduction = &quot;umap&quot;, order = TRUE, # Ensures higher-expressing cells are plotted on top pt.size = 1) # Adjust title size for each plot plots &lt;- lapply(plots, function(plot) { plot + theme(plot.title = element_text(size = 8)) }) # Combine the adjusted plots CombinePlots(plots = plots, ncol = 3) 6.4 Expression of MCAF1 isoforms Across Cell Types Lets look at isofroms ENST00000564288.6 ENST00000361689.7 , ENST00000289893.8 and ENST00000524432.5 in some more detail and plot the normalized expression of these isoforms across each cell type. We can see that the expression of ENST00000524432.5shows a cell type specific profile. Code features_MACF1 &lt;- c(&quot;ENST00000564288.6-MACF1&quot;, # cononical &quot;ENST00000361689.7-MACF1&quot;, # most cell types &quot;ENST00000289893.8-MACF1&quot;, # msot cell types &quot;ENST00000524432.5-MACF1&quot;) # radial glia VlnPlot(seu_obj, features = features_MACF1, ncol = 2) We can also show this with A dotplot. Code dittoDotPlot(seu_obj, vars = features_MACF1, group.by = &quot;sctype_db&quot;, scale = FALSE) lets look at our DE results comparing Glutamatergic neurons and Radial glia cells that we calcualted in the previous chapter and filter for significant MCAF1 isoforms. If we plot these features on a Volcano plotwe see isoform ENST00000524432.5 is enriched in radial glia cells. In fact its enrichment compared to Glutamatergic neurons is pretty high with a Log2fold change of 4.16. Code glu_RG_iso %&gt;% rownames_to_column(&quot;isoform&quot;) %&gt;% filter(grepl(&quot;MACF1&quot;, isoform)) %&gt;% filter(p_val_adj &lt; 0.5) ## isoform p_val avg_log2FC pct.1 pct.2 p_val_adj ## 1 ENST00000524432.5-MACF1 1.025842e-10 -4.163237 0.011 0.384 6.539231e-06 Code EnhancedVolcano(glu_RG_iso, lab=rownames(glu_RG_iso), x=&#39;avg_log2FC&#39;, y=&#39;p_val_adj&#39;, #selectLab= &quot;VIM&quot;, pCutoff=0.05, FCcutoff=2, selectLab = &quot;ENST00000524432.5-MACF1&quot;, boxedLabels = TRUE, drawConnectors = TRUE, title = &quot;Volcano Plot showing ENST00000524432.5-MACF1 isoforms \\n Glutamatergic Neurons vs Radial glial Cells&quot;) 6.5 Visualization of Isoform Structures Now that we know some MCAF1 isoforms expression is significantly different in these two cell populations it may be of interest to visualize the isoform structures. This analysis will help us explore the similarities and differences between our isoforms of interest. There are many visualization options available to us and many of these are available in R. In fact FLAMES has its own visualization function FLAMES::plot_isoform_reduced_dim . This function is designed to work on single cell experiment object and not Seurat object. Although it is possible to switch between these formats, for the purpose of this tutorial we want to keep file conversations to a minimum to keep the analysis simple. We instead recommend using IsoViz (Wan et al., 2024), which was developed in the Clark Lab. The tool is a web application specifically designed for visualizing isoform structures. This visualization can provide valuable insights into the potential functions of different isoforms. First lets prepare the count data that we will load into Isoviz1 Code #extract some isoform expression data to visualize in isoviz #use pseudobulk counts we from above row.names(df) &lt;- NULL df$gene_id &lt;- NULL write.csv(df, &quot;output_files/psedubulk_exp.csv&quot;, row.names = FALSE) To use IsoViz click on the following link https://isomix.org/isovis/ and uplaod the isofrom_annotated.gtf file located in the FLAMES output dir and psedubulk_exp.csv generated above For more detail on how to use Isoviz click the ‘IsoViz tutorial’ button or read the publication. Embedded bellow is the figure generated by Isoviz. When Viewing this data in the web broswer users will have more functionality. (eg looking a protein domains or clicking on ENST ids and being linked to ensemble). Here we and visualizing our 4 isofroms of interest. We can see MCAF1 is a very complex gene with many exons, a variety of alternative transcription start sites and ORFs. Our pseudobulk expression analysis clearly demonstrates that ENST00000524432.5 is predominantly expressed in radial glia cells. This isoform is particularly interesting, as it is significantly shorter than others and lacks many of the protein domains present in ENST00000564288.6, the canonical isoform. Notably, all four isoforms exhibit different transcription start sites (TSS), suggesting that TSS variation may be linked to cell-type-specific expression or distinct protein functions. Additionally, ENST00000289893.8 shows comparably high expression levels across most cell types. However, a deeper exploration of this isoform reveals that it does not produce a functional protein. This is evident from examining the Ensembl data, accessible via the hyperlink, where we can see that no open reading frames (ORFs) are associated with this transcript. Code knitr::include_graphics(&quot;images/IsoVis_ENSG00000127603.png&quot;) Figure 6.1: IsoViz visualization of 4 MACF1 isoforms. Structural visualization aids in identifying critical variations such as alternative splicing events, unique protein-coding regions, and functional domains and severs as a powerful tool to infer isoform function. There are lots of additional analysis that could be performed to further explore the function of our MCAF1 isofroms, these include domain enrichment analysis and protein folding to name a few. Idea to add Splice Variant Impact Analyze how alternative splicing affects protein structure and function using tools like PROSITE or structural prediction algorithms. References Wan, C. Y., Davis, J., Chauhan, M., Gleeson, J., Prawer, Y. J., De Paoli-Iseppi, R., Wells, C., Choi, J., &amp; Clark, M. (2024). IsoVis a webserver for visualization and annotation of alternative RNA isoforms. Nucleic Acids Research, 52(W1), W341–W347. https://doi.org/10.1093/nar/gkae343 Please be careful when interpreting pseudubulk expression data. Although the data can give you some indication of relative expression across cell types, this numbers can be affected by the number of cells in each cluster.↩︎ "],["session-info.html", "Chapter 7 Session info", " Chapter 7 Session info ## R version 4.4.0 (2024-04-24) ## Platform: x86_64-pc-linux-gnu ## Running under: Red Hat Enterprise Linux 9.4 (Plow) ## ## Matrix products: default ## BLAS/LAPACK: FlexiBLAS OPENBLAS; LAPACK version 3.10.1 ## ## locale: ## [1] LC_CTYPE=en_AU.UTF-8 LC_NUMERIC=C LC_TIME=en_AU.UTF-8 LC_COLLATE=en_AU.UTF-8 ## [5] LC_MONETARY=en_AU.UTF-8 LC_MESSAGES=en_AU.UTF-8 LC_PAPER=en_AU.UTF-8 LC_NAME=C ## [9] LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_AU.UTF-8 LC_IDENTIFICATION=C ## ## time zone: Australia/Melbourne ## tzcode source: system (glibc) ## ## attached base packages: ## [1] grid stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] dittoSeq_1.16.0 FLAMES_2.0.2 EnhancedVolcano_1.24.0 ggrepel_0.9.6 ## [5] gprofiler2_0.2.3 HGNChelper_0.8.14 data.tree_1.1.0 igraph_2.1.1 ## [9] ggraph_2.2.1 lubridate_1.9.3 forcats_1.0.0 dplyr_1.1.4 ## [13] purrr_1.0.2 readr_2.1.5 tidyr_1.3.1 tibble_3.2.1 ## [17] ggplot2_3.5.1 tidyverse_2.0.0 patchwork_1.3.0 cowplot_1.1.3 ## [21] stringr_1.5.1 DoubletFinder_2.0.4 celda_1.20.0 Matrix_1.7-1 ## [25] BiocParallel_1.40.0 data.table_1.16.2 gridExtra_2.3 DropletUtils_1.26.0 ## [29] SingleCellExperiment_1.28.0 SummarizedExperiment_1.36.0 Biobase_2.66.0 MatrixGenerics_1.18.0 ## [33] matrixStats_1.4.1 Seurat_5.1.0 SeuratObject_5.0.2 sp_2.1-4 ## [37] rtracklayer_1.64.0 GenomicRanges_1.58.0 GenomeInfoDb_1.42.0 IRanges_2.40.0 ## [41] S4Vectors_0.44.0 BiocGenerics_0.52.0 ## ## loaded via a namespace (and not attached): ## [1] graph_1.84.1 ica_1.0-3 plotly_4.10.4 Formula_1.2-5 ## [5] scater_1.34.0 zlibbioc_1.52.0 tidyselect_1.2.1 bit_4.5.0 ## [9] doParallel_1.0.17 clue_0.3-65 lattice_0.22-6 rjson_0.2.23 ## [13] blob_1.2.4 S4Arrays_1.6.0 parallel_4.4.0 dichromat_2.0-0.1 ## [17] png_0.1-8 cli_3.6.3 ProtGenerics_1.38.0 goftest_1.2-3 ## [21] BiocIO_1.16.0 bluster_1.16.0 basilisk.utils_1.18.0 BiocNeighbors_2.0.0 ## [25] uwot_0.2.2 curl_6.0.0 mime_0.12 evaluate_1.0.1 ## [29] leiden_0.4.3.1 ComplexHeatmap_2.22.0 stringi_1.8.4 backports_1.5.0 ## [33] XML_3.99-0.17 httpuv_1.6.15 AnnotationDbi_1.68.0 magrittr_2.0.3 ## [37] rappdirs_0.3.3 splines_4.4.0 sctransform_0.4.1 ggbeeswarm_0.7.2 ## [41] DBI_1.2.3 HDF5Array_1.34.0 jquerylib_0.1.4 withr_3.0.2 ## [45] xgboost_1.7.8.1 lmtest_0.9-40 RBGL_1.82.0 tidygraph_1.3.1 ## [49] BiocManager_1.30.25 htmlwidgets_1.6.4 fs_1.6.5 biomaRt_2.62.0 ## [53] bambu_3.8.0 labeling_0.4.3 SparseArray_1.6.0 reticulate_1.39.0 ## [57] VariantAnnotation_1.52.0 zoo_1.8-12 GGally_2.2.1 XVector_0.46.0 ## [61] knitr_1.48 UCSC.utils_1.2.0 timechange_0.3.0 foreach_1.5.2 ## [65] fansi_1.0.6 rhdf5_2.50.0 R.oo_1.27.0 RSpectra_0.16-2 ## [69] irlba_2.3.5.1 ggrastr_1.0.2 fastDummies_1.7.4 lazyeval_0.2.2 ## [73] yaml_2.3.10 survival_3.7-0 SpatialExperiment_1.16.0 scattermore_1.2 ## [77] crayon_1.5.3 RcppAnnoy_0.0.22 RColorBrewer_1.1-3 progressr_0.15.0 ## [81] tweenr_2.0.3 later_1.3.2 ggridges_0.5.6 codetools_0.2-20 ## [85] base64enc_0.1-3 GlobalOptions_0.1.2 KEGGREST_1.46.0 Rtsne_0.17 ## [89] shape_1.4.6.1 limma_3.62.1 Rsamtools_2.20.0 filelock_1.0.3 ## [93] splitstackshape_1.4.8 foreign_0.8-87 pkgconfig_2.0.3 xml2_1.3.5 ## [97] spatstat.univar_3.0-0 servr_0.32 GenomicAlignments_1.40.0 spatstat.sparse_3.1-0 ## [101] BSgenome_1.74.0 viridisLite_0.4.2 biovizBase_1.54.0 xtable_1.8-4 ## [105] highr_0.11 plyr_1.8.9 httr_1.4.7 tools_4.4.0 ## [109] globals_0.16.3 beeswarm_0.4.0 htmlTable_2.4.3 checkmate_2.3.2 ## [113] nlme_3.1-166 dbplyr_2.5.0 digest_0.6.37 bookdown_0.41 ## [117] dir.expiry_1.14.0 farver_2.1.2 tzdb_0.4.0 AnnotationFilter_1.30.0 ## [121] reshape2_1.4.4 yulab.utils_0.1.7 WriteXLS_6.7.0 viridis_0.6.5 ## [125] rpart_4.1.23 glue_1.8.0 cachem_1.1.0 BiocFileCache_2.14.0 ## [129] polyclip_1.10-7 Hmisc_5.2-0 generics_0.1.3 Biostrings_2.72.1 ## [133] presto_1.0.0 parallelly_1.38.0 txdbmaker_1.0.1 pkgload_1.3.3 ## [137] statmod_1.5.0 RcppHNSW_0.6.0 ScaledMatrix_1.14.0 pbapply_1.7-2 ## [141] httr2_0.2.3 spam_2.10-0 ggbio_1.54.0 dqrng_0.4.1 ## [145] utf8_1.2.4 basilisk_1.18.0 graphlayouts_1.2.0 RcppEigen_0.3.4.0.2 ## [149] shiny_1.9.1 GenomeInfoDbData_1.2.13 R.utils_2.12.3 rhdf5filters_1.18.0 ## [153] RCurl_1.98-1.16 memoise_2.0.1 rmarkdown_2.29 pheatmap_1.0.12 ## [157] scales_1.3.0 R.methodsS3_1.8.2 future_1.34.0 RANN_2.6.2 ## [161] OrganismDbi_1.48.0 spatstat.data_3.1-2 rstudioapi_0.15.0 cluster_2.1.6 ## [165] spatstat.utils_3.1-1 hms_1.1.3 fitdistrplus_1.2-1 munsell_0.5.1 ## [169] colorspace_2.1-1 rlang_1.1.4 DelayedMatrixStats_1.28.0 sparseMatrixStats_1.18.0 ## [173] dotCall64_1.2 ggforce_0.4.2 circlize_0.4.16 scuttle_1.16.0 ## [177] xfun_0.49 iterators_1.0.14 abind_1.4-8 MCMCprecision_0.4.0 ## [181] Rhdf5lib_1.28.0 bitops_1.0-9 promises_1.3.0 scatterpie_0.2.4 ## [185] RSQLite_2.3.7 openxlsx_4.2.6.1 DelayedArray_0.32.0 compiler_4.4.0 ## [189] prettyunits_1.2.0 beachmat_2.22.0 listenv_0.9.1 Rcpp_1.0.13-1 ## [193] enrichR_3.2 edgeR_4.4.0 BiocSingular_1.22.0 tensor_1.5 ## [197] MASS_7.3-61 progress_1.2.3 spatstat.random_3.3-1 R6_2.5.1 ## [201] fastmap_1.2.0 vipor_0.4.7 ensembldb_2.28.0 ROCR_1.0-11 ## [205] ggstats_0.8.0 rsvd_1.0.5 nnet_7.3-19 gtable_0.3.6 ## [209] KernSmooth_2.23-24 miniUI_0.1.1.1 deldir_2.0-4 htmltools_0.5.8.1 ## [213] bit64_4.5.2 spatstat.explore_3.3-1 lifecycle_1.0.4 zip_2.3.0 ## [217] restfulr_0.0.15 sass_0.4.9 vctrs_0.6.5 spatstat.geom_3.3-2 ## [221] scran_1.32.0 ggfun_0.1.7 future.apply_1.11.3 bslib_0.8.0 ## [225] pillar_1.9.0 GenomicFeatures_1.58.0 magick_2.8.5 metapod_1.14.0 ## [229] locfit_1.5-9.10 combinat_0.0-8 jsonlite_1.8.9 GetoptLong_1.0.5 Tian, L., Jabbari, J. S., Thijssen, R., Gouil, Q., Amarasinghe, S. L., Voogd, O., Kariyawasam, H., Du, M. R. M., Schuster, J., Wang, C., Su, S., Dong, X., Law, C. W., Lucattini, A., Prawer, Y. D. J., Collar-Fernández, C., Chung, J. D., Naim, T., Chan, A., … Ritchie, M. E. (2021). Comprehensive characterization of single-cell full-length isoforms in human and mouse with long-read sequencing. Genome Biology, 22(1). https://doi.org/10.1186/s13059-021-02525-6 Wan, C. Y., Davis, J., Chauhan, M., Gleeson, J., Prawer, Y. J., De Paoli-Iseppi, R., Wells, C., Choi, J., &amp; Clark, M. (2024). IsoVis a webserver for visualization and annotation of alternative RNA isoforms. Nucleic Acids Research, 52(W1), W341–W347. https://doi.org/10.1093/nar/gkae343 You, Y., Prawer, Y. D. J., De Paoli-Iseppi, R., Hunt, C. P. J., Parish, C. L., Shim, H., &amp; Clark, M. B. (2023). Identification of cell barcodes from long-read single-cell RNA-seq with BLAZE. Genome Biology, 24(1). https://doi.org/10.1186/s13059-023-02907-y "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
